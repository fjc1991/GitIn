{
  "project_name": "003random",
  "repository_url": "https://github.com/003random/ICU",
  "repository_name": "ICU",
  "ecosystem": "github",
  "repo_category": "all",
  "analysis_period": {
    "start_date": "2018-03-29",
    "end_date": "2018-07-11",
    "full_history": false
  },
  "commits": [
    {"hash": "f30bfc8542a2ab1896d10d7e0543c3e8ef9aafa2", "msg": "First commit", "author": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "committer": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "author_date": "2018-03-29 09:58:06+02:00", "author_timezone": -7200, "committer_date": "2018-03-29 09:58:06+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": [], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 0, "insertions": 827, "lines": 827, "files": 14, "modified_files": [{"old_path": null, "new_path": "database/additional_tools/get_subdomains.py", "filename": "get_subdomains.py", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1,24 @@\n+#!/usr/bin/python\n+import os, sys, MySQLdb\n+\n+connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+domain = sys.argv[1].strip()\n+cursor = connection.cursor()\n+\n+cursor.execute (\"select Domain from domains where TopDomainID = (select DomainID from domains where Domain = %s)\", (domain,))\n+\n+data = cursor.fetchall()\n+#Get first the values out of tuple and create an array with them\n+database_domains = [d[0] for d in data]\n+\n+for row in database_domains:\n+\tprint row\n+\n+#cursor.execute(\"select DomainID from domains where Domain = %s\", (domain,))\n+#data = cursor.fetchall()\n+#data = data[0][0]\n+#print \"also the TopDomainId = \" + str(data)\n+\n+cursor.close ()\n+connection.close ()\n+sys.exit()\n", "diff_parsed": {"added": [[1, "#!/usr/bin/python"], [2, "import os, sys, MySQLdb"], [3, ""], [4, "connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [5, "domain = sys.argv[1].strip()"], [6, "cursor = connection.cursor()"], [7, ""], [8, "cursor.execute (\"select Domain from domains where TopDomainID = (select DomainID from domains where Domain = %s)\", (domain,))"], [9, ""], [10, "data = cursor.fetchall()"], [11, "#Get first the values out of tuple and create an array with them"], [12, "database_domains = [d[0] for d in data]"], [13, ""], [14, "for row in database_domains:"], [15, "\tprint row"], [16, ""], [17, "#cursor.execute(\"select DomainID from domains where Domain = %s\", (domain,))"], [18, "#data = cursor.fetchall()"], [19, "#data = data[0][0]"], [20, "#print \"also the TopDomainId = \" + str(data)"], [21, ""], [22, "cursor.close ()"], [23, "connection.close ()"], [24, "sys.exit()"]], "deleted": []}, "added_lines": 24, "deleted_lines": 0, "source_code": "#!/usr/bin/python\nimport os, sys, MySQLdb\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\ndomain = sys.argv[1].strip()\ncursor = connection.cursor()\n\ncursor.execute (\"select Domain from domains where TopDomainID = (select DomainID from domains where Domain = %s)\", (domain,))\n\ndata = cursor.fetchall()\n#Get first the values out of tuple and create an array with them\ndatabase_domains = [d[0] for d in data]\n\nfor row in database_domains:\n\tprint row\n\n#cursor.execute(\"select DomainID from domains where Domain = %s\", (domain,))\n#data = cursor.fetchall()\n#data = data[0][0]\n#print \"also the TopDomainId = \" + str(data)\n\ncursor.close ()\nconnection.close ()\nsys.exit()\n", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": 12, "complexity": 0, "token_count": 99}, {"old_path": null, "new_path": "database/additional_tools/sublister_to_db.py", "filename": "sublister_to_db.py", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1,56 @@\n+#!/usr/bin/python\n+import os, sys, MySQLdb\n+\n+try:\n+\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+\tdomain = sys.argv[1].strip()\n+\tcursor = connection.cursor()\n+\tscanId = sys.argv[2]\n+\n+\tif not os.path.exists(\"/tmp/recon_domain_files\"):\n+\t\tos.makedirs(\"/tmp/recon_domain_files\")\n+\n+\tif not os.path.exists(\"/tmp/recon_domain_files/\"+domain+\"/\"):\n+\t    os.makedirs(\"/tmp/recon_domain_files/\"+domain+\"/\")\n+\n+\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../../dependencies/sublister/sublist3r.py -o /tmp/recon_domain_files/\"+domain+\"/domains-all.txt -d \"+domain)\n+\n+\tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n+\tdatabase_data = cursor.fetchall()\n+\tdatabase_domains = [d[0] for d in database_data]\n+\n+        non_active_subdomains = [x[0] for x in database_data if ord(x[2]) == False]\n+        program = [x[3] for x in database_data if x[0] == domain][0]\n+        topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n+\n+\tdomains_all = open(\"/tmp/recon_domain_files/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n+\tdomains_all.extend(x for x in database_domains if x not in domains_all)\n+\n+\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../../tools/online.py /tmp/recon_domain_files/\"+domain+\"/domains-all.txt /tmp/recon_domain_files/\"+domain+\"/domains-online.txt\")\n+\n+\tdomains_online = open(\"/tmp/recon_domain_files/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n+\n+\tfor sub_domain in domains_all:\n+\t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n+\t\tif sub_domain in domains_online:\n+\t\t\tactive=True\n+\t\t\tif sub_domain in non_active_subdomains:\n+\t\t\t\tinsertScanId = scanId\n+\t\telse:\n+\t\t\tactive=False\n+\n+\t\tif sub_domain:\n+\t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))\n+\t\t\tconnection.commit()\n+\n+\n+\tcursor.close ()\n+\tconnection.close ()\n+except Exception as e:\n+\tprint \"error in sublister_to_db.py with main domain; \" + domain\n+\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in sublister_to_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n+\tconnection.commit()\n+\tcursor.close()\n+\tconnection.close()\n+\tprint e\n+sys.exit()\n", "diff_parsed": {"added": [[1, "#!/usr/bin/python"], [2, "import os, sys, MySQLdb"], [3, ""], [4, "try:"], [5, "\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [6, "\tdomain = sys.argv[1].strip()"], [7, "\tcursor = connection.cursor()"], [8, "\tscanId = sys.argv[2]"], [9, ""], [10, "\tif not os.path.exists(\"/tmp/recon_domain_files\"):"], [11, "\t\tos.makedirs(\"/tmp/recon_domain_files\")"], [12, ""], [13, "\tif not os.path.exists(\"/tmp/recon_domain_files/\"+domain+\"/\"):"], [14, "\t    os.makedirs(\"/tmp/recon_domain_files/\"+domain+\"/\")"], [15, ""], [16, "\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../../dependencies/sublister/sublist3r.py -o /tmp/recon_domain_files/\"+domain+\"/domains-all.txt -d \"+domain)"], [17, ""], [18, "\tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))"], [19, "\tdatabase_data = cursor.fetchall()"], [20, "\tdatabase_domains = [d[0] for d in database_data]"], [21, ""], [22, "        non_active_subdomains = [x[0] for x in database_data if ord(x[2]) == False]"], [23, "        program = [x[3] for x in database_data if x[0] == domain][0]"], [24, "        topDomainID = [x[4] for x in database_data if x[0] == domain][0]"], [25, ""], [26, "\tdomains_all = open(\"/tmp/recon_domain_files/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')"], [27, "\tdomains_all.extend(x for x in database_domains if x not in domains_all)"], [28, ""], [29, "\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../../tools/online.py /tmp/recon_domain_files/\"+domain+\"/domains-all.txt /tmp/recon_domain_files/\"+domain+\"/domains-online.txt\")"], [30, ""], [31, "\tdomains_online = open(\"/tmp/recon_domain_files/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')"], [32, ""], [33, "\tfor sub_domain in domains_all:"], [34, "\t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]"], [35, "\t\tif sub_domain in domains_online:"], [36, "\t\t\tactive=True"], [37, "\t\t\tif sub_domain in non_active_subdomains:"], [38, "\t\t\t\tinsertScanId = scanId"], [39, "\t\telse:"], [40, "\t\t\tactive=False"], [41, ""], [42, "\t\tif sub_domain:"], [43, "\t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))"], [44, "\t\t\tconnection.commit()"], [45, ""], [46, ""], [47, "\tcursor.close ()"], [48, "\tconnection.close ()"], [49, "except Exception as e:"], [50, "\tprint \"error in sublister_to_db.py with main domain; \" + domain"], [51, "\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in sublister_to_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))"], [52, "\tconnection.commit()"], [53, "\tcursor.close()"], [54, "\tconnection.close()"], [55, "\tprint e"], [56, "sys.exit()"]], "deleted": []}, "added_lines": 56, "deleted_lines": 0, "source_code": "#!/usr/bin/python\nimport os, sys, MySQLdb\n\ntry:\n\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\tdomain = sys.argv[1].strip()\n\tcursor = connection.cursor()\n\tscanId = sys.argv[2]\n\n\tif not os.path.exists(\"/tmp/recon_domain_files\"):\n\t\tos.makedirs(\"/tmp/recon_domain_files\")\n\n\tif not os.path.exists(\"/tmp/recon_domain_files/\"+domain+\"/\"):\n\t    os.makedirs(\"/tmp/recon_domain_files/\"+domain+\"/\")\n\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../../dependencies/sublister/sublist3r.py -o /tmp/recon_domain_files/\"+domain+\"/domains-all.txt -d \"+domain)\n\n\tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n\tdatabase_data = cursor.fetchall()\n\tdatabase_domains = [d[0] for d in database_data]\n\n        non_active_subdomains = [x[0] for x in database_data if ord(x[2]) == False]\n        program = [x[3] for x in database_data if x[0] == domain][0]\n        topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n\n\tdomains_all = open(\"/tmp/recon_domain_files/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n\tdomains_all.extend(x for x in database_domains if x not in domains_all)\n\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../../tools/online.py /tmp/recon_domain_files/\"+domain+\"/domains-all.txt /tmp/recon_domain_files/\"+domain+\"/domains-online.txt\")\n\n\tdomains_online = open(\"/tmp/recon_domain_files/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n\n\tfor sub_domain in domains_all:\n\t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n\t\tif sub_domain in domains_online:\n\t\t\tactive=True\n\t\t\tif sub_domain in non_active_subdomains:\n\t\t\t\tinsertScanId = scanId\n\t\telse:\n\t\t\tactive=False\n\n\t\tif sub_domain:\n\t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))\n\t\t\tconnection.commit()\n\n\n\tcursor.close ()\n\tconnection.close ()\nexcept Exception as e:\n\tprint \"error in sublister_to_db.py with main domain; \" + domain\n\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in sublister_to_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n\tconnection.commit()\n\tcursor.close()\n\tconnection.close()\n\tprint e\nsys.exit()\n", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": 42, "complexity": 0, "token_count": 473}, {"old_path": null, "new_path": "database/db_test.py", "filename": "db_test.py", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1,20 @@\n+#!/usr/bin/python\n+\n+import MySQLdb\n+import sys\n+\n+connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+\n+cursor = connection.cursor ()\n+cursor.execute (\"select Domain ,Active, Program, InScope from domains limit 5\")\n+data = cursor.fetchall ()\n+\n+for row in data :\n+\tprint \"\\n --- \\n\"\n+\tprint \"domain: \" + row[0] + \"\\n\" + \"active: \" + str(ord(row[1])) + \"\\n\" + \"program: \" + row[2] + \"\\n\" + \"scope: \" + str(ord(row[1]))\n+\n+\n+cursor.close ()\n+connection.close ()\n+sys.exit()\n+\n", "diff_parsed": {"added": [[1, "#!/usr/bin/python"], [2, ""], [3, "import MySQLdb"], [4, "import sys"], [5, ""], [6, "connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [7, ""], [8, "cursor = connection.cursor ()"], [9, "cursor.execute (\"select Domain ,Active, Program, InScope from domains limit 5\")"], [10, "data = cursor.fetchall ()"], [11, ""], [12, "for row in data :"], [13, "\tprint \"\\n --- \\n\""], [14, "\tprint \"domain: \" + row[0] + \"\\n\" + \"active: \" + str(ord(row[1])) + \"\\n\" + \"program: \" + row[2] + \"\\n\" + \"scope: \" + str(ord(row[1]))"], [15, ""], [16, ""], [17, "cursor.close ()"], [18, "connection.close ()"], [19, "sys.exit()"], [20, ""]], "deleted": []}, "added_lines": 20, "deleted_lines": 0, "source_code": "#!/usr/bin/python\n\nimport MySQLdb\nimport sys\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\ncursor = connection.cursor ()\ncursor.execute (\"select Domain ,Active, Program, InScope from domains limit 5\")\ndata = cursor.fetchall ()\n\nfor row in data :\n\tprint \"\\n --- \\n\"\n\tprint \"domain: \" + row[0] + \"\\n\" + \"active: \" + str(ord(row[1])) + \"\\n\" + \"program: \" + row[2] + \"\\n\" + \"scope: \" + str(ord(row[1]))\n\n\ncursor.close ()\nconnection.close ()\nsys.exit()\n\n", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": 12, "complexity": 0, "token_count": 114}, {"old_path": null, "new_path": "database/init_db.py", "filename": "init_db.py", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1,86 @@\n+#!/usr/bin/python\n+\n+import MySQLdb\n+import sys\n+\n+connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+\n+cursor = connection.cursor ()\n+\n+cursor.execute (\"\"\"\n+CREATE TABLE domains\n+(\n+    DomainID int NOT NULL AUTO_INCREMENT,\n+    Program varchar(255) not null,\n+    TopDomainID int default null,\n+    Active bit NOT NULL DEFAULT 0,\n+    InScope bit NOT NULL DEFAULT 0,\n+    Domain varchar(100) not null,\n+    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n+    PRIMARY KEY (DomainID),\n+    FOREIGN KEY (TopDomainID) REFERENCES domains(DomainID),\n+    UNIQUE (Domain)\n+);\n+\"\"\")\n+\n+cursor.execute (\"\"\"\n+CREATE TABLE directories\n+(\n+    DirectoryID int NOT NULL AUTO_INCREMENT,\n+    DomainID int NOT NULL,\n+    Directory varchar(255) not null,\n+    File bit NOT NULL DEFAULT 0,\n+    Active bit NOT NULL DEFAULT 0,\n+    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n+    PRIMARY KEY (DirectoryID),\n+    FOREIGN KEY (DomainID) REFERENCES domains(DomainID)\n+);\n+\"\"\")\n+\n+cursor.execute (\"\"\"\n+CREATE TABLE crlf\n+(\n+    CRLFID int NOT NULL AUTO_INCREMENT,\n+    DomainID int NOT NULL,\n+    Payload varchar(255) not null,\n+    Active bit NOT NULL DEFAULT 0,\n+    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n+    PRIMARY KEY (CRLFID),\n+    FOREIGN KEY (DomainID) REFERENCES domains(DomainID)\n+);\n+\n+\"\"\")\n+\n+cursor.execute (\"\"\"\n+CREATE TABLE ports\n+(\n+    PortID int NOT NULL AUTO_INCREMENT,\n+    DomainID int NOT NULL,\n+    Port int NOT NULL,\n+    PortInfo varchar(255),\n+    Active bit NOT NULL DEFAULT 0,\n+    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n+    PRIMARY KEY (PortID),\n+    FOREIGN KEY (DomainID) REFERENCES domains(DomainID)\n+);\n+\n+\"\"\")\n+\n+cursor.execute (\"\"\"\n+CREATE TABLE errors\n+(\n+    ErrorID int NOT NULL AUTO_INCREMENT,\n+    Domain varchar(255),\n+    ErrorDescription varchar(255),\n+    Error varchar(255),\n+    Script varchar(255),\n+    ErrorDate timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n+    PRIMARY KEY (ErrorID)\n+);\n+\n+\"\"\")\n+\n+\n+cursor.close ()\n+connection.close ()\n+sys.exit()\n", "diff_parsed": {"added": [[1, "#!/usr/bin/python"], [2, ""], [3, "import MySQLdb"], [4, "import sys"], [5, ""], [6, "connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [7, ""], [8, "cursor = connection.cursor ()"], [9, ""], [10, "cursor.execute (\"\"\""], [11, "CREATE TABLE domains"], [12, "("], [13, "    DomainID int NOT NULL AUTO_INCREMENT,"], [14, "    Program varchar(255) not null,"], [15, "    TopDomainID int default null,"], [16, "    Active bit NOT NULL DEFAULT 0,"], [17, "    InScope bit NOT NULL DEFAULT 0,"], [18, "    Domain varchar(100) not null,"], [19, "    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,"], [20, "    PRIMARY KEY (DomainID),"], [21, "    FOREIGN KEY (TopDomainID) REFERENCES domains(DomainID),"], [22, "    UNIQUE (Domain)"], [23, ");"], [24, "\"\"\")"], [25, ""], [26, "cursor.execute (\"\"\""], [27, "CREATE TABLE directories"], [28, "("], [29, "    DirectoryID int NOT NULL AUTO_INCREMENT,"], [30, "    DomainID int NOT NULL,"], [31, "    Directory varchar(255) not null,"], [32, "    File bit NOT NULL DEFAULT 0,"], [33, "    Active bit NOT NULL DEFAULT 0,"], [34, "    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,"], [35, "    PRIMARY KEY (DirectoryID),"], [36, "    FOREIGN KEY (DomainID) REFERENCES domains(DomainID)"], [37, ");"], [38, "\"\"\")"], [39, ""], [40, "cursor.execute (\"\"\""], [41, "CREATE TABLE crlf"], [42, "("], [43, "    CRLFID int NOT NULL AUTO_INCREMENT,"], [44, "    DomainID int NOT NULL,"], [45, "    Payload varchar(255) not null,"], [46, "    Active bit NOT NULL DEFAULT 0,"], [47, "    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,"], [48, "    PRIMARY KEY (CRLFID),"], [49, "    FOREIGN KEY (DomainID) REFERENCES domains(DomainID)"], [50, ");"], [51, ""], [52, "\"\"\")"], [53, ""], [54, "cursor.execute (\"\"\""], [55, "CREATE TABLE ports"], [56, "("], [57, "    PortID int NOT NULL AUTO_INCREMENT,"], [58, "    DomainID int NOT NULL,"], [59, "    Port int NOT NULL,"], [60, "    PortInfo varchar(255),"], [61, "    Active bit NOT NULL DEFAULT 0,"], [62, "    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,"], [63, "    PRIMARY KEY (PortID),"], [64, "    FOREIGN KEY (DomainID) REFERENCES domains(DomainID)"], [65, ");"], [66, ""], [67, "\"\"\")"], [68, ""], [69, "cursor.execute (\"\"\""], [70, "CREATE TABLE errors"], [71, "("], [72, "    ErrorID int NOT NULL AUTO_INCREMENT,"], [73, "    Domain varchar(255),"], [74, "    ErrorDescription varchar(255),"], [75, "    Error varchar(255),"], [76, "    Script varchar(255),"], [77, "    ErrorDate timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,"], [78, "    PRIMARY KEY (ErrorID)"], [79, ");"], [80, ""], [81, "\"\"\")"], [82, ""], [83, ""], [84, "cursor.close ()"], [85, "connection.close ()"], [86, "sys.exit()"]], "deleted": []}, "added_lines": 86, "deleted_lines": 0, "source_code": "#!/usr/bin/python\n\nimport MySQLdb\nimport sys\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\ncursor = connection.cursor ()\n\ncursor.execute (\"\"\"\nCREATE TABLE domains\n(\n    DomainID int NOT NULL AUTO_INCREMENT,\n    Program varchar(255) not null,\n    TopDomainID int default null,\n    Active bit NOT NULL DEFAULT 0,\n    InScope bit NOT NULL DEFAULT 0,\n    Domain varchar(100) not null,\n    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n    PRIMARY KEY (DomainID),\n    FOREIGN KEY (TopDomainID) REFERENCES domains(DomainID),\n    UNIQUE (Domain)\n);\n\"\"\")\n\ncursor.execute (\"\"\"\nCREATE TABLE directories\n(\n    DirectoryID int NOT NULL AUTO_INCREMENT,\n    DomainID int NOT NULL,\n    Directory varchar(255) not null,\n    File bit NOT NULL DEFAULT 0,\n    Active bit NOT NULL DEFAULT 0,\n    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n    PRIMARY KEY (DirectoryID),\n    FOREIGN KEY (DomainID) REFERENCES domains(DomainID)\n);\n\"\"\")\n\ncursor.execute (\"\"\"\nCREATE TABLE crlf\n(\n    CRLFID int NOT NULL AUTO_INCREMENT,\n    DomainID int NOT NULL,\n    Payload varchar(255) not null,\n    Active bit NOT NULL DEFAULT 0,\n    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n    PRIMARY KEY (CRLFID),\n    FOREIGN KEY (DomainID) REFERENCES domains(DomainID)\n);\n\n\"\"\")\n\ncursor.execute (\"\"\"\nCREATE TABLE ports\n(\n    PortID int NOT NULL AUTO_INCREMENT,\n    DomainID int NOT NULL,\n    Port int NOT NULL,\n    PortInfo varchar(255),\n    Active bit NOT NULL DEFAULT 0,\n    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n    PRIMARY KEY (PortID),\n    FOREIGN KEY (DomainID) REFERENCES domains(DomainID)\n);\n\n\"\"\")\n\ncursor.execute (\"\"\"\nCREATE TABLE errors\n(\n    ErrorID int NOT NULL AUTO_INCREMENT,\n    Domain varchar(255),\n    ErrorDescription varchar(255),\n    Error varchar(255),\n    Script varchar(255),\n    ErrorDate timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n    PRIMARY KEY (ErrorID)\n);\n\n\"\"\")\n\n\ncursor.close ()\nconnection.close ()\nsys.exit()\n", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": 75, "complexity": 0, "token_count": 78}, {"old_path": null, "new_path": "database/queries/crlf_create.sql", "filename": "crlf_create.sql", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1,10 @@\n+CREATE TABLE crlf\n+(\n+CRLFID int NOT NULL AUTO_INCREMENT,\n+DomainID int NOT NULL,\n+Payload varchar(255) not null,\n+Active bit NOT NULL DEFAULT 0,\n+PRIMARY KEY (CRLFID),\n+FOREIGN KEY (DomainID) REFERENCES domains(DomainID)\n+);\n+\n", "diff_parsed": {"added": [[1, "CREATE TABLE crlf"], [2, "("], [3, "CRLFID int NOT NULL AUTO_INCREMENT,"], [4, "DomainID int NOT NULL,"], [5, "Payload varchar(255) not null,"], [6, "Active bit NOT NULL DEFAULT 0,"], [7, "PRIMARY KEY (CRLFID),"], [8, "FOREIGN KEY (DomainID) REFERENCES domains(DomainID)"], [9, ");"], [10, ""]], "deleted": []}, "added_lines": 10, "deleted_lines": 0, "source_code": "CREATE TABLE crlf\n(\nCRLFID int NOT NULL AUTO_INCREMENT,\nDomainID int NOT NULL,\nPayload varchar(255) not null,\nActive bit NOT NULL DEFAULT 0,\nPRIMARY KEY (CRLFID),\nFOREIGN KEY (DomainID) REFERENCES domains(DomainID)\n);\n\n", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}, {"old_path": null, "new_path": "database/queries/directories_create.sql", "filename": "directories_create.sql", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1,10 @@\n+CREATE TABLE directories\n+(\n+DirectoryID int NOT NULL AUTO_INCREMENT,\n+DomainID int NOT NULL,\n+Directory varchar(255) not null,\n+File bit NOT NULL DEFAULT 0,\n+Active bit NOT NULL DEFAULT 0,\n+PRIMARY KEY (DirectoryID),\n+FOREIGN KEY (DomainID) REFERENCES domains(DomainID)\n+);\n", "diff_parsed": {"added": [[1, "CREATE TABLE directories"], [2, "("], [3, "DirectoryID int NOT NULL AUTO_INCREMENT,"], [4, "DomainID int NOT NULL,"], [5, "Directory varchar(255) not null,"], [6, "File bit NOT NULL DEFAULT 0,"], [7, "Active bit NOT NULL DEFAULT 0,"], [8, "PRIMARY KEY (DirectoryID),"], [9, "FOREIGN KEY (DomainID) REFERENCES domains(DomainID)"], [10, ");"]], "deleted": []}, "added_lines": 10, "deleted_lines": 0, "source_code": "CREATE TABLE directories\n(\nDirectoryID int NOT NULL AUTO_INCREMENT,\nDomainID int NOT NULL,\nDirectory varchar(255) not null,\nFile bit NOT NULL DEFAULT 0,\nActive bit NOT NULL DEFAULT 0,\nPRIMARY KEY (DirectoryID),\nFOREIGN KEY (DomainID) REFERENCES domains(DomainID)\n);\n", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}, {"old_path": null, "new_path": "database/queries/domains_create.sql", "filename": "domains_create.sql", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1,13 @@\n+CREATE TABLE domains\n+(\n+DomainID int NOT NULL AUTO_INCREMENT,\n+Program varchar(255) not null,\n+TopDomainID int default null,\n+Active bit NOT NULL DEFAULT 0,\n+InScope bit NOT NULL DEFAULT 0,\n+Domain varchar(100) not null,\n+PRIMARY KEY (DomainID),\n+FOREIGN KEY (TopDomainID) REFERENCES domains(DomainID),\n+UNIQUE (Domain)\n+);\n+\n", "diff_parsed": {"added": [[1, "CREATE TABLE domains"], [2, "("], [3, "DomainID int NOT NULL AUTO_INCREMENT,"], [4, "Program varchar(255) not null,"], [5, "TopDomainID int default null,"], [6, "Active bit NOT NULL DEFAULT 0,"], [7, "InScope bit NOT NULL DEFAULT 0,"], [8, "Domain varchar(100) not null,"], [9, "PRIMARY KEY (DomainID),"], [10, "FOREIGN KEY (TopDomainID) REFERENCES domains(DomainID),"], [11, "UNIQUE (Domain)"], [12, ");"], [13, ""]], "deleted": []}, "added_lines": 13, "deleted_lines": 0, "source_code": "CREATE TABLE domains\n(\nDomainID int NOT NULL AUTO_INCREMENT,\nProgram varchar(255) not null,\nTopDomainID int default null,\nActive bit NOT NULL DEFAULT 0,\nInScope bit NOT NULL DEFAULT 0,\nDomain varchar(100) not null,\nPRIMARY KEY (DomainID),\nFOREIGN KEY (TopDomainID) REFERENCES domains(DomainID),\nUNIQUE (Domain)\n);\n\n", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}, {"old_path": null, "new_path": "database/queries/errors_create.sql", "filename": "errors_create.sql", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1,10 @@\n+CREATE TABLE errors\n+(\n+    ErrorID int NOT NULL AUTO_INCREMENT,\n+    Domain varchar(255),\n+    ErrorDescription varchar(255),\n+    Error varchar(255),\n+    Script varchar(255),\n+    ErrorDate datetime DEFAULT CURRENT_TIMESTAMP NOT NULL,\n+    PRIMARY KEY (ErrorID)\n+);\n", "diff_parsed": {"added": [[1, "CREATE TABLE errors"], [2, "("], [3, "    ErrorID int NOT NULL AUTO_INCREMENT,"], [4, "    Domain varchar(255),"], [5, "    ErrorDescription varchar(255),"], [6, "    Error varchar(255),"], [7, "    Script varchar(255),"], [8, "    ErrorDate datetime DEFAULT CURRENT_TIMESTAMP NOT NULL,"], [9, "    PRIMARY KEY (ErrorID)"], [10, ");"]], "deleted": []}, "added_lines": 10, "deleted_lines": 0, "source_code": "CREATE TABLE errors\n(\n    ErrorID int NOT NULL AUTO_INCREMENT,\n    Domain varchar(255),\n    ErrorDescription varchar(255),\n    Error varchar(255),\n    Script varchar(255),\n    ErrorDate datetime DEFAULT CURRENT_TIMESTAMP NOT NULL,\n    PRIMARY KEY (ErrorID)\n);\n", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}, {"old_path": null, "new_path": "database/queries/ports_create.sql", "filename": "ports_create.sql", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1,11 @@\n+CREATE TABLE ports\n+(\n+PortID int NOT NULL AUTO_INCREMENT,\n+DomainID int NOT NULL,\n+Port int NOT NULL,\n+PortInfo varchar(255),\n+Active bit NOT NULL DEFAULT 0,\n+PRIMARY KEY (PortID),\n+FOREIGN KEY (DomainID) REFERENCES domains(DomainID)\n+);\n+\n", "diff_parsed": {"added": [[1, "CREATE TABLE ports"], [2, "("], [3, "PortID int NOT NULL AUTO_INCREMENT,"], [4, "DomainID int NOT NULL,"], [5, "Port int NOT NULL,"], [6, "PortInfo varchar(255),"], [7, "Active bit NOT NULL DEFAULT 0,"], [8, "PRIMARY KEY (PortID),"], [9, "FOREIGN KEY (DomainID) REFERENCES domains(DomainID)"], [10, ");"], [11, ""]], "deleted": []}, "added_lines": 11, "deleted_lines": 0, "source_code": "CREATE TABLE ports\n(\nPortID int NOT NULL AUTO_INCREMENT,\nDomainID int NOT NULL,\nPort int NOT NULL,\nPortInfo varchar(255),\nActive bit NOT NULL DEFAULT 0,\nPRIMARY KEY (PortID),\nFOREIGN KEY (DomainID) REFERENCES domains(DomainID)\n);\n\n", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}, {"old_path": null, "new_path": "database/queries/scans_screate.sql", "filename": "scans_screate.sql", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1,7 @@\n+CREATE TABLE scans ( \n+\tScanID int NOT NULL AUTO_INCREMENT, \n+\tStartDate datetime NOT NULL, \n+\tEndDate datetime, \n+\tprimary key (ScanID) \n+);\n+\n", "diff_parsed": {"added": [[1, "CREATE TABLE scans ("], [2, "\tScanID int NOT NULL AUTO_INCREMENT,"], [3, "\tStartDate datetime NOT NULL,"], [4, "\tEndDate datetime,"], [5, "\tprimary key (ScanID)"], [6, ");"], [7, ""]], "deleted": []}, "added_lines": 7, "deleted_lines": 0, "source_code": "CREATE TABLE scans ( \n\tScanID int NOT NULL AUTO_INCREMENT, \n\tStartDate datetime NOT NULL, \n\tEndDate datetime, \n\tprimary key (ScanID) \n);\n\n", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}, {"old_path": null, "new_path": "main.py", "filename": "main.py", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1,206 @@\n+#!/usr/bin/python\n+\n+import os, sys, MySQLdb, time\n+\n+class bcolors:\n+    HEADER = '\\033[95m'\n+    OKBLUE = '\\033[94m'\n+    OKGREEN = '\\033[92m'\n+    WARNING = '\\033[93m'\n+    FAIL = '\\033[91m'\n+    ENDC = '\\033[0m'\n+    BOLD = '\\033[1m'\n+    UNDERLINE = '\\033[4m'\n+\n+connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+cursor = connection.cursor()\n+\n+\n+def list_subdomains():\n+\tsub_domain = raw_input('[Domain] > ')\n+\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (sub_domain,))\n+\tdata = cursor.fetchall()\n+\n+\tfor row in data:\n+\t\tif ord(row[1]):\n+\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n+\t\telse:\n+\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n+\n+\traw_input(\"\\nPress any key to go back...\")\n+\tstart()\n+\n+\n+def run_subdomain_scan_on_target(top_domain_par = None):\n+\tif top_domain_par is None:\n+\t\tprint \"What is the domain?\"\n+\t\ttop_domain = raw_input('[Domain] > ')\n+\telse:\n+\t\ttop_domain = top_domain_par\n+\n+\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__)) + \"/database/additional_tools/sublister_to_db.py \" + top_domain + \" NULL\")\n+\n+def insert_topdomain(top_domain_par = None):\n+\tif top_domain_par is None:\n+\t\tprint \"What is the domain? \"\n+\t\ttop_domain = raw_input('[Domain] > ')\n+\telse:\n+\t\ttop_domain = top_domain_par\n+\n+\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n+\tdata = cursor.fetchone()  \n+\n+\tif data:\n+    \t\tprint bcolors.WARNING + \"Domains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n+\t\traw_input(\"Press any key to go back...\")\n+\t\tstart()\n+\t\n+\n+\tprint \"What is the program? \"\n+\tprogram = raw_input('[program] > ')\n+\n+\tprint \"Inscope? \"\n+\tinscope = raw_input('[Inscope] > ')\n+\tif \"no\" not in inscope.lower():\n+\t\tinscope = 1\n+\telse:\n+\t\tinscope = 0\n+\t\n+\n+\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active) VALUES (%s, %s, %s, %s)\", (program, inscope, top_domain, 1))\n+\tconnection.commit()\n+\t\n+\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n+\traw_input(\"\\nPress any key to go back...\")\n+\tstart()\n+\n+\n+def insert_subdomain(top_domain_par = None):\n+\tif top_domain_par is None:\n+\t\tprint \"What is the (top)domain? \"\n+\t\ttop_domain = raw_input('[(Top)Domain] > ')\n+\telse:\n+\t\ttop_domain = top_domain_par\n+\n+\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n+\tdata = cursor.fetchone()  \n+\n+\tif not data:\n+    \t\tprint bcolors.WARNING + \"Domain not found!\" + bcolors.ENDC\n+\t\tprint \"Do you want to add it? \"\n+\t\tanswer = raw_input('[yes/no] > ')\n+\t\tif \"no\" not in answer.lower():\n+\t\t\tinsert_topdomain(top_domain)\n+\t\telse:\n+\t\t\traw_input(\"Press any key to go back...\")\n+\t\t\tstart()\n+\n+\tprogram = str(data[1])\n+\ttopdomainid = int(data[0])\n+\n+\n+\n+\tprint \"What is the subdomain? \"\n+\tsub_domain = raw_input('[(Subdomain] > ')\n+\n+\tcursor.execute (\"select * from domains where Domain = %s\", (sub_domain,))\n+\tdata = cursor.fetchone()  \n+\n+\tif data:\n+    \t\tprint bcolors.WARNING + \"Subdomains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n+\t\tdoes_not_exist = False\n+\telse:\n+\t\tdoes_not_exist = True\n+\n+\tif does_not_exist:\n+\t\tprint \"Inscope? \"\n+\t\tinscope = raw_input('[Inscope] > ')\n+\t\tif \"no\" not in inscope.lower():\n+\t\t\tinscope = 1\n+\t\telse:\n+\t\t\tinscope = 0\n+\n+\t\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active, TopDomainID) VALUES (%s, %s, %s, %s, %s)\", (program, inscope, sub_domain, 1, topdomainid))\n+\t\tconnection.commit()\n+\t\t\n+\t\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n+\n+\tprint \"Do you want to add another one?? \"\n+\tanother_one = raw_input('[yes/no] > ')\n+\tif \"no\" not in another_one.lower():\n+\n+\t\tinsert_subdomain(top_domain)\n+\n+\traw_input(\"\\nPress any key to go back...\")\n+\tstart()\n+\n+\n+\n+def list_domains():\n+\tcursor.execute (\"select Domain, Active from domains where TopDomainID is NULL\")\n+\tdata = cursor.fetchall()\n+\n+\tfor row in data:\n+\t\tif ord(row[1]):\n+\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n+\t\telse:\n+\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n+\t\n+\traw_input(\"\\nPress any key to go back...\")\n+\tstart()\n+\n+\n+options = {1 : insert_topdomain,\n+           2 : list_subdomains,\n+           3 : list_domains,\n+           4 : insert_subdomain,\n+\t   5 : run_subdomain_scan_on_target\n+}\n+\n+\n+def start():\n+\tos.system('clear')\n+\tcursor.execute (\"select count(*) from domains where TopDomainID is NULL;\")\n+\tdata = cursor.fetchall()\n+\tsub_domains = data[0][0]\n+\n+\tcursor.execute (\"select count(TopDomainID) from domains\")\n+\tdata = cursor.fetchall()\n+\ttop_domains = data[0][0]\n+\n+\tdomains = top_domains + sub_domains\n+\n+\tbanner = \"\"\" {0}---------------+-------\n+ Domains       | {1}   \n+ Top-domains   | {2}  \n+ Sudomains     | {3}   \n+---------------+-------{4}\"\"\"\n+\n+\tchoices = \"\"\"\n+1. Add domain\n+2. List subdomains from domain\n+3. List all (top)domains\n+4. Add subdomain\n+5. Run subdomain scan on top domain\n+\"\"\"\n+\n+\tprint banner.format(bcolors.HEADER, domains, sub_domains, top_domains, bcolors.ENDC)\n+\n+\tprint choices.format()\n+\n+\ttry:\n+\t\tnum = raw_input('> ')\n+\t\tnum = int(num)\n+\texcept:\n+\t\tprint \"Provide a number please,\"\n+\t\traw_input(\"\\nPress any key to go back...\")\n+\t\tstart()\n+\t\tstart()\n+\n+\toptions[num]()\n+\n+\n+start()\n+cursor.close ()\n+connection.close ()\n+sys.exit()\n", "diff_parsed": {"added": [[1, "#!/usr/bin/python"], [2, ""], [3, "import os, sys, MySQLdb, time"], [4, ""], [5, "class bcolors:"], [6, "    HEADER = '\\033[95m'"], [7, "    OKBLUE = '\\033[94m'"], [8, "    OKGREEN = '\\033[92m'"], [9, "    WARNING = '\\033[93m'"], [10, "    FAIL = '\\033[91m'"], [11, "    ENDC = '\\033[0m'"], [12, "    BOLD = '\\033[1m'"], [13, "    UNDERLINE = '\\033[4m'"], [14, ""], [15, "connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [16, "cursor = connection.cursor()"], [17, ""], [18, ""], [19, "def list_subdomains():"], [20, "\tsub_domain = raw_input('[Domain] > ')"], [21, "\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (sub_domain,))"], [22, "\tdata = cursor.fetchall()"], [23, ""], [24, "\tfor row in data:"], [25, "\t\tif ord(row[1]):"], [26, "\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC"], [27, "\t\telse:"], [28, "\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC"], [29, ""], [30, "\traw_input(\"\\nPress any key to go back...\")"], [31, "\tstart()"], [32, ""], [33, ""], [34, "def run_subdomain_scan_on_target(top_domain_par = None):"], [35, "\tif top_domain_par is None:"], [36, "\t\tprint \"What is the domain?\""], [37, "\t\ttop_domain = raw_input('[Domain] > ')"], [38, "\telse:"], [39, "\t\ttop_domain = top_domain_par"], [40, ""], [41, "\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__)) + \"/database/additional_tools/sublister_to_db.py \" + top_domain + \" NULL\")"], [42, ""], [43, "def insert_topdomain(top_domain_par = None):"], [44, "\tif top_domain_par is None:"], [45, "\t\tprint \"What is the domain? \""], [46, "\t\ttop_domain = raw_input('[Domain] > ')"], [47, "\telse:"], [48, "\t\ttop_domain = top_domain_par"], [49, ""], [50, "\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))"], [51, "\tdata = cursor.fetchone()"], [52, ""], [53, "\tif data:"], [54, "    \t\tprint bcolors.WARNING + \"Domains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC"], [55, "\t\traw_input(\"Press any key to go back...\")"], [56, "\t\tstart()"], [57, ""], [58, ""], [59, "\tprint \"What is the program? \""], [60, "\tprogram = raw_input('[program] > ')"], [61, ""], [62, "\tprint \"Inscope? \""], [63, "\tinscope = raw_input('[Inscope] > ')"], [64, "\tif \"no\" not in inscope.lower():"], [65, "\t\tinscope = 1"], [66, "\telse:"], [67, "\t\tinscope = 0"], [68, ""], [69, ""], [70, "\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active) VALUES (%s, %s, %s, %s)\", (program, inscope, top_domain, 1))"], [71, "\tconnection.commit()"], [72, ""], [73, "\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC"], [74, "\traw_input(\"\\nPress any key to go back...\")"], [75, "\tstart()"], [76, ""], [77, ""], [78, "def insert_subdomain(top_domain_par = None):"], [79, "\tif top_domain_par is None:"], [80, "\t\tprint \"What is the (top)domain? \""], [81, "\t\ttop_domain = raw_input('[(Top)Domain] > ')"], [82, "\telse:"], [83, "\t\ttop_domain = top_domain_par"], [84, ""], [85, "\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))"], [86, "\tdata = cursor.fetchone()"], [87, ""], [88, "\tif not data:"], [89, "    \t\tprint bcolors.WARNING + \"Domain not found!\" + bcolors.ENDC"], [90, "\t\tprint \"Do you want to add it? \""], [91, "\t\tanswer = raw_input('[yes/no] > ')"], [92, "\t\tif \"no\" not in answer.lower():"], [93, "\t\t\tinsert_topdomain(top_domain)"], [94, "\t\telse:"], [95, "\t\t\traw_input(\"Press any key to go back...\")"], [96, "\t\t\tstart()"], [97, ""], [98, "\tprogram = str(data[1])"], [99, "\ttopdomainid = int(data[0])"], [100, ""], [101, ""], [102, ""], [103, "\tprint \"What is the subdomain? \""], [104, "\tsub_domain = raw_input('[(Subdomain] > ')"], [105, ""], [106, "\tcursor.execute (\"select * from domains where Domain = %s\", (sub_domain,))"], [107, "\tdata = cursor.fetchone()"], [108, ""], [109, "\tif data:"], [110, "    \t\tprint bcolors.WARNING + \"Subdomains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC"], [111, "\t\tdoes_not_exist = False"], [112, "\telse:"], [113, "\t\tdoes_not_exist = True"], [114, ""], [115, "\tif does_not_exist:"], [116, "\t\tprint \"Inscope? \""], [117, "\t\tinscope = raw_input('[Inscope] > ')"], [118, "\t\tif \"no\" not in inscope.lower():"], [119, "\t\t\tinscope = 1"], [120, "\t\telse:"], [121, "\t\t\tinscope = 0"], [122, ""], [123, "\t\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active, TopDomainID) VALUES (%s, %s, %s, %s, %s)\", (program, inscope, sub_domain, 1, topdomainid))"], [124, "\t\tconnection.commit()"], [125, ""], [126, "\t\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC"], [127, ""], [128, "\tprint \"Do you want to add another one?? \""], [129, "\tanother_one = raw_input('[yes/no] > ')"], [130, "\tif \"no\" not in another_one.lower():"], [131, ""], [132, "\t\tinsert_subdomain(top_domain)"], [133, ""], [134, "\traw_input(\"\\nPress any key to go back...\")"], [135, "\tstart()"], [136, ""], [137, ""], [138, ""], [139, "def list_domains():"], [140, "\tcursor.execute (\"select Domain, Active from domains where TopDomainID is NULL\")"], [141, "\tdata = cursor.fetchall()"], [142, ""], [143, "\tfor row in data:"], [144, "\t\tif ord(row[1]):"], [145, "\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC"], [146, "\t\telse:"], [147, "\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC"], [148, ""], [149, "\traw_input(\"\\nPress any key to go back...\")"], [150, "\tstart()"], [151, ""], [152, ""], [153, "options = {1 : insert_topdomain,"], [154, "           2 : list_subdomains,"], [155, "           3 : list_domains,"], [156, "           4 : insert_subdomain,"], [157, "\t   5 : run_subdomain_scan_on_target"], [158, "}"], [159, ""], [160, ""], [161, "def start():"], [162, "\tos.system('clear')"], [163, "\tcursor.execute (\"select count(*) from domains where TopDomainID is NULL;\")"], [164, "\tdata = cursor.fetchall()"], [165, "\tsub_domains = data[0][0]"], [166, ""], [167, "\tcursor.execute (\"select count(TopDomainID) from domains\")"], [168, "\tdata = cursor.fetchall()"], [169, "\ttop_domains = data[0][0]"], [170, ""], [171, "\tdomains = top_domains + sub_domains"], [172, ""], [173, "\tbanner = \"\"\" {0}---------------+-------"], [174, " Domains       | {1}"], [175, " Top-domains   | {2}"], [176, " Sudomains     | {3}"], [177, "---------------+-------{4}\"\"\""], [178, ""], [179, "\tchoices = \"\"\""], [180, "1. Add domain"], [181, "2. List subdomains from domain"], [182, "3. List all (top)domains"], [183, "4. Add subdomain"], [184, "5. Run subdomain scan on top domain"], [185, "\"\"\""], [186, ""], [187, "\tprint banner.format(bcolors.HEADER, domains, sub_domains, top_domains, bcolors.ENDC)"], [188, ""], [189, "\tprint choices.format()"], [190, ""], [191, "\ttry:"], [192, "\t\tnum = raw_input('> ')"], [193, "\t\tnum = int(num)"], [194, "\texcept:"], [195, "\t\tprint \"Provide a number please,\""], [196, "\t\traw_input(\"\\nPress any key to go back...\")"], [197, "\t\tstart()"], [198, "\t\tstart()"], [199, ""], [200, "\toptions[num]()"], [201, ""], [202, ""], [203, "start()"], [204, "cursor.close ()"], [205, "connection.close ()"], [206, "sys.exit()"]], "deleted": []}, "added_lines": 206, "deleted_lines": 0, "source_code": "#!/usr/bin/python\n\nimport os, sys, MySQLdb, time\n\nclass bcolors:\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\ncursor = connection.cursor()\n\n\ndef list_subdomains():\n\tsub_domain = raw_input('[Domain] > ')\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (sub_domain,))\n\tdata = cursor.fetchall()\n\n\tfor row in data:\n\t\tif ord(row[1]):\n\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n\t\telse:\n\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\ndef run_subdomain_scan_on_target(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the domain?\"\n\t\ttop_domain = raw_input('[Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__)) + \"/database/additional_tools/sublister_to_db.py \" + top_domain + \" NULL\")\n\ndef insert_topdomain(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the domain? \"\n\t\ttop_domain = raw_input('[Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n\tdata = cursor.fetchone()  \n\n\tif data:\n    \t\tprint bcolors.WARNING + \"Domains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n\t\traw_input(\"Press any key to go back...\")\n\t\tstart()\n\t\n\n\tprint \"What is the program? \"\n\tprogram = raw_input('[program] > ')\n\n\tprint \"Inscope? \"\n\tinscope = raw_input('[Inscope] > ')\n\tif \"no\" not in inscope.lower():\n\t\tinscope = 1\n\telse:\n\t\tinscope = 0\n\t\n\n\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active) VALUES (%s, %s, %s, %s)\", (program, inscope, top_domain, 1))\n\tconnection.commit()\n\t\n\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\ndef insert_subdomain(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the (top)domain? \"\n\t\ttop_domain = raw_input('[(Top)Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n\tdata = cursor.fetchone()  \n\n\tif not data:\n    \t\tprint bcolors.WARNING + \"Domain not found!\" + bcolors.ENDC\n\t\tprint \"Do you want to add it? \"\n\t\tanswer = raw_input('[yes/no] > ')\n\t\tif \"no\" not in answer.lower():\n\t\t\tinsert_topdomain(top_domain)\n\t\telse:\n\t\t\traw_input(\"Press any key to go back...\")\n\t\t\tstart()\n\n\tprogram = str(data[1])\n\ttopdomainid = int(data[0])\n\n\n\n\tprint \"What is the subdomain? \"\n\tsub_domain = raw_input('[(Subdomain] > ')\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (sub_domain,))\n\tdata = cursor.fetchone()  \n\n\tif data:\n    \t\tprint bcolors.WARNING + \"Subdomains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n\t\tdoes_not_exist = False\n\telse:\n\t\tdoes_not_exist = True\n\n\tif does_not_exist:\n\t\tprint \"Inscope? \"\n\t\tinscope = raw_input('[Inscope] > ')\n\t\tif \"no\" not in inscope.lower():\n\t\t\tinscope = 1\n\t\telse:\n\t\t\tinscope = 0\n\n\t\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active, TopDomainID) VALUES (%s, %s, %s, %s, %s)\", (program, inscope, sub_domain, 1, topdomainid))\n\t\tconnection.commit()\n\t\t\n\t\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n\n\tprint \"Do you want to add another one?? \"\n\tanother_one = raw_input('[yes/no] > ')\n\tif \"no\" not in another_one.lower():\n\n\t\tinsert_subdomain(top_domain)\n\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\n\ndef list_domains():\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID is NULL\")\n\tdata = cursor.fetchall()\n\n\tfor row in data:\n\t\tif ord(row[1]):\n\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n\t\telse:\n\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n\t\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\noptions = {1 : insert_topdomain,\n           2 : list_subdomains,\n           3 : list_domains,\n           4 : insert_subdomain,\n\t   5 : run_subdomain_scan_on_target\n}\n\n\ndef start():\n\tos.system('clear')\n\tcursor.execute (\"select count(*) from domains where TopDomainID is NULL;\")\n\tdata = cursor.fetchall()\n\tsub_domains = data[0][0]\n\n\tcursor.execute (\"select count(TopDomainID) from domains\")\n\tdata = cursor.fetchall()\n\ttop_domains = data[0][0]\n\n\tdomains = top_domains + sub_domains\n\n\tbanner = \"\"\" {0}---------------+-------\n Domains       | {1}   \n Top-domains   | {2}  \n Sudomains     | {3}   \n---------------+-------{4}\"\"\"\n\n\tchoices = \"\"\"\n1. Add domain\n2. List subdomains from domain\n3. List all (top)domains\n4. Add subdomain\n5. Run subdomain scan on top domain\n\"\"\"\n\n\tprint banner.format(bcolors.HEADER, domains, sub_domains, top_domains, bcolors.ENDC)\n\n\tprint choices.format()\n\n\ttry:\n\t\tnum = raw_input('> ')\n\t\tnum = int(num)\n\texcept:\n\t\tprint \"Provide a number please,\"\n\t\traw_input(\"\\nPress any key to go back...\")\n\t\tstart()\n\t\tstart()\n\n\toptions[num]()\n\n\nstart()\ncursor.close ()\nconnection.close ()\nsys.exit()\n", "source_code_before": null, "methods": [{"name": "list_subdomains", "start_line": 19, "end_line": 31}, {"name": "run_subdomain_scan_on_target", "start_line": 34, "end_line": 41}, {"name": "insert_topdomain", "start_line": 43, "end_line": 75}, {"name": "insert_subdomain", "start_line": 78, "end_line": 135}, {"name": "list_domains", "start_line": 139, "end_line": 150}, {"name": "start", "start_line": 161, "end_line": 200}], "methods_before": [], "changed_methods": [{"name": "insert_subdomain", "start_line": 78, "end_line": 135}, {"name": "insert_topdomain", "start_line": 43, "end_line": 75}, {"name": "run_subdomain_scan_on_target", "start_line": 34, "end_line": 41}, {"name": "list_domains", "start_line": 139, "end_line": 150}, {"name": "list_subdomains", "start_line": 19, "end_line": 31}, {"name": "start", "start_line": 161, "end_line": 200}], "nloc": 151, "complexity": 22, "token_count": 846}, {"old_path": null, "new_path": "run.py", "filename": "run.py", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1,25 @@\n+#!/usr/bin/python\n+import sys, os, MySQLdb, datetime\n+\n+connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+cursor = connection.cursor ()\n+\n+cursor.execute (\"insert into scans (StartDate) values (CURRENT_TIMESTAMP)\")\n+connection.commit()\n+scanId = cursor.lastrowid\n+\n+cursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\n+data = cursor.fetchall ()\n+connection.close()\n+\n+for row in data:\n+\tprint \"Running sublister on \" + row[0]\n+\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/database/additional_tools/sublister_to_db.py \" + row[0] + \" \" + str(scanId))\n+\n+connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+cursor = connection.cursor ()\n+cursor.execute (\"update scans set EndDate = CURRENT_TIMESTAMP where ScanID = %s\", (scanId))\n+connection.commit()\n+connection.close()\n+\n+os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/telegram/notify.py \" + str(scanId))\n", "diff_parsed": {"added": [[1, "#!/usr/bin/python"], [2, "import sys, os, MySQLdb, datetime"], [3, ""], [4, "connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [5, "cursor = connection.cursor ()"], [6, ""], [7, "cursor.execute (\"insert into scans (StartDate) values (CURRENT_TIMESTAMP)\")"], [8, "connection.commit()"], [9, "scanId = cursor.lastrowid"], [10, ""], [11, "cursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")"], [12, "data = cursor.fetchall ()"], [13, "connection.close()"], [14, ""], [15, "for row in data:"], [16, "\tprint \"Running sublister on \" + row[0]"], [17, "\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/database/additional_tools/sublister_to_db.py \" + row[0] + \" \" + str(scanId))"], [18, ""], [19, "connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [20, "cursor = connection.cursor ()"], [21, "cursor.execute (\"update scans set EndDate = CURRENT_TIMESTAMP where ScanID = %s\", (scanId))"], [22, "connection.commit()"], [23, "connection.close()"], [24, ""], [25, "os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/telegram/notify.py \" + str(scanId))"]], "deleted": []}, "added_lines": 25, "deleted_lines": 0, "source_code": "#!/usr/bin/python\nimport sys, os, MySQLdb, datetime\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\ncursor = connection.cursor ()\n\ncursor.execute (\"insert into scans (StartDate) values (CURRENT_TIMESTAMP)\")\nconnection.commit()\nscanId = cursor.lastrowid\n\ncursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\ndata = cursor.fetchall ()\nconnection.close()\n\nfor row in data:\n\tprint \"Running sublister on \" + row[0]\n\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/database/additional_tools/sublister_to_db.py \" + row[0] + \" \" + str(scanId))\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\ncursor = connection.cursor ()\ncursor.execute (\"update scans set EndDate = CURRENT_TIMESTAMP where ScanID = %s\", (scanId))\nconnection.commit()\nconnection.close()\n\nos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/telegram/notify.py \" + str(scanId))\n", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": 18, "complexity": 0, "token_count": 197}, {"old_path": null, "new_path": "telegram/bot.py", "filename": "bot.py", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1,310 @@\n+#!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n+\n+import logging, datetime, MySQLdb, os, telegram\n+from telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\n+from telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\n+from random import randint\n+\n+# Enable logging\n+logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n+\t\t\t\t\tlevel=logging.INFO)\n+\n+logger = logging.getLogger(__name__)\n+\n+BUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n+\n+def start(bot, update):\n+\tuser = update.message.from_user\n+\thour = datetime.datetime.now().hour\n+\tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])\n+\n+\tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n+\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n+\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]\n+\n+\treply_markup = InlineKeyboardMarkup(keyboard)\n+\tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n+\tprint \"button before\"\n+\treturn BUTTON\n+\n+\n+def button(bot, update):\n+\tquery = update.callback_query\n+\t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button\n+\n+\tprint \"button func called with: \" + query.data\n+\tchoice = query.data.split('-')[0]\n+\tr = str(randint(0, 99))\n+\n+\theader_1 = \"Catagory:\"\n+\tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n+\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n+\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + r)]]\n+\n+\theader_2 = \"Action:\"\n+\tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n+\t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n+\t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n+\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n+\n+\theader_3 = \"Action:\"\n+\tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n+\t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n+\t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n+\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n+\n+        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n+        keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n+                         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n+                        [InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n+\n+        header_5 = \"Action:\"\n+        keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n+                         InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n+\t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n+                        [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]\n+\n+        header_6 = \"Which type of domains?\"\n+        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active_domains-' + r),\n+                         InlineKeyboardButton(\"All\", callback_data='all_domains-' + r)],\n+                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n+\n+        header_7 = \"Which type of subdomains?\"\n+        keyboard_7 = [[InlineKeyboardButton(\"Active\", callback_data='active_subdomains-' + r),\n+                         InlineKeyboardButton(\"All\", callback_data='all_subdomains-' + r)],\n+                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n+\n+\t#ToDO: Transform into a swtich\n+\tif choice == \"back\":\n+\t\tbot.edit_message_text(header_1, reply_markup=InlineKeyboardMarkup(keyboard_1), chat_id=query.message.chat_id, message_id=query.message.message_id)\n+\t\treturn BUTTON\n+\telif choice == \"close\":\n+\t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)\n+\telif choice == \"scan\":\n+\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n+\t\treturn BUTTON\n+\telif choice == \"data\":\n+\t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n+\t\treturn BUTTON\n+\n+\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+\tcursor = connection.cursor ()\n+\n+\tif choice == \"latest\":\n+\t\tget_latest_scan(bot, update, cursor)\n+\t\tcursor.close()\n+\t\tconnection.close()\n+\telif choice == \"custom\":\n+\t\tget_custom_scan(bot, update, cursor)\n+\t\tcursor.close()\n+\t\tconnection.close()\n+\t\treturn CUSTOM_SCAN_ID_INPUT\n+\telif choice == \"run\":\n+\t\trun_scan(bot, update, cursor)\n+\t\tcursor.close()\n+\t\tconnection.close()\n+\n+        if choice == \"add\":\n+                cursor.close()\n+                connection.close()\n+\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n+\t\treturn ADD_DOMAIN\n+        elif choice == \"edit\":\n+                cursor.close()\n+                connection.close()\n+\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n+                return EDIT_DOMAIN\n+        elif choice == \"get\":\n+                cursor.close()\n+                connection.close()\n+                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n+                return BUTTON\n+\n+        if choice == \"topdomais\":\n+                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n+                return BUTTON\n+        elif choice == \"subdomains\":\n+                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n+                return BUTTON\n+        elif choice == \"contains\":\n+\t\tbot.send_message(text=\"What is the search string?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n+                return CONTAINS\n+        elif choice == \"back_data\":\n+                bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n+                return BUTTON\n+        elif choice == \"back_get\":\n+                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n+                return BUTTON\n+\n+\n+\tif choice == \"yes_scan\":\n+\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n+\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n+\telif choice == \"back_scan\" or choice == \"no_scan\":\n+\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n+\t\treturn BUTTON\n+\n+\n+def get_latest_scan(bot, update, cursor):\n+\tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")\n+\tdata = cursor.fetchall()\n+\tif data:\n+\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))\n+\telse:\n+\t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n+\n+\n+def get_custom_scan(bot, update, cursor):\n+\tquery = update.callback_query\n+\n+\tcursor.execute (\"SELECT ScanID FROM scans where EndDate is not null ORDER BY ScanID DESC LIMIT 10\")\n+\tdata = cursor.fetchall()\n+\tif data:\n+\t\tlatestScanIds = sorted([str(x[0]) for x in data])\n+\t\tfirstRow = latestScanIds[:len(latestScanIds)/2]\n+\t\tsecondRow = latestScanIds[len(latestScanIds)/2:]\n+\t\tcustom_keyboard = [firstRow, secondRow]\n+\t\treply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\n+\n+\t\tif data:\n+\t\t\tbot.send_message(chat_id=query.message.chat_id,\n+\t\t\t\ttext=\"Which scan ID? \\n/cancel to cancel\",\n+\t\t\t\treply_markup=reply_markup, ForceReply = True)\n+\t\telse:\n+\t\t\tbot.send_message(chat_id=query.message.chat_id,\n+\t\t\t\t text=\"Which scan ID? \\n/cancel to cancel\")\n+\n+\n+def run_scan(bot, update, cursor):\n+\tquery = update.callback_query\n+\tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")\n+\tdata = cursor.fetchall()\n+\tif data[0][2] != None:\n+\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n+\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n+\telse:\n+\t\tr = str(randint(0, 99))\n+\t        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n+        \tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n+                \t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n+                        \t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n+\n+\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n+                return BUTTON\n+\n+\n+def custom_scan_id_input(bot, update):\n+\tprint \"inside input method with data: \" + update.message.text\n+\tcustomId = update.message.text\n+\ttry:\n+\t\tint(customId)\n+\texcept ValueError:\n+\t\tprint \"invalid number\"\n+\t\tupdate.message.reply_text(\"Not a valid number\")\n+\telse:\n+\t\tprint \"valid number\"\n+        \tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+        \tcursor = connection.cursor ()\n+\t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))\n+\t        data = cursor.fetchall()\n+\t\tcursor.close()\n+\t\tconnection.close()\n+\t\tif data:\n+\t\t\tprint \"scan ID was found in the db\"\n+\t\t\tprint \"data[0][0] is: \" + str(data[0][0])\n+\t\t\tif data[0][0] == None:\n+\t\t\t\tprint \"EndDate of scan is empty\"\n+\t\t\t\tupdate.message.reply_text(\"This scan hasn't finished yet\")\n+\t\t\telse:\n+\t\t\t\tprint \"Valid scan found\"\n+\t\t\t\treply_markup = telegram.ReplyKeyboardRemove()\n+\t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)\n+\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))\n+\t\t\t\treturn ConversationHandler.END\n+\t\telse:\n+\t\t\tprint \"Scan ID not found in db\"\n+\t\t\tupdate.message.reply_text(\"This scan ID doesn't exist\")\n+\n+\n+def add_domain(bot, update):\n+\tprint update.message.text\n+\treturn BUTTON\n+\n+\n+def edit_domain(bot, update):\n+\tprint update.message.text\n+\treturn BUTTON\n+\n+\n+def get_domains(bot, update):\n+\tprint update.message.text\n+\treturn BUTTON\n+\n+\n+def domains_contain(bot, update):\n+\tprint update.message.text\n+\treturn BUTTON\n+\n+\n+def help(bot, update):\n+\tupdate.message.reply_text(\"click /start to start :)\")\n+\n+\n+def error(bot, update, error):\n+\tlogger.warning('Update \"%s\" caused error \"%s\"', update, error)\n+\t\t\n+\n+def cancel(bot, update):\n+\tprint \"canceled\"\n+\treply_markup = telegram.ReplyKeyboardRemove()\n+\tupdate.message.reply_text(\"canceled! Click or type /start to start again\", reply_markup=reply_markup)\n+\treturn ConversationHandler.END\n+\n+\n+def main():\n+\t# Create the EventHandler and pass it your bot's token.\n+\tupdater = Updater(\"576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI\")\n+\n+\t# Get the dispatcher to register handlers\n+\tdp = updater.dispatcher\n+\n+\t# Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO\n+\tconv_handler = ConversationHandler(\n+\t\tentry_points=[CommandHandler('start', start)],\n+\n+\t\tstates={\n+\t\t\tBUTTON: [CallbackQueryHandler(button),\n+\t\t\t\t\t   CommandHandler('cancel', cancel)],\n+\t\t\tCUSTOM_SCAN_ID_INPUT: [MessageHandler(Filters.text, custom_scan_id_input),\n+\t\t\t\t\t   CommandHandler('cancel', cancel)],\n+                        ADD_DOMAIN: [MessageHandler(Filters.text, add_domain),\n+                                           CommandHandler('cancel', cancel)],\n+                        EDIT_DOMAIN: [MessageHandler(Filters.text, edit_domain),\n+                                           CommandHandler('cancel', cancel)],\n+                        GET_DOMAINS: [MessageHandler(Filters.text, get_domains),\n+                                           CommandHandler('cancel', cancel)],\n+                        CONTAINS: [MessageHandler(Filters.text, domains_contain),\n+                                           CommandHandler('cancel', cancel)]\n+\n+\t\t},\n+\n+\t\tfallbacks=[CommandHandler('cancel', cancel)]\n+\t)\n+\n+\tdp.add_handler(conv_handler)\n+\n+\t# log all errors\n+\tdp.add_error_handler(error)\n+\n+\t# Start the Bot\n+\tupdater.start_polling()\n+\n+\t# Run the bot until you press Ctrl-C or the process receives SIGINT,\n+\t# SIGTERM or SIGABRT. This should be used most of the time, since\n+\t# start_polling() is non-blocking and will stop the bot gracefully.\n+\tupdater.idle()\n+\n+\n+if __name__ == '__main__':\n+\tmain()\n", "diff_parsed": {"added": [[1, "#!/usr/bin/env python"], [2, "# -*- coding: utf-8 -*-"], [3, ""], [4, "import logging, datetime, MySQLdb, os, telegram"], [5, "from telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)"], [6, "from telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters"], [7, "from random import randint"], [8, ""], [9, "# Enable logging"], [10, "logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',"], [11, "\t\t\t\t\tlevel=logging.INFO)"], [12, ""], [13, "logger = logging.getLogger(__name__)"], [14, ""], [15, "BUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)"], [16, ""], [17, "def start(bot, update):"], [18, "\tuser = update.message.from_user"], [19, "\thour = datetime.datetime.now().hour"], [20, "\tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])"], [21, ""], [22, "\tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),"], [23, "\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],"], [24, "\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]"], [25, ""], [26, "\treply_markup = InlineKeyboardMarkup(keyboard)"], [27, "\tupdate.message.reply_text(greeting, reply_markup=reply_markup)"], [28, "\tprint \"button before\""], [29, "\treturn BUTTON"], [30, ""], [31, ""], [32, "def button(bot, update):"], [33, "\tquery = update.callback_query"], [34, "\t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button"], [35, ""], [36, "\tprint \"button func called with: \" + query.data"], [37, "\tchoice = query.data.split('-')[0]"], [38, "\tr = str(randint(0, 99))"], [39, ""], [40, "\theader_1 = \"Catagory:\""], [41, "\tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),"], [42, "\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],"], [43, "\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + r)]]"], [44, ""], [45, "\theader_2 = \"Action:\""], [46, "\tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),"], [47, "\t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),"], [48, "\t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],"], [49, "\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]"], [50, ""], [51, "\theader_3 = \"Action:\""], [52, "\tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),"], [53, "\t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),"], [54, "\t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],"], [55, "\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]"], [56, ""], [57, "        header_4 = \"It looks like a scan is already running. Want to start a new one?\""], [58, "        keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),"], [59, "                         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],"], [60, "                        [InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]"], [61, ""], [62, "        header_5 = \"Action:\""], [63, "        keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),"], [64, "                         InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),"], [65, "\t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],"], [66, "                        [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]"], [67, ""], [68, "        header_6 = \"Which type of domains?\""], [69, "        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active_domains-' + r),"], [70, "                         InlineKeyboardButton(\"All\", callback_data='all_domains-' + r)],"], [71, "                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]"], [72, ""], [73, "        header_7 = \"Which type of subdomains?\""], [74, "        keyboard_7 = [[InlineKeyboardButton(\"Active\", callback_data='active_subdomains-' + r),"], [75, "                         InlineKeyboardButton(\"All\", callback_data='all_subdomains-' + r)],"], [76, "                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]"], [77, ""], [78, "\t#ToDO: Transform into a swtich"], [79, "\tif choice == \"back\":"], [80, "\t\tbot.edit_message_text(header_1, reply_markup=InlineKeyboardMarkup(keyboard_1), chat_id=query.message.chat_id, message_id=query.message.message_id)"], [81, "\t\treturn BUTTON"], [82, "\telif choice == \"close\":"], [83, "\t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)"], [84, "\telif choice == \"scan\":"], [85, "\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)"], [86, "\t\treturn BUTTON"], [87, "\telif choice == \"data\":"], [88, "\t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)"], [89, "\t\treturn BUTTON"], [90, ""], [91, "\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [92, "\tcursor = connection.cursor ()"], [93, ""], [94, "\tif choice == \"latest\":"], [95, "\t\tget_latest_scan(bot, update, cursor)"], [96, "\t\tcursor.close()"], [97, "\t\tconnection.close()"], [98, "\telif choice == \"custom\":"], [99, "\t\tget_custom_scan(bot, update, cursor)"], [100, "\t\tcursor.close()"], [101, "\t\tconnection.close()"], [102, "\t\treturn CUSTOM_SCAN_ID_INPUT"], [103, "\telif choice == \"run\":"], [104, "\t\trun_scan(bot, update, cursor)"], [105, "\t\tcursor.close()"], [106, "\t\tconnection.close()"], [107, ""], [108, "        if choice == \"add\":"], [109, "                cursor.close()"], [110, "                connection.close()"], [111, "\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)"], [112, "\t\treturn ADD_DOMAIN"], [113, "        elif choice == \"edit\":"], [114, "                cursor.close()"], [115, "                connection.close()"], [116, "\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)"], [117, "                return EDIT_DOMAIN"], [118, "        elif choice == \"get\":"], [119, "                cursor.close()"], [120, "                connection.close()"], [121, "                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)"], [122, "                return BUTTON"], [123, ""], [124, "        if choice == \"topdomais\":"], [125, "                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)"], [126, "                return BUTTON"], [127, "        elif choice == \"subdomains\":"], [128, "                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)"], [129, "                return BUTTON"], [130, "        elif choice == \"contains\":"], [131, "\t\tbot.send_message(text=\"What is the search string?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)"], [132, "                return CONTAINS"], [133, "        elif choice == \"back_data\":"], [134, "                bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)"], [135, "                return BUTTON"], [136, "        elif choice == \"back_get\":"], [137, "                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)"], [138, "                return BUTTON"], [139, ""], [140, ""], [141, "\tif choice == \"yes_scan\":"], [142, "\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)"], [143, "\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")"], [144, "\telif choice == \"back_scan\" or choice == \"no_scan\":"], [145, "\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)"], [146, "\t\treturn BUTTON"], [147, ""], [148, ""], [149, "def get_latest_scan(bot, update, cursor):"], [150, "\tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")"], [151, "\tdata = cursor.fetchall()"], [152, "\tif data:"], [153, "\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))"], [154, "\telse:"], [155, "\t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)"], [156, ""], [157, ""], [158, "def get_custom_scan(bot, update, cursor):"], [159, "\tquery = update.callback_query"], [160, ""], [161, "\tcursor.execute (\"SELECT ScanID FROM scans where EndDate is not null ORDER BY ScanID DESC LIMIT 10\")"], [162, "\tdata = cursor.fetchall()"], [163, "\tif data:"], [164, "\t\tlatestScanIds = sorted([str(x[0]) for x in data])"], [165, "\t\tfirstRow = latestScanIds[:len(latestScanIds)/2]"], [166, "\t\tsecondRow = latestScanIds[len(latestScanIds)/2:]"], [167, "\t\tcustom_keyboard = [firstRow, secondRow]"], [168, "\t\treply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)"], [169, ""], [170, "\t\tif data:"], [171, "\t\t\tbot.send_message(chat_id=query.message.chat_id,"], [172, "\t\t\t\ttext=\"Which scan ID? \\n/cancel to cancel\","], [173, "\t\t\t\treply_markup=reply_markup, ForceReply = True)"], [174, "\t\telse:"], [175, "\t\t\tbot.send_message(chat_id=query.message.chat_id,"], [176, "\t\t\t\t text=\"Which scan ID? \\n/cancel to cancel\")"], [177, ""], [178, ""], [179, "def run_scan(bot, update, cursor):"], [180, "\tquery = update.callback_query"], [181, "\tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")"], [182, "\tdata = cursor.fetchall()"], [183, "\tif data[0][2] != None:"], [184, "\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)"], [185, "\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")"], [186, "\telse:"], [187, "\t\tr = str(randint(0, 99))"], [188, "\t        header_4 = \"It looks like a scan is already running. Want to start a new one?\""], [189, "        \tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),"], [190, "                \t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],"], [191, "                        \t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]"], [192, ""], [193, "\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)"], [194, "                return BUTTON"], [195, ""], [196, ""], [197, "def custom_scan_id_input(bot, update):"], [198, "\tprint \"inside input method with data: \" + update.message.text"], [199, "\tcustomId = update.message.text"], [200, "\ttry:"], [201, "\t\tint(customId)"], [202, "\texcept ValueError:"], [203, "\t\tprint \"invalid number\""], [204, "\t\tupdate.message.reply_text(\"Not a valid number\")"], [205, "\telse:"], [206, "\t\tprint \"valid number\""], [207, "        \tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [208, "        \tcursor = connection.cursor ()"], [209, "\t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))"], [210, "\t        data = cursor.fetchall()"], [211, "\t\tcursor.close()"], [212, "\t\tconnection.close()"], [213, "\t\tif data:"], [214, "\t\t\tprint \"scan ID was found in the db\""], [215, "\t\t\tprint \"data[0][0] is: \" + str(data[0][0])"], [216, "\t\t\tif data[0][0] == None:"], [217, "\t\t\t\tprint \"EndDate of scan is empty\""], [218, "\t\t\t\tupdate.message.reply_text(\"This scan hasn't finished yet\")"], [219, "\t\t\telse:"], [220, "\t\t\t\tprint \"Valid scan found\""], [221, "\t\t\t\treply_markup = telegram.ReplyKeyboardRemove()"], [222, "\t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)"], [223, "\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))"], [224, "\t\t\t\treturn ConversationHandler.END"], [225, "\t\telse:"], [226, "\t\t\tprint \"Scan ID not found in db\""], [227, "\t\t\tupdate.message.reply_text(\"This scan ID doesn't exist\")"], [228, ""], [229, ""], [230, "def add_domain(bot, update):"], [231, "\tprint update.message.text"], [232, "\treturn BUTTON"], [233, ""], [234, ""], [235, "def edit_domain(bot, update):"], [236, "\tprint update.message.text"], [237, "\treturn BUTTON"], [238, ""], [239, ""], [240, "def get_domains(bot, update):"], [241, "\tprint update.message.text"], [242, "\treturn BUTTON"], [243, ""], [244, ""], [245, "def domains_contain(bot, update):"], [246, "\tprint update.message.text"], [247, "\treturn BUTTON"], [248, ""], [249, ""], [250, "def help(bot, update):"], [251, "\tupdate.message.reply_text(\"click /start to start :)\")"], [252, ""], [253, ""], [254, "def error(bot, update, error):"], [255, "\tlogger.warning('Update \"%s\" caused error \"%s\"', update, error)"], [256, ""], [257, ""], [258, "def cancel(bot, update):"], [259, "\tprint \"canceled\""], [260, "\treply_markup = telegram.ReplyKeyboardRemove()"], [261, "\tupdate.message.reply_text(\"canceled! Click or type /start to start again\", reply_markup=reply_markup)"], [262, "\treturn ConversationHandler.END"], [263, ""], [264, ""], [265, "def main():"], [266, "\t# Create the EventHandler and pass it your bot's token."], [267, "\tupdater = Updater(\"576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI\")"], [268, ""], [269, "\t# Get the dispatcher to register handlers"], [270, "\tdp = updater.dispatcher"], [271, ""], [272, "\t# Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO"], [273, "\tconv_handler = ConversationHandler("], [274, "\t\tentry_points=[CommandHandler('start', start)],"], [275, ""], [276, "\t\tstates={"], [277, "\t\t\tBUTTON: [CallbackQueryHandler(button),"], [278, "\t\t\t\t\t   CommandHandler('cancel', cancel)],"], [279, "\t\t\tCUSTOM_SCAN_ID_INPUT: [MessageHandler(Filters.text, custom_scan_id_input),"], [280, "\t\t\t\t\t   CommandHandler('cancel', cancel)],"], [281, "                        ADD_DOMAIN: [MessageHandler(Filters.text, add_domain),"], [282, "                                           CommandHandler('cancel', cancel)],"], [283, "                        EDIT_DOMAIN: [MessageHandler(Filters.text, edit_domain),"], [284, "                                           CommandHandler('cancel', cancel)],"], [285, "                        GET_DOMAINS: [MessageHandler(Filters.text, get_domains),"], [286, "                                           CommandHandler('cancel', cancel)],"], [287, "                        CONTAINS: [MessageHandler(Filters.text, domains_contain),"], [288, "                                           CommandHandler('cancel', cancel)]"], [289, ""], [290, "\t\t},"], [291, ""], [292, "\t\tfallbacks=[CommandHandler('cancel', cancel)]"], [293, "\t)"], [294, ""], [295, "\tdp.add_handler(conv_handler)"], [296, ""], [297, "\t# log all errors"], [298, "\tdp.add_error_handler(error)"], [299, ""], [300, "\t# Start the Bot"], [301, "\tupdater.start_polling()"], [302, ""], [303, "\t# Run the bot until you press Ctrl-C or the process receives SIGINT,"], [304, "\t# SIGTERM or SIGABRT. This should be used most of the time, since"], [305, "\t# start_polling() is non-blocking and will stop the bot gracefully."], [306, "\tupdater.idle()"], [307, ""], [308, ""], [309, "if __name__ == '__main__':"], [310, "\tmain()"]], "deleted": []}, "added_lines": 310, "deleted_lines": 0, "source_code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport logging, datetime, MySQLdb, os, telegram\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nfrom random import randint\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\nlogger = logging.getLogger(__name__)\n\nBUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n\ndef start(bot, update):\n\tuser = update.message.from_user\n\thour = datetime.datetime.now().hour\n\tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])\n\n\tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n\treply_markup = InlineKeyboardMarkup(keyboard)\n\tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n\tprint \"button before\"\n\treturn BUTTON\n\n\ndef button(bot, update):\n\tquery = update.callback_query\n\t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button\n\n\tprint \"button func called with: \" + query.data\n\tchoice = query.data.split('-')[0]\n\tr = str(randint(0, 99))\n\n\theader_1 = \"Catagory:\"\n\tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + r)]]\n\n\theader_2 = \"Action:\"\n\tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n\t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n\t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n\theader_3 = \"Action:\"\n\tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n\t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n\t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n        header_5 = \"Action:\"\n        keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n                         InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n\t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]\n\n        header_6 = \"Which type of domains?\"\n        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active_domains-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='all_domains-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n\n        header_7 = \"Which type of subdomains?\"\n        keyboard_7 = [[InlineKeyboardButton(\"Active\", callback_data='active_subdomains-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='all_subdomains-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n\n\t#ToDO: Transform into a swtich\n\tif choice == \"back\":\n\t\tbot.edit_message_text(header_1, reply_markup=InlineKeyboardMarkup(keyboard_1), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"close\":\n\t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)\n\telif choice == \"scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"data\":\n\t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\tcursor = connection.cursor ()\n\n\tif choice == \"latest\":\n\t\tget_latest_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\telif choice == \"custom\":\n\t\tget_custom_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\t\treturn CUSTOM_SCAN_ID_INPUT\n\telif choice == \"run\":\n\t\trun_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\n        if choice == \"add\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\treturn ADD_DOMAIN\n        elif choice == \"edit\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return EDIT_DOMAIN\n        elif choice == \"get\":\n                cursor.close()\n                connection.close()\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"topdomais\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"subdomains\":\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"contains\":\n\t\tbot.send_message(text=\"What is the search string?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return CONTAINS\n        elif choice == \"back_data\":\n                bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"back_get\":\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n\n\tif choice == \"yes_scan\":\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telif choice == \"back_scan\" or choice == \"no_scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\ndef get_latest_scan(bot, update, cursor):\n\tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))\n\telse:\n\t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\n\ndef get_custom_scan(bot, update, cursor):\n\tquery = update.callback_query\n\n\tcursor.execute (\"SELECT ScanID FROM scans where EndDate is not null ORDER BY ScanID DESC LIMIT 10\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tlatestScanIds = sorted([str(x[0]) for x in data])\n\t\tfirstRow = latestScanIds[:len(latestScanIds)/2]\n\t\tsecondRow = latestScanIds[len(latestScanIds)/2:]\n\t\tcustom_keyboard = [firstRow, secondRow]\n\t\treply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\n\n\t\tif data:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\ttext=\"Which scan ID? \\n/cancel to cancel\",\n\t\t\t\treply_markup=reply_markup, ForceReply = True)\n\t\telse:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\t text=\"Which scan ID? \\n/cancel to cancel\")\n\n\ndef run_scan(bot, update, cursor):\n\tquery = update.callback_query\n\tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")\n\tdata = cursor.fetchall()\n\tif data[0][2] != None:\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telse:\n\t\tr = str(randint(0, 99))\n\t        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        \tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                \t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        \t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n\ndef custom_scan_id_input(bot, update):\n\tprint \"inside input method with data: \" + update.message.text\n\tcustomId = update.message.text\n\ttry:\n\t\tint(customId)\n\texcept ValueError:\n\t\tprint \"invalid number\"\n\t\tupdate.message.reply_text(\"Not a valid number\")\n\telse:\n\t\tprint \"valid number\"\n        \tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n        \tcursor = connection.cursor ()\n\t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))\n\t        data = cursor.fetchall()\n\t\tcursor.close()\n\t\tconnection.close()\n\t\tif data:\n\t\t\tprint \"scan ID was found in the db\"\n\t\t\tprint \"data[0][0] is: \" + str(data[0][0])\n\t\t\tif data[0][0] == None:\n\t\t\t\tprint \"EndDate of scan is empty\"\n\t\t\t\tupdate.message.reply_text(\"This scan hasn't finished yet\")\n\t\t\telse:\n\t\t\t\tprint \"Valid scan found\"\n\t\t\t\treply_markup = telegram.ReplyKeyboardRemove()\n\t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)\n\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))\n\t\t\t\treturn ConversationHandler.END\n\t\telse:\n\t\t\tprint \"Scan ID not found in db\"\n\t\t\tupdate.message.reply_text(\"This scan ID doesn't exist\")\n\n\ndef add_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef edit_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef get_domains(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef domains_contain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef help(bot, update):\n\tupdate.message.reply_text(\"click /start to start :)\")\n\n\ndef error(bot, update, error):\n\tlogger.warning('Update \"%s\" caused error \"%s\"', update, error)\n\t\t\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treply_markup = telegram.ReplyKeyboardRemove()\n\tupdate.message.reply_text(\"canceled! Click or type /start to start again\", reply_markup=reply_markup)\n\treturn ConversationHandler.END\n\n\ndef main():\n\t# Create the EventHandler and pass it your bot's token.\n\tupdater = Updater(\"576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI\")\n\n\t# Get the dispatcher to register handlers\n\tdp = updater.dispatcher\n\n\t# Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t\tBUTTON: [CallbackQueryHandler(button),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n\t\t\tCUSTOM_SCAN_ID_INPUT: [MessageHandler(Filters.text, custom_scan_id_input),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n                        ADD_DOMAIN: [MessageHandler(Filters.text, add_domain),\n                                           CommandHandler('cancel', cancel)],\n                        EDIT_DOMAIN: [MessageHandler(Filters.text, edit_domain),\n                                           CommandHandler('cancel', cancel)],\n                        GET_DOMAINS: [MessageHandler(Filters.text, get_domains),\n                                           CommandHandler('cancel', cancel)],\n                        CONTAINS: [MessageHandler(Filters.text, domains_contain),\n                                           CommandHandler('cancel', cancel)]\n\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\n\t# log all errors\n\tdp.add_error_handler(error)\n\n\t# Start the Bot\n\tupdater.start_polling()\n\n\t# Run the bot until you press Ctrl-C or the process receives SIGINT,\n\t# SIGTERM or SIGABRT. This should be used most of the time, since\n\t# start_polling() is non-blocking and will stop the bot gracefully.\n\tupdater.idle()\n\n\nif __name__ == '__main__':\n\tmain()\n", "source_code_before": null, "methods": [{"name": "start", "start_line": 17, "end_line": 29}, {"name": "button", "start_line": 32, "end_line": 146}, {"name": "get_latest_scan", "start_line": 149, "end_line": 155}, {"name": "get_custom_scan", "start_line": 158, "end_line": 176}, {"name": "run_scan", "start_line": 179, "end_line": 194}, {"name": "custom_scan_id_input", "start_line": 197, "end_line": 227}, {"name": "add_domain", "start_line": 230, "end_line": 232}, {"name": "edit_domain", "start_line": 235, "end_line": 237}, {"name": "get_domains", "start_line": 240, "end_line": 242}, {"name": "domains_contain", "start_line": 245, "end_line": 247}, {"name": "help", "start_line": 250, "end_line": 251}, {"name": "error", "start_line": 254, "end_line": 255}, {"name": "cancel", "start_line": 258, "end_line": 262}, {"name": "main", "start_line": 265, "end_line": 306}], "methods_before": [], "changed_methods": [{"name": "get_domains", "start_line": 240, "end_line": 242}, {"name": "domains_contain", "start_line": 245, "end_line": 247}, {"name": "help", "start_line": 250, "end_line": 251}, {"name": "button", "start_line": 32, "end_line": 146}, {"name": "error", "start_line": 254, "end_line": 255}, {"name": "main", "start_line": 265, "end_line": 306}, {"name": "edit_domain", "start_line": 235, "end_line": 237}, {"name": "run_scan", "start_line": 179, "end_line": 194}, {"name": "get_custom_scan", "start_line": 158, "end_line": 176}, {"name": "start", "start_line": 17, "end_line": 29}, {"name": "custom_scan_id_input", "start_line": 197, "end_line": 227}, {"name": "add_domain", "start_line": 230, "end_line": 232}, {"name": "cancel", "start_line": 258, "end_line": 262}, {"name": "get_latest_scan", "start_line": 149, "end_line": 155}], "nloc": 233, "complexity": 42, "token_count": 2126}, {"old_path": null, "new_path": "telegram/notify.py", "filename": "notify.py", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1,39 @@\n+#!/usr/bin/python\n+\n+import sys, datetime, MySQLdb, telegram\n+\n+bot = telegram.Bot('576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI')\n+scanId = sys.argv[1]\n+message = \"*\" + str(datetime.datetime.now().replace(microsecond=0)) + \"*\"\n+\n+connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+cursor = connection.cursor()\n+\n+cursor.execute (\"select * from domains where scan_Id = %s and Active order by TopDomainID\", (scanId))\n+newSubDomains = cursor.fetchall()\n+\n+cursor.execute (\"select * from errors where scan_Id = %s order by ErrorDate\", (scanId))\n+errors = cursor.fetchall()\n+\n+connection.close()\n+\n+message += \"\\n_Scan \" + str(scanId) + \"_\"\n+\n+message += \"\\n\"\n+\n+if len(errors) > 1:\n+        message += \"\\n(\" + str(len(errors)) + \"  Errors)\"\n+elif len(errors) == 1:\n+        message += \"\\n(\" + str(len(errors)) + \"  Error)\"\n+\n+if len(errors) > 0:\n+\tmessage += \"\\n--------------\"\n+\n+if len(newSubDomains) > 1:\n+\tmessage += \"\\n\\[+] \" + str(len(newSubDomains)) + \" New subdomains:\"\n+elif len(newSubDomains) == 1:\n+\tmessage += \"\\n\\[+] \" + str(len(newSubDomains)) + \" New subdomain:\"\n+\n+message += \"\"\n+\n+bot.send_message(chat_id=476443218, text=message, parse_mode=telegram.ParseMode.MARKDOWN)\n", "diff_parsed": {"added": [[1, "#!/usr/bin/python"], [2, ""], [3, "import sys, datetime, MySQLdb, telegram"], [4, ""], [5, "bot = telegram.Bot('576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI')"], [6, "scanId = sys.argv[1]"], [7, "message = \"*\" + str(datetime.datetime.now().replace(microsecond=0)) + \"*\""], [8, ""], [9, "connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [10, "cursor = connection.cursor()"], [11, ""], [12, "cursor.execute (\"select * from domains where scan_Id = %s and Active order by TopDomainID\", (scanId))"], [13, "newSubDomains = cursor.fetchall()"], [14, ""], [15, "cursor.execute (\"select * from errors where scan_Id = %s order by ErrorDate\", (scanId))"], [16, "errors = cursor.fetchall()"], [17, ""], [18, "connection.close()"], [19, ""], [20, "message += \"\\n_Scan \" + str(scanId) + \"_\""], [21, ""], [22, "message += \"\\n\""], [23, ""], [24, "if len(errors) > 1:"], [25, "        message += \"\\n(\" + str(len(errors)) + \"  Errors)\""], [26, "elif len(errors) == 1:"], [27, "        message += \"\\n(\" + str(len(errors)) + \"  Error)\""], [28, ""], [29, "if len(errors) > 0:"], [30, "\tmessage += \"\\n--------------\""], [31, ""], [32, "if len(newSubDomains) > 1:"], [33, "\tmessage += \"\\n\\[+] \" + str(len(newSubDomains)) + \" New subdomains:\""], [34, "elif len(newSubDomains) == 1:"], [35, "\tmessage += \"\\n\\[+] \" + str(len(newSubDomains)) + \" New subdomain:\""], [36, ""], [37, "message += \"\""], [38, ""], [39, "bot.send_message(chat_id=476443218, text=message, parse_mode=telegram.ParseMode.MARKDOWN)"]], "deleted": []}, "added_lines": 39, "deleted_lines": 0, "source_code": "#!/usr/bin/python\n\nimport sys, datetime, MySQLdb, telegram\n\nbot = telegram.Bot('576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI')\nscanId = sys.argv[1]\nmessage = \"*\" + str(datetime.datetime.now().replace(microsecond=0)) + \"*\"\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\ncursor = connection.cursor()\n\ncursor.execute (\"select * from domains where scan_Id = %s and Active order by TopDomainID\", (scanId))\nnewSubDomains = cursor.fetchall()\n\ncursor.execute (\"select * from errors where scan_Id = %s order by ErrorDate\", (scanId))\nerrors = cursor.fetchall()\n\nconnection.close()\n\nmessage += \"\\n_Scan \" + str(scanId) + \"_\"\n\nmessage += \"\\n\"\n\nif len(errors) > 1:\n        message += \"\\n(\" + str(len(errors)) + \"  Errors)\"\nelif len(errors) == 1:\n        message += \"\\n(\" + str(len(errors)) + \"  Error)\"\n\nif len(errors) > 0:\n\tmessage += \"\\n--------------\"\n\nif len(newSubDomains) > 1:\n\tmessage += \"\\n\\[+] \" + str(len(newSubDomains)) + \" New subdomains:\"\nelif len(newSubDomains) == 1:\n\tmessage += \"\\n\\[+] \" + str(len(newSubDomains)) + \" New subdomain:\"\n\nmessage += \"\"\n\nbot.send_message(chat_id=476443218, text=message, parse_mode=telegram.ParseMode.MARKDOWN)\n", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": 25, "complexity": 0, "token_count": 246}], "dmm_unit_size": 0.23011363636363635, "dmm_unit_complexity": 0.5994318181818182, "dmm_unit_interfacing": 0.8863636363636364},
    {"hash": "cf67a0253880df79101f3476c5dcf38feeb1642a", "msg": "Initialize", "author": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "committer": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "author_date": "2018-05-26 21:45:08+02:00", "author_timezone": -7200, "committer_date": "2018-05-26 21:45:08+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["f30bfc8542a2ab1896d10d7e0543c3e8ef9aafa2"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 10, "insertions": 49, "lines": 59, "files": 2, "modified_files": [{"old_path": null, "new_path": "install.sh", "filename": "install.sh", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1 @@\n+temp\n", "diff_parsed": {"added": [[1, "temp"]], "deleted": []}, "added_lines": 1, "deleted_lines": 0, "source_code": "temp\n", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}, {"old_path": "telegram/bot.py", "new_path": "telegram/bot.py", "filename": "bot.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -66,14 +66,15 @@ def button(bot, update):\n                         [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]\n \n         header_6 = \"Which type of domains?\"\n-        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active_domains-' + r),\n-                         InlineKeyboardButton(\"All\", callback_data='all_domains-' + r)],\n+        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active-' + r),\n+                         InlineKeyboardButton(\"All\", callback_data='all-' + r)],\n                         [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n \n-        header_7 = \"Which type of subdomains?\"\n-        keyboard_7 = [[InlineKeyboardButton(\"Active\", callback_data='active_subdomains-' + r),\n-                         InlineKeyboardButton(\"All\", callback_data='all_subdomains-' + r)],\n-                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n+        header_7 = \"How many domains?\"\n+        keyboard_7 = [[InlineKeyboardButton(\"Top 20\", callback_data='limit-' + r),\n+                         InlineKeyboardButton(\"All\", callback_data='nolimit-' + r)],\n+                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_data-' + r)]]\n+\n \n \t#ToDO: Transform into a swtich\n \tif choice == \"back\":\n@@ -123,10 +124,14 @@ def button(bot, update):\n \n         if choice == \"topdomais\":\n                 bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n-                return BUTTON\n+                global subdomains\n+\t\tsubdomains = False\n+\t\treturn BUTTON\n         elif choice == \"subdomains\":\n-                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n-                return BUTTON\n+                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n+                global subdomains\n+\t\tsubdomains = True\n+\t\treturn BUTTON\n         elif choice == \"contains\":\n \t\tbot.send_message(text=\"What is the search string?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                 return CONTAINS\n@@ -137,6 +142,39 @@ def button(bot, update):\n                 bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                 return BUTTON\n \n+        if choice == \"active\":\n+\t\tglobal active\n+\t\tactive = True\n+                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n+\t\treturn BUTTON\n+        elif choice == \"all\":\n+                global active\n+                active = False\n+                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n+                return BUTTON\n+\n+        if choice == \"nolimit\":\n+\t\tglobal subdomains\n+\t\tif subdomains:\n+                        global limit\n+                        limit = False\n+\t\t\tbot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n+\t\t\treturn GET_DOMAINS\n+\t\telse:\n+\t\t\tglobal limit\n+\t\t\tlimit = False\n+\t\t\tget_topdomains()\n+        elif choice == \"limit\":\n+                global subdomains\n+                if subdomains:\n+                        global limit\n+                        limit = True\n+                        bot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n+                        return GET_DOMAINS\n+                else:\n+                        global limit\n+                        limit = True\n+\t\t\tget_topdomains()\n \n \tif choice == \"yes_scan\":\n \t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n@@ -237,7 +275,7 @@ def edit_domain(bot, update):\n \treturn BUTTON\n \n \n-def get_domains(bot, update):\n+def get_domains():\n \tprint update.message.text\n \treturn BUTTON\n \n", "diff_parsed": {"added": [[69, "        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active-' + r),"], [70, "                         InlineKeyboardButton(\"All\", callback_data='all-' + r)],"], [73, "        header_7 = \"How many domains?\""], [74, "        keyboard_7 = [[InlineKeyboardButton(\"Top 20\", callback_data='limit-' + r),"], [75, "                         InlineKeyboardButton(\"All\", callback_data='nolimit-' + r)],"], [76, "                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_data-' + r)]]"], [77, ""], [127, "                global subdomains"], [128, "\t\tsubdomains = False"], [129, "\t\treturn BUTTON"], [131, "                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)"], [132, "                global subdomains"], [133, "\t\tsubdomains = True"], [134, "\t\treturn BUTTON"], [145, "        if choice == \"active\":"], [146, "\t\tglobal active"], [147, "\t\tactive = True"], [148, "                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)"], [149, "\t\treturn BUTTON"], [150, "        elif choice == \"all\":"], [151, "                global active"], [152, "                active = False"], [153, "                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)"], [154, "                return BUTTON"], [155, ""], [156, "        if choice == \"nolimit\":"], [157, "\t\tglobal subdomains"], [158, "\t\tif subdomains:"], [159, "                        global limit"], [160, "                        limit = False"], [161, "\t\t\tbot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)"], [162, "\t\t\treturn GET_DOMAINS"], [163, "\t\telse:"], [164, "\t\t\tglobal limit"], [165, "\t\t\tlimit = False"], [166, "\t\t\tget_topdomains()"], [167, "        elif choice == \"limit\":"], [168, "                global subdomains"], [169, "                if subdomains:"], [170, "                        global limit"], [171, "                        limit = True"], [172, "                        bot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)"], [173, "                        return GET_DOMAINS"], [174, "                else:"], [175, "                        global limit"], [176, "                        limit = True"], [177, "\t\t\tget_topdomains()"], [278, "def get_domains():"]], "deleted": [[69, "        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active_domains-' + r),"], [70, "                         InlineKeyboardButton(\"All\", callback_data='all_domains-' + r)],"], [73, "        header_7 = \"Which type of subdomains?\""], [74, "        keyboard_7 = [[InlineKeyboardButton(\"Active\", callback_data='active_subdomains-' + r),"], [75, "                         InlineKeyboardButton(\"All\", callback_data='all_subdomains-' + r)],"], [76, "                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]"], [126, "                return BUTTON"], [128, "                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)"], [129, "                return BUTTON"], [240, "def get_domains(bot, update):"]]}, "added_lines": 48, "deleted_lines": 10, "source_code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport logging, datetime, MySQLdb, os, telegram\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nfrom random import randint\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\nlogger = logging.getLogger(__name__)\n\nBUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n\ndef start(bot, update):\n\tuser = update.message.from_user\n\thour = datetime.datetime.now().hour\n\tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])\n\n\tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n\treply_markup = InlineKeyboardMarkup(keyboard)\n\tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n\tprint \"button before\"\n\treturn BUTTON\n\n\ndef button(bot, update):\n\tquery = update.callback_query\n\t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button\n\n\tprint \"button func called with: \" + query.data\n\tchoice = query.data.split('-')[0]\n\tr = str(randint(0, 99))\n\n\theader_1 = \"Catagory:\"\n\tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + r)]]\n\n\theader_2 = \"Action:\"\n\tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n\t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n\t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n\theader_3 = \"Action:\"\n\tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n\t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n\t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n        header_5 = \"Action:\"\n        keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n                         InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n\t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]\n\n        header_6 = \"Which type of domains?\"\n        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='all-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n\n        header_7 = \"How many domains?\"\n        keyboard_7 = [[InlineKeyboardButton(\"Top 20\", callback_data='limit-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='nolimit-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_data-' + r)]]\n\n\n\t#ToDO: Transform into a swtich\n\tif choice == \"back\":\n\t\tbot.edit_message_text(header_1, reply_markup=InlineKeyboardMarkup(keyboard_1), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"close\":\n\t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)\n\telif choice == \"scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"data\":\n\t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\tcursor = connection.cursor ()\n\n\tif choice == \"latest\":\n\t\tget_latest_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\telif choice == \"custom\":\n\t\tget_custom_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\t\treturn CUSTOM_SCAN_ID_INPUT\n\telif choice == \"run\":\n\t\trun_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\n        if choice == \"add\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\treturn ADD_DOMAIN\n        elif choice == \"edit\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return EDIT_DOMAIN\n        elif choice == \"get\":\n                cursor.close()\n                connection.close()\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"topdomais\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = False\n\t\treturn BUTTON\n        elif choice == \"subdomains\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = True\n\t\treturn BUTTON\n        elif choice == \"contains\":\n\t\tbot.send_message(text=\"What is the search string?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return CONTAINS\n        elif choice == \"back_data\":\n                bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"back_get\":\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"active\":\n\t\tglobal active\n\t\tactive = True\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n        elif choice == \"all\":\n                global active\n                active = False\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"nolimit\":\n\t\tglobal subdomains\n\t\tif subdomains:\n                        global limit\n                        limit = False\n\t\t\tbot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\treturn GET_DOMAINS\n\t\telse:\n\t\t\tglobal limit\n\t\t\tlimit = False\n\t\t\tget_topdomains()\n        elif choice == \"limit\":\n                global subdomains\n                if subdomains:\n                        global limit\n                        limit = True\n                        bot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                        return GET_DOMAINS\n                else:\n                        global limit\n                        limit = True\n\t\t\tget_topdomains()\n\n\tif choice == \"yes_scan\":\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telif choice == \"back_scan\" or choice == \"no_scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\ndef get_latest_scan(bot, update, cursor):\n\tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))\n\telse:\n\t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\n\ndef get_custom_scan(bot, update, cursor):\n\tquery = update.callback_query\n\n\tcursor.execute (\"SELECT ScanID FROM scans where EndDate is not null ORDER BY ScanID DESC LIMIT 10\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tlatestScanIds = sorted([str(x[0]) for x in data])\n\t\tfirstRow = latestScanIds[:len(latestScanIds)/2]\n\t\tsecondRow = latestScanIds[len(latestScanIds)/2:]\n\t\tcustom_keyboard = [firstRow, secondRow]\n\t\treply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\n\n\t\tif data:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\ttext=\"Which scan ID? \\n/cancel to cancel\",\n\t\t\t\treply_markup=reply_markup, ForceReply = True)\n\t\telse:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\t text=\"Which scan ID? \\n/cancel to cancel\")\n\n\ndef run_scan(bot, update, cursor):\n\tquery = update.callback_query\n\tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")\n\tdata = cursor.fetchall()\n\tif data[0][2] != None:\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telse:\n\t\tr = str(randint(0, 99))\n\t        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        \tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                \t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        \t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n\ndef custom_scan_id_input(bot, update):\n\tprint \"inside input method with data: \" + update.message.text\n\tcustomId = update.message.text\n\ttry:\n\t\tint(customId)\n\texcept ValueError:\n\t\tprint \"invalid number\"\n\t\tupdate.message.reply_text(\"Not a valid number\")\n\telse:\n\t\tprint \"valid number\"\n        \tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n        \tcursor = connection.cursor ()\n\t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))\n\t        data = cursor.fetchall()\n\t\tcursor.close()\n\t\tconnection.close()\n\t\tif data:\n\t\t\tprint \"scan ID was found in the db\"\n\t\t\tprint \"data[0][0] is: \" + str(data[0][0])\n\t\t\tif data[0][0] == None:\n\t\t\t\tprint \"EndDate of scan is empty\"\n\t\t\t\tupdate.message.reply_text(\"This scan hasn't finished yet\")\n\t\t\telse:\n\t\t\t\tprint \"Valid scan found\"\n\t\t\t\treply_markup = telegram.ReplyKeyboardRemove()\n\t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)\n\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))\n\t\t\t\treturn ConversationHandler.END\n\t\telse:\n\t\t\tprint \"Scan ID not found in db\"\n\t\t\tupdate.message.reply_text(\"This scan ID doesn't exist\")\n\n\ndef add_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef edit_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef get_domains():\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef domains_contain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef help(bot, update):\n\tupdate.message.reply_text(\"click /start to start :)\")\n\n\ndef error(bot, update, error):\n\tlogger.warning('Update \"%s\" caused error \"%s\"', update, error)\n\t\t\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treply_markup = telegram.ReplyKeyboardRemove()\n\tupdate.message.reply_text(\"canceled! Click or type /start to start again\", reply_markup=reply_markup)\n\treturn ConversationHandler.END\n\n\ndef main():\n\t# Create the EventHandler and pass it your bot's token.\n\tupdater = Updater(\"576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI\")\n\n\t# Get the dispatcher to register handlers\n\tdp = updater.dispatcher\n\n\t# Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t\tBUTTON: [CallbackQueryHandler(button),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n\t\t\tCUSTOM_SCAN_ID_INPUT: [MessageHandler(Filters.text, custom_scan_id_input),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n                        ADD_DOMAIN: [MessageHandler(Filters.text, add_domain),\n                                           CommandHandler('cancel', cancel)],\n                        EDIT_DOMAIN: [MessageHandler(Filters.text, edit_domain),\n                                           CommandHandler('cancel', cancel)],\n                        GET_DOMAINS: [MessageHandler(Filters.text, get_domains),\n                                           CommandHandler('cancel', cancel)],\n                        CONTAINS: [MessageHandler(Filters.text, domains_contain),\n                                           CommandHandler('cancel', cancel)]\n\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\n\t# log all errors\n\tdp.add_error_handler(error)\n\n\t# Start the Bot\n\tupdater.start_polling()\n\n\t# Run the bot until you press Ctrl-C or the process receives SIGINT,\n\t# SIGTERM or SIGABRT. This should be used most of the time, since\n\t# start_polling() is non-blocking and will stop the bot gracefully.\n\tupdater.idle()\n\n\nif __name__ == '__main__':\n\tmain()\n", "source_code_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport logging, datetime, MySQLdb, os, telegram\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nfrom random import randint\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\nlogger = logging.getLogger(__name__)\n\nBUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n\ndef start(bot, update):\n\tuser = update.message.from_user\n\thour = datetime.datetime.now().hour\n\tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])\n\n\tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n\treply_markup = InlineKeyboardMarkup(keyboard)\n\tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n\tprint \"button before\"\n\treturn BUTTON\n\n\ndef button(bot, update):\n\tquery = update.callback_query\n\t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button\n\n\tprint \"button func called with: \" + query.data\n\tchoice = query.data.split('-')[0]\n\tr = str(randint(0, 99))\n\n\theader_1 = \"Catagory:\"\n\tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + r)]]\n\n\theader_2 = \"Action:\"\n\tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n\t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n\t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n\theader_3 = \"Action:\"\n\tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n\t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n\t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n        header_5 = \"Action:\"\n        keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n                         InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n\t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]\n\n        header_6 = \"Which type of domains?\"\n        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active_domains-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='all_domains-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n\n        header_7 = \"Which type of subdomains?\"\n        keyboard_7 = [[InlineKeyboardButton(\"Active\", callback_data='active_subdomains-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='all_subdomains-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n\n\t#ToDO: Transform into a swtich\n\tif choice == \"back\":\n\t\tbot.edit_message_text(header_1, reply_markup=InlineKeyboardMarkup(keyboard_1), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"close\":\n\t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)\n\telif choice == \"scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"data\":\n\t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\tcursor = connection.cursor ()\n\n\tif choice == \"latest\":\n\t\tget_latest_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\telif choice == \"custom\":\n\t\tget_custom_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\t\treturn CUSTOM_SCAN_ID_INPUT\n\telif choice == \"run\":\n\t\trun_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\n        if choice == \"add\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\treturn ADD_DOMAIN\n        elif choice == \"edit\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return EDIT_DOMAIN\n        elif choice == \"get\":\n                cursor.close()\n                connection.close()\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"topdomais\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"subdomains\":\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"contains\":\n\t\tbot.send_message(text=\"What is the search string?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return CONTAINS\n        elif choice == \"back_data\":\n                bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"back_get\":\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n\n\tif choice == \"yes_scan\":\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telif choice == \"back_scan\" or choice == \"no_scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\ndef get_latest_scan(bot, update, cursor):\n\tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))\n\telse:\n\t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\n\ndef get_custom_scan(bot, update, cursor):\n\tquery = update.callback_query\n\n\tcursor.execute (\"SELECT ScanID FROM scans where EndDate is not null ORDER BY ScanID DESC LIMIT 10\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tlatestScanIds = sorted([str(x[0]) for x in data])\n\t\tfirstRow = latestScanIds[:len(latestScanIds)/2]\n\t\tsecondRow = latestScanIds[len(latestScanIds)/2:]\n\t\tcustom_keyboard = [firstRow, secondRow]\n\t\treply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\n\n\t\tif data:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\ttext=\"Which scan ID? \\n/cancel to cancel\",\n\t\t\t\treply_markup=reply_markup, ForceReply = True)\n\t\telse:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\t text=\"Which scan ID? \\n/cancel to cancel\")\n\n\ndef run_scan(bot, update, cursor):\n\tquery = update.callback_query\n\tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")\n\tdata = cursor.fetchall()\n\tif data[0][2] != None:\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telse:\n\t\tr = str(randint(0, 99))\n\t        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        \tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                \t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        \t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n\ndef custom_scan_id_input(bot, update):\n\tprint \"inside input method with data: \" + update.message.text\n\tcustomId = update.message.text\n\ttry:\n\t\tint(customId)\n\texcept ValueError:\n\t\tprint \"invalid number\"\n\t\tupdate.message.reply_text(\"Not a valid number\")\n\telse:\n\t\tprint \"valid number\"\n        \tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n        \tcursor = connection.cursor ()\n\t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))\n\t        data = cursor.fetchall()\n\t\tcursor.close()\n\t\tconnection.close()\n\t\tif data:\n\t\t\tprint \"scan ID was found in the db\"\n\t\t\tprint \"data[0][0] is: \" + str(data[0][0])\n\t\t\tif data[0][0] == None:\n\t\t\t\tprint \"EndDate of scan is empty\"\n\t\t\t\tupdate.message.reply_text(\"This scan hasn't finished yet\")\n\t\t\telse:\n\t\t\t\tprint \"Valid scan found\"\n\t\t\t\treply_markup = telegram.ReplyKeyboardRemove()\n\t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)\n\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))\n\t\t\t\treturn ConversationHandler.END\n\t\telse:\n\t\t\tprint \"Scan ID not found in db\"\n\t\t\tupdate.message.reply_text(\"This scan ID doesn't exist\")\n\n\ndef add_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef edit_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef get_domains(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef domains_contain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef help(bot, update):\n\tupdate.message.reply_text(\"click /start to start :)\")\n\n\ndef error(bot, update, error):\n\tlogger.warning('Update \"%s\" caused error \"%s\"', update, error)\n\t\t\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treply_markup = telegram.ReplyKeyboardRemove()\n\tupdate.message.reply_text(\"canceled! Click or type /start to start again\", reply_markup=reply_markup)\n\treturn ConversationHandler.END\n\n\ndef main():\n\t# Create the EventHandler and pass it your bot's token.\n\tupdater = Updater(\"576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI\")\n\n\t# Get the dispatcher to register handlers\n\tdp = updater.dispatcher\n\n\t# Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t\tBUTTON: [CallbackQueryHandler(button),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n\t\t\tCUSTOM_SCAN_ID_INPUT: [MessageHandler(Filters.text, custom_scan_id_input),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n                        ADD_DOMAIN: [MessageHandler(Filters.text, add_domain),\n                                           CommandHandler('cancel', cancel)],\n                        EDIT_DOMAIN: [MessageHandler(Filters.text, edit_domain),\n                                           CommandHandler('cancel', cancel)],\n                        GET_DOMAINS: [MessageHandler(Filters.text, get_domains),\n                                           CommandHandler('cancel', cancel)],\n                        CONTAINS: [MessageHandler(Filters.text, domains_contain),\n                                           CommandHandler('cancel', cancel)]\n\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\n\t# log all errors\n\tdp.add_error_handler(error)\n\n\t# Start the Bot\n\tupdater.start_polling()\n\n\t# Run the bot until you press Ctrl-C or the process receives SIGINT,\n\t# SIGTERM or SIGABRT. This should be used most of the time, since\n\t# start_polling() is non-blocking and will stop the bot gracefully.\n\tupdater.idle()\n\n\nif __name__ == '__main__':\n\tmain()\n", "methods": [{"name": "start", "start_line": 17, "end_line": 29}, {"name": "button", "start_line": 32, "end_line": 184}, {"name": "get_latest_scan", "start_line": 187, "end_line": 193}, {"name": "get_custom_scan", "start_line": 196, "end_line": 214}, {"name": "run_scan", "start_line": 217, "end_line": 232}, {"name": "custom_scan_id_input", "start_line": 235, "end_line": 265}, {"name": "add_domain", "start_line": 268, "end_line": 270}, {"name": "edit_domain", "start_line": 273, "end_line": 275}, {"name": "get_domains", "start_line": 278, "end_line": 280}, {"name": "domains_contain", "start_line": 283, "end_line": 285}, {"name": "help", "start_line": 288, "end_line": 289}, {"name": "error", "start_line": 292, "end_line": 293}, {"name": "cancel", "start_line": 296, "end_line": 300}, {"name": "main", "start_line": 303, "end_line": 344}], "methods_before": [{"name": "start", "start_line": 17, "end_line": 29}, {"name": "button", "start_line": 32, "end_line": 146}, {"name": "get_latest_scan", "start_line": 149, "end_line": 155}, {"name": "get_custom_scan", "start_line": 158, "end_line": 176}, {"name": "run_scan", "start_line": 179, "end_line": 194}, {"name": "custom_scan_id_input", "start_line": 197, "end_line": 227}, {"name": "add_domain", "start_line": 230, "end_line": 232}, {"name": "edit_domain", "start_line": 235, "end_line": 237}, {"name": "get_domains", "start_line": 240, "end_line": 242}, {"name": "domains_contain", "start_line": 245, "end_line": 247}, {"name": "help", "start_line": 250, "end_line": 251}, {"name": "error", "start_line": 254, "end_line": 255}, {"name": "cancel", "start_line": 258, "end_line": 262}, {"name": "main", "start_line": 265, "end_line": 306}], "changed_methods": [{"name": "get_domains", "start_line": 240, "end_line": 242}, {"name": "get_domains", "start_line": 278, "end_line": 280}, {"name": "button", "start_line": 32, "end_line": 184}], "nloc": 269, "complexity": 48, "token_count": 2317}], "dmm_unit_size": 0.0, "dmm_unit_complexity": 0.0, "dmm_unit_interfacing": 1.0},
    {"hash": "fd519918f2192de40d7437064df736dc6aa4a108", "msg": "Quite some changes...", "author": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "committer": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "author_date": "2018-05-27 02:43:27+02:00", "author_timezone": -7200, "committer_date": "2018-05-27 02:43:27+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["cf67a0253880df79101f3476c5dcf38feeb1642a"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 80, "insertions": 185, "lines": 265, "files": 9, "modified_files": [{"old_path": "database/additional_tools/sublister_to_db.py", "new_path": "database/additional_tools/sublister_to_db.py", "filename": "sublister_to_db.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -7,13 +7,13 @@ try:\n \tcursor = connection.cursor()\n \tscanId = sys.argv[2]\n \n-\tif not os.path.exists(\"/tmp/recon_domain_files\"):\n-\t\tos.makedirs(\"/tmp/recon_domain_files\")\n+\tif not os.path.exists(\"/tmp/ICU\"):\n+\t\tos.makedirs(\"/tmp/ICU\")\n \n-\tif not os.path.exists(\"/tmp/recon_domain_files/\"+domain+\"/\"):\n-\t    os.makedirs(\"/tmp/recon_domain_files/\"+domain+\"/\")\n+\tif not os.path.exists(\"/tmp/ICU/\"+domain+\"/\"):\n+\t    os.makedirs(\"/tmp/ICU/\"+domain+\"/\")\n \n-\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../../dependencies/sublister/sublist3r.py -o /tmp/recon_domain_files/\"+domain+\"/domains-all.txt -d \"+domain)\n+\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n \n \tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n \tdatabase_data = cursor.fetchall()\n@@ -23,12 +23,16 @@ try:\n         program = [x[3] for x in database_data if x[0] == domain][0]\n         topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n \n-\tdomains_all = open(\"/tmp/recon_domain_files/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n+\tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n \tdomains_all.extend(x for x in database_domains if x not in domains_all)\n \n-\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../../tools/online.py /tmp/recon_domain_files/\"+domain+\"/domains-all.txt /tmp/recon_domain_files/\"+domain+\"/domains-online.txt\")\n+\tdomains_all_combined_file = open(\"/tmp/ICU/\"+domain+\"/domains-all-combined.txt\", 'w')\n+\tfor item in domains_all:\n+\t\tdomains_all_combined_file.write(\"%s\\n\" % item)\n \n-\tdomains_online = open(\"/tmp/recon_domain_files/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n+\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all-combined.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")\n+\n+\tdomains_online = open(\"/tmp/ICU/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n \n \tfor sub_domain in domains_all:\n \t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n", "diff_parsed": {"added": [[10, "\tif not os.path.exists(\"/tmp/ICU\"):"], [11, "\t\tos.makedirs(\"/tmp/ICU\")"], [13, "\tif not os.path.exists(\"/tmp/ICU/\"+domain+\"/\"):"], [14, "\t    os.makedirs(\"/tmp/ICU/\"+domain+\"/\")"], [16, "\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)"], [26, "\tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')"], [29, "\tdomains_all_combined_file = open(\"/tmp/ICU/\"+domain+\"/domains-all-combined.txt\", 'w')"], [30, "\tfor item in domains_all:"], [31, "\t\tdomains_all_combined_file.write(\"%s\\n\" % item)"], [33, "\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all-combined.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")"], [34, ""], [35, "\tdomains_online = open(\"/tmp/ICU/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')"]], "deleted": [[10, "\tif not os.path.exists(\"/tmp/recon_domain_files\"):"], [11, "\t\tos.makedirs(\"/tmp/recon_domain_files\")"], [13, "\tif not os.path.exists(\"/tmp/recon_domain_files/\"+domain+\"/\"):"], [14, "\t    os.makedirs(\"/tmp/recon_domain_files/\"+domain+\"/\")"], [16, "\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../../dependencies/sublister/sublist3r.py -o /tmp/recon_domain_files/\"+domain+\"/domains-all.txt -d \"+domain)"], [26, "\tdomains_all = open(\"/tmp/recon_domain_files/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')"], [29, "\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../../tools/online.py /tmp/recon_domain_files/\"+domain+\"/domains-all.txt /tmp/recon_domain_files/\"+domain+\"/domains-online.txt\")"], [31, "\tdomains_online = open(\"/tmp/recon_domain_files/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')"]]}, "added_lines": 12, "deleted_lines": 8, "source_code": "#!/usr/bin/python\nimport os, sys, MySQLdb\n\ntry:\n\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\tdomain = sys.argv[1].strip()\n\tcursor = connection.cursor()\n\tscanId = sys.argv[2]\n\n\tif not os.path.exists(\"/tmp/ICU\"):\n\t\tos.makedirs(\"/tmp/ICU\")\n\n\tif not os.path.exists(\"/tmp/ICU/\"+domain+\"/\"):\n\t    os.makedirs(\"/tmp/ICU/\"+domain+\"/\")\n\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n\n\tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n\tdatabase_data = cursor.fetchall()\n\tdatabase_domains = [d[0] for d in database_data]\n\n        non_active_subdomains = [x[0] for x in database_data if ord(x[2]) == False]\n        program = [x[3] for x in database_data if x[0] == domain][0]\n        topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n\n\tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n\tdomains_all.extend(x for x in database_domains if x not in domains_all)\n\n\tdomains_all_combined_file = open(\"/tmp/ICU/\"+domain+\"/domains-all-combined.txt\", 'w')\n\tfor item in domains_all:\n\t\tdomains_all_combined_file.write(\"%s\\n\" % item)\n\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all-combined.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")\n\n\tdomains_online = open(\"/tmp/ICU/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n\n\tfor sub_domain in domains_all:\n\t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n\t\tif sub_domain in domains_online:\n\t\t\tactive=True\n\t\t\tif sub_domain in non_active_subdomains:\n\t\t\t\tinsertScanId = scanId\n\t\telse:\n\t\t\tactive=False\n\n\t\tif sub_domain:\n\t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))\n\t\t\tconnection.commit()\n\n\n\tcursor.close ()\n\tconnection.close ()\nexcept Exception as e:\n\tprint \"error in sublister_to_db.py with main domain; \" + domain\n\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in sublister_to_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n\tconnection.commit()\n\tcursor.close()\n\tconnection.close()\n\tprint e\nsys.exit()\n", "source_code_before": "#!/usr/bin/python\nimport os, sys, MySQLdb\n\ntry:\n\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\tdomain = sys.argv[1].strip()\n\tcursor = connection.cursor()\n\tscanId = sys.argv[2]\n\n\tif not os.path.exists(\"/tmp/recon_domain_files\"):\n\t\tos.makedirs(\"/tmp/recon_domain_files\")\n\n\tif not os.path.exists(\"/tmp/recon_domain_files/\"+domain+\"/\"):\n\t    os.makedirs(\"/tmp/recon_domain_files/\"+domain+\"/\")\n\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../../dependencies/sublister/sublist3r.py -o /tmp/recon_domain_files/\"+domain+\"/domains-all.txt -d \"+domain)\n\n\tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n\tdatabase_data = cursor.fetchall()\n\tdatabase_domains = [d[0] for d in database_data]\n\n        non_active_subdomains = [x[0] for x in database_data if ord(x[2]) == False]\n        program = [x[3] for x in database_data if x[0] == domain][0]\n        topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n\n\tdomains_all = open(\"/tmp/recon_domain_files/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n\tdomains_all.extend(x for x in database_domains if x not in domains_all)\n\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../../tools/online.py /tmp/recon_domain_files/\"+domain+\"/domains-all.txt /tmp/recon_domain_files/\"+domain+\"/domains-online.txt\")\n\n\tdomains_online = open(\"/tmp/recon_domain_files/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n\n\tfor sub_domain in domains_all:\n\t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n\t\tif sub_domain in domains_online:\n\t\t\tactive=True\n\t\t\tif sub_domain in non_active_subdomains:\n\t\t\t\tinsertScanId = scanId\n\t\telse:\n\t\t\tactive=False\n\n\t\tif sub_domain:\n\t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))\n\t\t\tconnection.commit()\n\n\n\tcursor.close ()\n\tconnection.close ()\nexcept Exception as e:\n\tprint \"error in sublister_to_db.py with main domain; \" + domain\n\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in sublister_to_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n\tconnection.commit()\n\tcursor.close()\n\tconnection.close()\n\tprint e\nsys.exit()\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": 45, "complexity": 0, "token_count": 498}, {"old_path": "database/db_test.py", "new_path": "database/db_test.py", "filename": "db_test.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -6,12 +6,39 @@ import sys\n connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n \n cursor = connection.cursor ()\n-cursor.execute (\"select Domain ,Active, Program, InScope from domains limit 5\")\n-data = cursor.fetchall ()\n+cursor.execute (\"\"\"\n+        SELECT COUNT(*)\n+        FROM information_schema.tables\n+        WHERE table_name = '{0}'\n+        \"\"\".format(\"domains\"))\n \n-for row in data :\n-\tprint \"\\n --- \\n\"\n-\tprint \"domain: \" + row[0] + \"\\n\" + \"active: \" + str(ord(row[1])) + \"\\n\" + \"program: \" + row[2] + \"\\n\" + \"scope: \" + str(ord(row[1]))\n+if cursor.fetchone()[0] == 1:\n+        print \"[+] Table domains found\"\n+else:\n+\tprint \"[-] Hmm... No table 'domains' was found in the database recon. Did you run the initialize script?\"\n+\n+\n+cursor.execute (\"\"\"\n+        SELECT COUNT(*)\n+        FROM information_schema.tables\n+        WHERE table_name = '{0}'\n+        \"\"\".format(\"errors\"))\n+\n+if cursor.fetchone()[0] == 1:\n+        print \"[+] Table errors found\"\n+else:\n+        print \"[-] Hmm... No table 'errors' was found in the database recon. Did you run the initialize script?\"\n+\n+cursor.execute (\"\"\"\n+        SELECT COUNT(*)\n+        FROM information_schema.tables\n+        WHERE table_name = '{0}'\n+        \"\"\".format(\"scans\"))\n+\n+if cursor.fetchone()[0] == 1:\n+        print \"[+] Table scans found\"\n+else:\n+        print \"[-] Hmm... No table 'scans' was found in the database recon. Did you run the initialize script?\"\n \n \n cursor.close ()\n", "diff_parsed": {"added": [[9, "cursor.execute (\"\"\""], [10, "        SELECT COUNT(*)"], [11, "        FROM information_schema.tables"], [12, "        WHERE table_name = '{0}'"], [13, "        \"\"\".format(\"domains\"))"], [15, "if cursor.fetchone()[0] == 1:"], [16, "        print \"[+] Table domains found\""], [17, "else:"], [18, "\tprint \"[-] Hmm... No table 'domains' was found in the database recon. Did you run the initialize script?\""], [19, ""], [20, ""], [21, "cursor.execute (\"\"\""], [22, "        SELECT COUNT(*)"], [23, "        FROM information_schema.tables"], [24, "        WHERE table_name = '{0}'"], [25, "        \"\"\".format(\"errors\"))"], [26, ""], [27, "if cursor.fetchone()[0] == 1:"], [28, "        print \"[+] Table errors found\""], [29, "else:"], [30, "        print \"[-] Hmm... No table 'errors' was found in the database recon. Did you run the initialize script?\""], [31, ""], [32, "cursor.execute (\"\"\""], [33, "        SELECT COUNT(*)"], [34, "        FROM information_schema.tables"], [35, "        WHERE table_name = '{0}'"], [36, "        \"\"\".format(\"scans\"))"], [37, ""], [38, "if cursor.fetchone()[0] == 1:"], [39, "        print \"[+] Table scans found\""], [40, "else:"], [41, "        print \"[-] Hmm... No table 'scans' was found in the database recon. Did you run the initialize script?\""]], "deleted": [[9, "cursor.execute (\"select Domain ,Active, Program, InScope from domains limit 5\")"], [10, "data = cursor.fetchall ()"], [12, "for row in data :"], [13, "\tprint \"\\n --- \\n\""], [14, "\tprint \"domain: \" + row[0] + \"\\n\" + \"active: \" + str(ord(row[1])) + \"\\n\" + \"program: \" + row[2] + \"\\n\" + \"scope: \" + str(ord(row[1]))"]]}, "added_lines": 32, "deleted_lines": 5, "source_code": "#!/usr/bin/python\n\nimport MySQLdb\nimport sys\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\ncursor = connection.cursor ()\ncursor.execute (\"\"\"\n        SELECT COUNT(*)\n        FROM information_schema.tables\n        WHERE table_name = '{0}'\n        \"\"\".format(\"domains\"))\n\nif cursor.fetchone()[0] == 1:\n        print \"[+] Table domains found\"\nelse:\n\tprint \"[-] Hmm... No table 'domains' was found in the database recon. Did you run the initialize script?\"\n\n\ncursor.execute (\"\"\"\n        SELECT COUNT(*)\n        FROM information_schema.tables\n        WHERE table_name = '{0}'\n        \"\"\".format(\"errors\"))\n\nif cursor.fetchone()[0] == 1:\n        print \"[+] Table errors found\"\nelse:\n        print \"[-] Hmm... No table 'errors' was found in the database recon. Did you run the initialize script?\"\n\ncursor.execute (\"\"\"\n        SELECT COUNT(*)\n        FROM information_schema.tables\n        WHERE table_name = '{0}'\n        \"\"\".format(\"scans\"))\n\nif cursor.fetchone()[0] == 1:\n        print \"[+] Table scans found\"\nelse:\n        print \"[-] Hmm... No table 'scans' was found in the database recon. Did you run the initialize script?\"\n\n\ncursor.close ()\nconnection.close ()\nsys.exit()\n\n", "source_code_before": "#!/usr/bin/python\n\nimport MySQLdb\nimport sys\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\ncursor = connection.cursor ()\ncursor.execute (\"select Domain ,Active, Program, InScope from domains limit 5\")\ndata = cursor.fetchall ()\n\nfor row in data :\n\tprint \"\\n --- \\n\"\n\tprint \"domain: \" + row[0] + \"\\n\" + \"active: \" + str(ord(row[1])) + \"\\n\" + \"program: \" + row[2] + \"\\n\" + \"scope: \" + str(ord(row[1]))\n\n\ncursor.close ()\nconnection.close ()\nsys.exit()\n\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": 34, "complexity": 0, "token_count": 135}, {"old_path": "database/init_db.py", "new_path": "database/init_db.py", "filename": "init_db.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -3,10 +3,20 @@\n import MySQLdb\n import sys\n \n-connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+username = \"rjp\"\n+password = \"1484\"\n+\n+connection = MySQLdb.connect (host = \"localhost\", user = username, passwd = password)\n \n cursor = connection.cursor ()\n \n+cursor.execute (\"\"\"\n+CREATE DATABASE recon;\n+\"\"\")\n+\n+connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+cursor = connection.cursor ()\n+\n cursor.execute (\"\"\"\n CREATE TABLE domains\n (\n@@ -17,55 +27,13 @@ CREATE TABLE domains\n     InScope bit NOT NULL DEFAULT 0,\n     Domain varchar(100) not null,\n     LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n+    scan_Id int,\n     PRIMARY KEY (DomainID),\n     FOREIGN KEY (TopDomainID) REFERENCES domains(DomainID),\n     UNIQUE (Domain)\n );\n \"\"\")\n \n-cursor.execute (\"\"\"\n-CREATE TABLE directories\n-(\n-    DirectoryID int NOT NULL AUTO_INCREMENT,\n-    DomainID int NOT NULL,\n-    Directory varchar(255) not null,\n-    File bit NOT NULL DEFAULT 0,\n-    Active bit NOT NULL DEFAULT 0,\n-    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n-    PRIMARY KEY (DirectoryID),\n-    FOREIGN KEY (DomainID) REFERENCES domains(DomainID)\n-);\n-\"\"\")\n-\n-cursor.execute (\"\"\"\n-CREATE TABLE crlf\n-(\n-    CRLFID int NOT NULL AUTO_INCREMENT,\n-    DomainID int NOT NULL,\n-    Payload varchar(255) not null,\n-    Active bit NOT NULL DEFAULT 0,\n-    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n-    PRIMARY KEY (CRLFID),\n-    FOREIGN KEY (DomainID) REFERENCES domains(DomainID)\n-);\n-\n-\"\"\")\n-\n-cursor.execute (\"\"\"\n-CREATE TABLE ports\n-(\n-    PortID int NOT NULL AUTO_INCREMENT,\n-    DomainID int NOT NULL,\n-    Port int NOT NULL,\n-    PortInfo varchar(255),\n-    Active bit NOT NULL DEFAULT 0,\n-    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n-    PRIMARY KEY (PortID),\n-    FOREIGN KEY (DomainID) REFERENCES domains(DomainID)\n-);\n-\n-\"\"\")\n-\n cursor.execute (\"\"\"\n CREATE TABLE errors\n (\n@@ -75,12 +43,22 @@ CREATE TABLE errors\n     Error varchar(255),\n     Script varchar(255),\n     ErrorDate timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n+    scan_ID int,\n     PRIMARY KEY (ErrorID)\n );\n-\n \"\"\")\n \n \n+cursor.execute (\"\"\"\n+CREATE TABLE scans \n+( \n+\tScanID int NOT NULL AUTO_INCREMENT, \n+\tStartDate datetime NOT NULL, \n+\tEndDate datetime, \n+\tprimary key (ScanID) \n+);\n+\"\"\")\n+\n cursor.close ()\n connection.close ()\n sys.exit()\n", "diff_parsed": {"added": [[6, "username = \"rjp\""], [7, "password = \"1484\""], [8, ""], [9, "connection = MySQLdb.connect (host = \"localhost\", user = username, passwd = password)"], [13, "cursor.execute (\"\"\""], [14, "CREATE DATABASE recon;"], [15, "\"\"\")"], [16, ""], [17, "connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [18, "cursor = connection.cursor ()"], [19, ""], [30, "    scan_Id int,"], [46, "    scan_ID int,"], [52, "cursor.execute (\"\"\""], [53, "CREATE TABLE scans"], [54, "("], [55, "\tScanID int NOT NULL AUTO_INCREMENT,"], [56, "\tStartDate datetime NOT NULL,"], [57, "\tEndDate datetime,"], [58, "\tprimary key (ScanID)"], [59, ");"], [60, "\"\"\")"], [61, ""]], "deleted": [[6, "connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [26, "cursor.execute (\"\"\""], [27, "CREATE TABLE directories"], [28, "("], [29, "    DirectoryID int NOT NULL AUTO_INCREMENT,"], [30, "    DomainID int NOT NULL,"], [31, "    Directory varchar(255) not null,"], [32, "    File bit NOT NULL DEFAULT 0,"], [33, "    Active bit NOT NULL DEFAULT 0,"], [34, "    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,"], [35, "    PRIMARY KEY (DirectoryID),"], [36, "    FOREIGN KEY (DomainID) REFERENCES domains(DomainID)"], [37, ");"], [38, "\"\"\")"], [39, ""], [40, "cursor.execute (\"\"\""], [41, "CREATE TABLE crlf"], [42, "("], [43, "    CRLFID int NOT NULL AUTO_INCREMENT,"], [44, "    DomainID int NOT NULL,"], [45, "    Payload varchar(255) not null,"], [46, "    Active bit NOT NULL DEFAULT 0,"], [47, "    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,"], [48, "    PRIMARY KEY (CRLFID),"], [49, "    FOREIGN KEY (DomainID) REFERENCES domains(DomainID)"], [50, ");"], [51, ""], [52, "\"\"\")"], [53, ""], [54, "cursor.execute (\"\"\""], [55, "CREATE TABLE ports"], [56, "("], [57, "    PortID int NOT NULL AUTO_INCREMENT,"], [58, "    DomainID int NOT NULL,"], [59, "    Port int NOT NULL,"], [60, "    PortInfo varchar(255),"], [61, "    Active bit NOT NULL DEFAULT 0,"], [62, "    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,"], [63, "    PRIMARY KEY (PortID),"], [64, "    FOREIGN KEY (DomainID) REFERENCES domains(DomainID)"], [65, ");"], [66, ""], [67, "\"\"\")"], [68, ""], [80, ""]]}, "added_lines": 23, "deleted_lines": 45, "source_code": "#!/usr/bin/python\n\nimport MySQLdb\nimport sys\n\nusername = \"rjp\"\npassword = \"1484\"\n\nconnection = MySQLdb.connect (host = \"localhost\", user = username, passwd = password)\n\ncursor = connection.cursor ()\n\ncursor.execute (\"\"\"\nCREATE DATABASE recon;\n\"\"\")\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\ncursor = connection.cursor ()\n\ncursor.execute (\"\"\"\nCREATE TABLE domains\n(\n    DomainID int NOT NULL AUTO_INCREMENT,\n    Program varchar(255) not null,\n    TopDomainID int default null,\n    Active bit NOT NULL DEFAULT 0,\n    InScope bit NOT NULL DEFAULT 0,\n    Domain varchar(100) not null,\n    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n    scan_Id int,\n    PRIMARY KEY (DomainID),\n    FOREIGN KEY (TopDomainID) REFERENCES domains(DomainID),\n    UNIQUE (Domain)\n);\n\"\"\")\n\ncursor.execute (\"\"\"\nCREATE TABLE errors\n(\n    ErrorID int NOT NULL AUTO_INCREMENT,\n    Domain varchar(255),\n    ErrorDescription varchar(255),\n    Error varchar(255),\n    Script varchar(255),\n    ErrorDate timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n    scan_ID int,\n    PRIMARY KEY (ErrorID)\n);\n\"\"\")\n\n\ncursor.execute (\"\"\"\nCREATE TABLE scans \n( \n\tScanID int NOT NULL AUTO_INCREMENT, \n\tStartDate datetime NOT NULL, \n\tEndDate datetime, \n\tprimary key (ScanID) \n);\n\"\"\")\n\ncursor.close ()\nconnection.close ()\nsys.exit()\n", "source_code_before": "#!/usr/bin/python\n\nimport MySQLdb\nimport sys\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\ncursor = connection.cursor ()\n\ncursor.execute (\"\"\"\nCREATE TABLE domains\n(\n    DomainID int NOT NULL AUTO_INCREMENT,\n    Program varchar(255) not null,\n    TopDomainID int default null,\n    Active bit NOT NULL DEFAULT 0,\n    InScope bit NOT NULL DEFAULT 0,\n    Domain varchar(100) not null,\n    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n    PRIMARY KEY (DomainID),\n    FOREIGN KEY (TopDomainID) REFERENCES domains(DomainID),\n    UNIQUE (Domain)\n);\n\"\"\")\n\ncursor.execute (\"\"\"\nCREATE TABLE directories\n(\n    DirectoryID int NOT NULL AUTO_INCREMENT,\n    DomainID int NOT NULL,\n    Directory varchar(255) not null,\n    File bit NOT NULL DEFAULT 0,\n    Active bit NOT NULL DEFAULT 0,\n    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n    PRIMARY KEY (DirectoryID),\n    FOREIGN KEY (DomainID) REFERENCES domains(DomainID)\n);\n\"\"\")\n\ncursor.execute (\"\"\"\nCREATE TABLE crlf\n(\n    CRLFID int NOT NULL AUTO_INCREMENT,\n    DomainID int NOT NULL,\n    Payload varchar(255) not null,\n    Active bit NOT NULL DEFAULT 0,\n    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n    PRIMARY KEY (CRLFID),\n    FOREIGN KEY (DomainID) REFERENCES domains(DomainID)\n);\n\n\"\"\")\n\ncursor.execute (\"\"\"\nCREATE TABLE ports\n(\n    PortID int NOT NULL AUTO_INCREMENT,\n    DomainID int NOT NULL,\n    Port int NOT NULL,\n    PortInfo varchar(255),\n    Active bit NOT NULL DEFAULT 0,\n    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n    PRIMARY KEY (PortID),\n    FOREIGN KEY (DomainID) REFERENCES domains(DomainID)\n);\n\n\"\"\")\n\ncursor.execute (\"\"\"\nCREATE TABLE errors\n(\n    ErrorID int NOT NULL AUTO_INCREMENT,\n    Domain varchar(255),\n    ErrorDescription varchar(255),\n    Error varchar(255),\n    Script varchar(255),\n    ErrorDate timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n    PRIMARY KEY (ErrorID)\n);\n\n\"\"\")\n\n\ncursor.close ()\nconnection.close ()\nsys.exit()\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": 52, "complexity": 0, "token_count": 103}, {"old_path": "install.sh", "new_path": "install.sh", "filename": "install.sh", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -1 +1,20 @@\n-temp\n+ #!/usr/bin/env bash\n+\n+# Install sublis3r\n+#git clone https://github.com/aboul3la/Sublist3r.git tools/dependencies/sublister\n+\n+#echo \"- Creating database 'recon' with tables 'domains' and 'errors' -\"\n+#python database/init_db.py\n+\n+#echo \"- Checking if the database was created successfully -\"\n+#python database/db_test.py\n+\n+echo \"- Adding a cron task to run 'run.py' every 12 hours. You can edit this with the command 'crontab -e' -\"\n+echo \"Check?: Adding the path to crontab. If this isn't the right path to the file, please edit this with the command 'crontab -e'\"\n+#write out current crontab\n+crontab -l > mycron\n+#echo new cron into cron file\n+echo \"0 */12 * * * python $(pwd)/run.py\" >> mycron\n+#install new cron file\n+crontab mycron\n+rm mycron\n", "diff_parsed": {"added": [[1, " #!/usr/bin/env bash"], [2, ""], [3, "# Install sublis3r"], [4, "#git clone https://github.com/aboul3la/Sublist3r.git tools/dependencies/sublister"], [5, ""], [6, "#echo \"- Creating database 'recon' with tables 'domains' and 'errors' -\""], [7, "#python database/init_db.py"], [8, ""], [9, "#echo \"- Checking if the database was created successfully -\""], [10, "#python database/db_test.py"], [11, ""], [12, "echo \"- Adding a cron task to run 'run.py' every 12 hours. You can edit this with the command 'crontab -e' -\""], [13, "echo \"Check?: Adding the path to crontab. If this isn't the right path to the file, please edit this with the command 'crontab -e'\""], [14, "#write out current crontab"], [15, "crontab -l > mycron"], [16, "#echo new cron into cron file"], [17, "echo \"0 */12 * * * python $(pwd)/run.py\" >> mycron"], [18, "#install new cron file"], [19, "crontab mycron"], [20, "rm mycron"]], "deleted": [[1, "temp"]]}, "added_lines": 20, "deleted_lines": 1, "source_code": " #!/usr/bin/env bash\n\n# Install sublis3r\n#git clone https://github.com/aboul3la/Sublist3r.git tools/dependencies/sublister\n\n#echo \"- Creating database 'recon' with tables 'domains' and 'errors' -\"\n#python database/init_db.py\n\n#echo \"- Checking if the database was created successfully -\"\n#python database/db_test.py\n\necho \"- Adding a cron task to run 'run.py' every 12 hours. You can edit this with the command 'crontab -e' -\"\necho \"Check?: Adding the path to crontab. If this isn't the right path to the file, please edit this with the command 'crontab -e'\"\n#write out current crontab\ncrontab -l > mycron\n#echo new cron into cron file\necho \"0 */12 * * * python $(pwd)/run.py\" >> mycron\n#install new cron file\ncrontab mycron\nrm mycron\n", "source_code_before": "temp\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}, {"old_path": "main.py", "new_path": "main.py", "filename": "main.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -40,6 +40,26 @@ def run_subdomain_scan_on_target(top_domain_par = None):\n \n \tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__)) + \"/database/additional_tools/sublister_to_db.py \" + top_domain + \" NULL\")\n \n+def delete_top_domain():\n+\tprint \"What is the domain? \"\n+\ttop_domain = raw_input('[Domain] > ')\n+\n+        cursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n+        data = cursor.fetchone()\n+\n+\ttop_domain = int(data[0])\n+\n+        cursor.execute(\"delete from domains where topDomainID = %s\", (top_domain,))\n+        connection.commit()\n+\n+        cursor.execute(\"delete from domains where DomainID = %s\", (top_domain,))\n+        connection.commit()\n+\n+        print bcolors.OKGREEN + \"Domain with its subdomains deleted\" + bcolors.ENDC\n+        raw_input(\"\\nPress any key to go back...\")\n+        start()\n+\n+\n def insert_topdomain(top_domain_par = None):\n \tif top_domain_par is None:\n \t\tprint \"What is the domain? \"\n@@ -150,11 +170,14 @@ def list_domains():\n \tstart()\n \n \n+\n+\n options = {1 : insert_topdomain,\n            2 : list_subdomains,\n            3 : list_domains,\n            4 : insert_subdomain,\n-\t   5 : run_subdomain_scan_on_target\n+\t   5 : run_subdomain_scan_on_target,\n+\t   6 : delete_top_domain\n }\n \n \n@@ -182,6 +205,7 @@ def start():\n 3. List all (top)domains\n 4. Add subdomain\n 5. Run subdomain scan on top domain\n+6. Delete a (top)domain\n \"\"\"\n \n \tprint banner.format(bcolors.HEADER, domains, sub_domains, top_domains, bcolors.ENDC)\n", "diff_parsed": {"added": [[43, "def delete_top_domain():"], [44, "\tprint \"What is the domain? \""], [45, "\ttop_domain = raw_input('[Domain] > ')"], [46, ""], [47, "        cursor.execute (\"select * from domains where Domain = %s\", (top_domain,))"], [48, "        data = cursor.fetchone()"], [49, ""], [50, "\ttop_domain = int(data[0])"], [51, ""], [52, "        cursor.execute(\"delete from domains where topDomainID = %s\", (top_domain,))"], [53, "        connection.commit()"], [54, ""], [55, "        cursor.execute(\"delete from domains where DomainID = %s\", (top_domain,))"], [56, "        connection.commit()"], [57, ""], [58, "        print bcolors.OKGREEN + \"Domain with its subdomains deleted\" + bcolors.ENDC"], [59, "        raw_input(\"\\nPress any key to go back...\")"], [60, "        start()"], [61, ""], [62, ""], [173, ""], [174, ""], [179, "\t   5 : run_subdomain_scan_on_target,"], [180, "\t   6 : delete_top_domain"], [208, "6. Delete a (top)domain"]], "deleted": [[157, "\t   5 : run_subdomain_scan_on_target"]]}, "added_lines": 25, "deleted_lines": 1, "source_code": "#!/usr/bin/python\n\nimport os, sys, MySQLdb, time\n\nclass bcolors:\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\ncursor = connection.cursor()\n\n\ndef list_subdomains():\n\tsub_domain = raw_input('[Domain] > ')\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (sub_domain,))\n\tdata = cursor.fetchall()\n\n\tfor row in data:\n\t\tif ord(row[1]):\n\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n\t\telse:\n\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\ndef run_subdomain_scan_on_target(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the domain?\"\n\t\ttop_domain = raw_input('[Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__)) + \"/database/additional_tools/sublister_to_db.py \" + top_domain + \" NULL\")\n\ndef delete_top_domain():\n\tprint \"What is the domain? \"\n\ttop_domain = raw_input('[Domain] > ')\n\n        cursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n        data = cursor.fetchone()\n\n\ttop_domain = int(data[0])\n\n        cursor.execute(\"delete from domains where topDomainID = %s\", (top_domain,))\n        connection.commit()\n\n        cursor.execute(\"delete from domains where DomainID = %s\", (top_domain,))\n        connection.commit()\n\n        print bcolors.OKGREEN + \"Domain with its subdomains deleted\" + bcolors.ENDC\n        raw_input(\"\\nPress any key to go back...\")\n        start()\n\n\ndef insert_topdomain(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the domain? \"\n\t\ttop_domain = raw_input('[Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n\tdata = cursor.fetchone()  \n\n\tif data:\n    \t\tprint bcolors.WARNING + \"Domains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n\t\traw_input(\"Press any key to go back...\")\n\t\tstart()\n\t\n\n\tprint \"What is the program? \"\n\tprogram = raw_input('[program] > ')\n\n\tprint \"Inscope? \"\n\tinscope = raw_input('[Inscope] > ')\n\tif \"no\" not in inscope.lower():\n\t\tinscope = 1\n\telse:\n\t\tinscope = 0\n\t\n\n\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active) VALUES (%s, %s, %s, %s)\", (program, inscope, top_domain, 1))\n\tconnection.commit()\n\t\n\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\ndef insert_subdomain(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the (top)domain? \"\n\t\ttop_domain = raw_input('[(Top)Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n\tdata = cursor.fetchone()  \n\n\tif not data:\n    \t\tprint bcolors.WARNING + \"Domain not found!\" + bcolors.ENDC\n\t\tprint \"Do you want to add it? \"\n\t\tanswer = raw_input('[yes/no] > ')\n\t\tif \"no\" not in answer.lower():\n\t\t\tinsert_topdomain(top_domain)\n\t\telse:\n\t\t\traw_input(\"Press any key to go back...\")\n\t\t\tstart()\n\n\tprogram = str(data[1])\n\ttopdomainid = int(data[0])\n\n\n\n\tprint \"What is the subdomain? \"\n\tsub_domain = raw_input('[(Subdomain] > ')\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (sub_domain,))\n\tdata = cursor.fetchone()  \n\n\tif data:\n    \t\tprint bcolors.WARNING + \"Subdomains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n\t\tdoes_not_exist = False\n\telse:\n\t\tdoes_not_exist = True\n\n\tif does_not_exist:\n\t\tprint \"Inscope? \"\n\t\tinscope = raw_input('[Inscope] > ')\n\t\tif \"no\" not in inscope.lower():\n\t\t\tinscope = 1\n\t\telse:\n\t\t\tinscope = 0\n\n\t\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active, TopDomainID) VALUES (%s, %s, %s, %s, %s)\", (program, inscope, sub_domain, 1, topdomainid))\n\t\tconnection.commit()\n\t\t\n\t\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n\n\tprint \"Do you want to add another one?? \"\n\tanother_one = raw_input('[yes/no] > ')\n\tif \"no\" not in another_one.lower():\n\n\t\tinsert_subdomain(top_domain)\n\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\n\ndef list_domains():\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID is NULL\")\n\tdata = cursor.fetchall()\n\n\tfor row in data:\n\t\tif ord(row[1]):\n\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n\t\telse:\n\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n\t\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\n\n\noptions = {1 : insert_topdomain,\n           2 : list_subdomains,\n           3 : list_domains,\n           4 : insert_subdomain,\n\t   5 : run_subdomain_scan_on_target,\n\t   6 : delete_top_domain\n}\n\n\ndef start():\n\tos.system('clear')\n\tcursor.execute (\"select count(*) from domains where TopDomainID is NULL;\")\n\tdata = cursor.fetchall()\n\tsub_domains = data[0][0]\n\n\tcursor.execute (\"select count(TopDomainID) from domains\")\n\tdata = cursor.fetchall()\n\ttop_domains = data[0][0]\n\n\tdomains = top_domains + sub_domains\n\n\tbanner = \"\"\" {0}---------------+-------\n Domains       | {1}   \n Top-domains   | {2}  \n Sudomains     | {3}   \n---------------+-------{4}\"\"\"\n\n\tchoices = \"\"\"\n1. Add domain\n2. List subdomains from domain\n3. List all (top)domains\n4. Add subdomain\n5. Run subdomain scan on top domain\n6. Delete a (top)domain\n\"\"\"\n\n\tprint banner.format(bcolors.HEADER, domains, sub_domains, top_domains, bcolors.ENDC)\n\n\tprint choices.format()\n\n\ttry:\n\t\tnum = raw_input('> ')\n\t\tnum = int(num)\n\texcept:\n\t\tprint \"Provide a number please,\"\n\t\traw_input(\"\\nPress any key to go back...\")\n\t\tstart()\n\t\tstart()\n\n\toptions[num]()\n\n\nstart()\ncursor.close ()\nconnection.close ()\nsys.exit()\n", "source_code_before": "#!/usr/bin/python\n\nimport os, sys, MySQLdb, time\n\nclass bcolors:\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\ncursor = connection.cursor()\n\n\ndef list_subdomains():\n\tsub_domain = raw_input('[Domain] > ')\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (sub_domain,))\n\tdata = cursor.fetchall()\n\n\tfor row in data:\n\t\tif ord(row[1]):\n\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n\t\telse:\n\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\ndef run_subdomain_scan_on_target(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the domain?\"\n\t\ttop_domain = raw_input('[Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__)) + \"/database/additional_tools/sublister_to_db.py \" + top_domain + \" NULL\")\n\ndef insert_topdomain(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the domain? \"\n\t\ttop_domain = raw_input('[Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n\tdata = cursor.fetchone()  \n\n\tif data:\n    \t\tprint bcolors.WARNING + \"Domains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n\t\traw_input(\"Press any key to go back...\")\n\t\tstart()\n\t\n\n\tprint \"What is the program? \"\n\tprogram = raw_input('[program] > ')\n\n\tprint \"Inscope? \"\n\tinscope = raw_input('[Inscope] > ')\n\tif \"no\" not in inscope.lower():\n\t\tinscope = 1\n\telse:\n\t\tinscope = 0\n\t\n\n\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active) VALUES (%s, %s, %s, %s)\", (program, inscope, top_domain, 1))\n\tconnection.commit()\n\t\n\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\ndef insert_subdomain(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the (top)domain? \"\n\t\ttop_domain = raw_input('[(Top)Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n\tdata = cursor.fetchone()  \n\n\tif not data:\n    \t\tprint bcolors.WARNING + \"Domain not found!\" + bcolors.ENDC\n\t\tprint \"Do you want to add it? \"\n\t\tanswer = raw_input('[yes/no] > ')\n\t\tif \"no\" not in answer.lower():\n\t\t\tinsert_topdomain(top_domain)\n\t\telse:\n\t\t\traw_input(\"Press any key to go back...\")\n\t\t\tstart()\n\n\tprogram = str(data[1])\n\ttopdomainid = int(data[0])\n\n\n\n\tprint \"What is the subdomain? \"\n\tsub_domain = raw_input('[(Subdomain] > ')\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (sub_domain,))\n\tdata = cursor.fetchone()  \n\n\tif data:\n    \t\tprint bcolors.WARNING + \"Subdomains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n\t\tdoes_not_exist = False\n\telse:\n\t\tdoes_not_exist = True\n\n\tif does_not_exist:\n\t\tprint \"Inscope? \"\n\t\tinscope = raw_input('[Inscope] > ')\n\t\tif \"no\" not in inscope.lower():\n\t\t\tinscope = 1\n\t\telse:\n\t\t\tinscope = 0\n\n\t\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active, TopDomainID) VALUES (%s, %s, %s, %s, %s)\", (program, inscope, sub_domain, 1, topdomainid))\n\t\tconnection.commit()\n\t\t\n\t\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n\n\tprint \"Do you want to add another one?? \"\n\tanother_one = raw_input('[yes/no] > ')\n\tif \"no\" not in another_one.lower():\n\n\t\tinsert_subdomain(top_domain)\n\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\n\ndef list_domains():\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID is NULL\")\n\tdata = cursor.fetchall()\n\n\tfor row in data:\n\t\tif ord(row[1]):\n\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n\t\telse:\n\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n\t\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\noptions = {1 : insert_topdomain,\n           2 : list_subdomains,\n           3 : list_domains,\n           4 : insert_subdomain,\n\t   5 : run_subdomain_scan_on_target\n}\n\n\ndef start():\n\tos.system('clear')\n\tcursor.execute (\"select count(*) from domains where TopDomainID is NULL;\")\n\tdata = cursor.fetchall()\n\tsub_domains = data[0][0]\n\n\tcursor.execute (\"select count(TopDomainID) from domains\")\n\tdata = cursor.fetchall()\n\ttop_domains = data[0][0]\n\n\tdomains = top_domains + sub_domains\n\n\tbanner = \"\"\" {0}---------------+-------\n Domains       | {1}   \n Top-domains   | {2}  \n Sudomains     | {3}   \n---------------+-------{4}\"\"\"\n\n\tchoices = \"\"\"\n1. Add domain\n2. List subdomains from domain\n3. List all (top)domains\n4. Add subdomain\n5. Run subdomain scan on top domain\n\"\"\"\n\n\tprint banner.format(bcolors.HEADER, domains, sub_domains, top_domains, bcolors.ENDC)\n\n\tprint choices.format()\n\n\ttry:\n\t\tnum = raw_input('> ')\n\t\tnum = int(num)\n\texcept:\n\t\tprint \"Provide a number please,\"\n\t\traw_input(\"\\nPress any key to go back...\")\n\t\tstart()\n\t\tstart()\n\n\toptions[num]()\n\n\nstart()\ncursor.close ()\nconnection.close ()\nsys.exit()\n", "methods": [{"name": "list_subdomains", "start_line": 19, "end_line": 31}, {"name": "run_subdomain_scan_on_target", "start_line": 34, "end_line": 41}, {"name": "delete_top_domain", "start_line": 43, "end_line": 60}, {"name": "insert_topdomain", "start_line": 63, "end_line": 95}, {"name": "insert_subdomain", "start_line": 98, "end_line": 155}, {"name": "list_domains", "start_line": 159, "end_line": 170}, {"name": "start", "start_line": 184, "end_line": 224}], "methods_before": [{"name": "list_subdomains", "start_line": 19, "end_line": 31}, {"name": "run_subdomain_scan_on_target", "start_line": 34, "end_line": 41}, {"name": "insert_topdomain", "start_line": 43, "end_line": 75}, {"name": "insert_subdomain", "start_line": 78, "end_line": 135}, {"name": "list_domains", "start_line": 139, "end_line": 150}, {"name": "start", "start_line": 161, "end_line": 200}], "changed_methods": [{"name": "delete_top_domain", "start_line": 43, "end_line": 60}, {"name": "start", "start_line": 184, "end_line": 224}], "nloc": 166, "complexity": 23, "token_count": 939}, {"old_path": "run.py", "new_path": "run.py", "filename": "run.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -1,25 +1,29 @@\n #!/usr/bin/python\n-import sys, os, MySQLdb, datetime\n+try:\n+\timport sys, os, MySQLdb, datetime\n \n-connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n-cursor = connection.cursor ()\n+\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+\tcursor = connection.cursor ()\n \n-cursor.execute (\"insert into scans (StartDate) values (CURRENT_TIMESTAMP)\")\n-connection.commit()\n-scanId = cursor.lastrowid\n+\tcursor.execute (\"insert into scans (StartDate) values (CURRENT_TIMESTAMP)\")\n+\tconnection.commit()\n+\tscanId = cursor.lastrowid\n+\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\n+\tdata = cursor.fetchall ()\n+\tconnection.close()\n \n-cursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\n-data = cursor.fetchall ()\n-connection.close()\n+\tfor row in data:\n+\t\tprint \"Running sublister on \" + row[0]\n+\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/database/additional_tools/sublister_to_db.py \" + row[0] + \" \" + str(scanId))\n \n-for row in data:\n-\tprint \"Running sublister on \" + row[0]\n-\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/database/additional_tools/sublister_to_db.py \" + row[0] + \" \" + str(scanId))\n+\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+\tcursor = connection.cursor ()\n+\tcursor.execute (\"update scans set EndDate = CURRENT_TIMESTAMP where ScanID = %s\", (scanId))\n+\tconnection.commit()\n+\tconnection.close()\n \n-connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n-cursor = connection.cursor ()\n-cursor.execute (\"update scans set EndDate = CURRENT_TIMESTAMP where ScanID = %s\", (scanId))\n-connection.commit()\n-connection.close()\n-\n-os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/telegram/notify.py \" + str(scanId))\n+\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/telegram/notify.py \" + str(scanId))\n+except Exception, e:\n+\tprint \"error: \" + str(e)\n+\twith open(os.path.dirname(os.path.abspath(__file__))  + '/logs/run_logs.txt', 'w+') as the_file:\n+\t\tthe_file.write(str(e) + \"\\n\")\n", "diff_parsed": {"added": [[2, "try:"], [3, "\timport sys, os, MySQLdb, datetime"], [5, "\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [6, "\tcursor = connection.cursor ()"], [8, "\tcursor.execute (\"insert into scans (StartDate) values (CURRENT_TIMESTAMP)\")"], [9, "\tconnection.commit()"], [10, "\tscanId = cursor.lastrowid"], [11, "\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")"], [12, "\tdata = cursor.fetchall ()"], [13, "\tconnection.close()"], [15, "\tfor row in data:"], [16, "\t\tprint \"Running sublister on \" + row[0]"], [17, "\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/database/additional_tools/sublister_to_db.py \" + row[0] + \" \" + str(scanId))"], [19, "\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [20, "\tcursor = connection.cursor ()"], [21, "\tcursor.execute (\"update scans set EndDate = CURRENT_TIMESTAMP where ScanID = %s\", (scanId))"], [22, "\tconnection.commit()"], [23, "\tconnection.close()"], [25, "\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/telegram/notify.py \" + str(scanId))"], [26, "except Exception, e:"], [27, "\tprint \"error: \" + str(e)"], [28, "\twith open(os.path.dirname(os.path.abspath(__file__))  + '/logs/run_logs.txt', 'w+') as the_file:"], [29, "\t\tthe_file.write(str(e) + \"\\n\")"]], "deleted": [[2, "import sys, os, MySQLdb, datetime"], [4, "connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [5, "cursor = connection.cursor ()"], [7, "cursor.execute (\"insert into scans (StartDate) values (CURRENT_TIMESTAMP)\")"], [8, "connection.commit()"], [9, "scanId = cursor.lastrowid"], [11, "cursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")"], [12, "data = cursor.fetchall ()"], [13, "connection.close()"], [15, "for row in data:"], [16, "\tprint \"Running sublister on \" + row[0]"], [17, "\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/database/additional_tools/sublister_to_db.py \" + row[0] + \" \" + str(scanId))"], [19, "connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [20, "cursor = connection.cursor ()"], [21, "cursor.execute (\"update scans set EndDate = CURRENT_TIMESTAMP where ScanID = %s\", (scanId))"], [22, "connection.commit()"], [23, "connection.close()"], [24, ""], [25, "os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/telegram/notify.py \" + str(scanId))"]]}, "added_lines": 23, "deleted_lines": 19, "source_code": "#!/usr/bin/python\ntry:\n\timport sys, os, MySQLdb, datetime\n\n\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\tcursor = connection.cursor ()\n\n\tcursor.execute (\"insert into scans (StartDate) values (CURRENT_TIMESTAMP)\")\n\tconnection.commit()\n\tscanId = cursor.lastrowid\n\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\n\tdata = cursor.fetchall ()\n\tconnection.close()\n\n\tfor row in data:\n\t\tprint \"Running sublister on \" + row[0]\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/database/additional_tools/sublister_to_db.py \" + row[0] + \" \" + str(scanId))\n\n\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\tcursor = connection.cursor ()\n\tcursor.execute (\"update scans set EndDate = CURRENT_TIMESTAMP where ScanID = %s\", (scanId))\n\tconnection.commit()\n\tconnection.close()\n\n\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/telegram/notify.py \" + str(scanId))\nexcept Exception, e:\n\tprint \"error: \" + str(e)\n\twith open(os.path.dirname(os.path.abspath(__file__))  + '/logs/run_logs.txt', 'w+') as the_file:\n\t\tthe_file.write(str(e) + \"\\n\")\n", "source_code_before": "#!/usr/bin/python\nimport sys, os, MySQLdb, datetime\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\ncursor = connection.cursor ()\n\ncursor.execute (\"insert into scans (StartDate) values (CURRENT_TIMESTAMP)\")\nconnection.commit()\nscanId = cursor.lastrowid\n\ncursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\ndata = cursor.fetchall ()\nconnection.close()\n\nfor row in data:\n\tprint \"Running sublister on \" + row[0]\n\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/database/additional_tools/sublister_to_db.py \" + row[0] + \" \" + str(scanId))\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\ncursor = connection.cursor ()\ncursor.execute (\"update scans set EndDate = CURRENT_TIMESTAMP where ScanID = %s\", (scanId))\nconnection.commit()\nconnection.close()\n\nos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/telegram/notify.py \" + str(scanId))\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": 23, "complexity": 0, "token_count": 248}, {"old_path": "telegram/bot.py", "new_path": "telegram/bot.py", "filename": "bot.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -10,6 +10,9 @@ from random import randint\n logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n \t\t\t\t\tlevel=logging.INFO)\n \n+telegram_bot_token = \"576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI\"\n+\n+\n logger = logging.getLogger(__name__)\n \n BUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n@@ -302,7 +305,7 @@ def cancel(bot, update):\n \n def main():\n \t# Create the EventHandler and pass it your bot's token.\n-\tupdater = Updater(\"576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI\")\n+\tupdater = Updater(telegram_bot_token)\n \n \t# Get the dispatcher to register handlers\n \tdp = updater.dispatcher\n", "diff_parsed": {"added": [[13, "telegram_bot_token = \"576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI\""], [14, ""], [15, ""], [308, "\tupdater = Updater(telegram_bot_token)"]], "deleted": [[305, "\tupdater = Updater(\"576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI\")"]]}, "added_lines": 4, "deleted_lines": 1, "source_code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport logging, datetime, MySQLdb, os, telegram\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nfrom random import randint\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\ntelegram_bot_token = \"576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI\"\n\n\nlogger = logging.getLogger(__name__)\n\nBUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n\ndef start(bot, update):\n\tuser = update.message.from_user\n\thour = datetime.datetime.now().hour\n\tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])\n\n\tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n\treply_markup = InlineKeyboardMarkup(keyboard)\n\tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n\tprint \"button before\"\n\treturn BUTTON\n\n\ndef button(bot, update):\n\tquery = update.callback_query\n\t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button\n\n\tprint \"button func called with: \" + query.data\n\tchoice = query.data.split('-')[0]\n\tr = str(randint(0, 99))\n\n\theader_1 = \"Catagory:\"\n\tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + r)]]\n\n\theader_2 = \"Action:\"\n\tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n\t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n\t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n\theader_3 = \"Action:\"\n\tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n\t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n\t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n        header_5 = \"Action:\"\n        keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n                         InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n\t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]\n\n        header_6 = \"Which type of domains?\"\n        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='all-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n\n        header_7 = \"How many domains?\"\n        keyboard_7 = [[InlineKeyboardButton(\"Top 20\", callback_data='limit-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='nolimit-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_data-' + r)]]\n\n\n\t#ToDO: Transform into a swtich\n\tif choice == \"back\":\n\t\tbot.edit_message_text(header_1, reply_markup=InlineKeyboardMarkup(keyboard_1), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"close\":\n\t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)\n\telif choice == \"scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"data\":\n\t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\tcursor = connection.cursor ()\n\n\tif choice == \"latest\":\n\t\tget_latest_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\telif choice == \"custom\":\n\t\tget_custom_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\t\treturn CUSTOM_SCAN_ID_INPUT\n\telif choice == \"run\":\n\t\trun_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\n        if choice == \"add\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\treturn ADD_DOMAIN\n        elif choice == \"edit\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return EDIT_DOMAIN\n        elif choice == \"get\":\n                cursor.close()\n                connection.close()\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"topdomais\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = False\n\t\treturn BUTTON\n        elif choice == \"subdomains\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = True\n\t\treturn BUTTON\n        elif choice == \"contains\":\n\t\tbot.send_message(text=\"What is the search string?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return CONTAINS\n        elif choice == \"back_data\":\n                bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"back_get\":\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"active\":\n\t\tglobal active\n\t\tactive = True\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n        elif choice == \"all\":\n                global active\n                active = False\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"nolimit\":\n\t\tglobal subdomains\n\t\tif subdomains:\n                        global limit\n                        limit = False\n\t\t\tbot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\treturn GET_DOMAINS\n\t\telse:\n\t\t\tglobal limit\n\t\t\tlimit = False\n\t\t\tget_topdomains()\n        elif choice == \"limit\":\n                global subdomains\n                if subdomains:\n                        global limit\n                        limit = True\n                        bot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                        return GET_DOMAINS\n                else:\n                        global limit\n                        limit = True\n\t\t\tget_topdomains()\n\n\tif choice == \"yes_scan\":\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telif choice == \"back_scan\" or choice == \"no_scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\ndef get_latest_scan(bot, update, cursor):\n\tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))\n\telse:\n\t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\n\ndef get_custom_scan(bot, update, cursor):\n\tquery = update.callback_query\n\n\tcursor.execute (\"SELECT ScanID FROM scans where EndDate is not null ORDER BY ScanID DESC LIMIT 10\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tlatestScanIds = sorted([str(x[0]) for x in data])\n\t\tfirstRow = latestScanIds[:len(latestScanIds)/2]\n\t\tsecondRow = latestScanIds[len(latestScanIds)/2:]\n\t\tcustom_keyboard = [firstRow, secondRow]\n\t\treply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\n\n\t\tif data:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\ttext=\"Which scan ID? \\n/cancel to cancel\",\n\t\t\t\treply_markup=reply_markup, ForceReply = True)\n\t\telse:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\t text=\"Which scan ID? \\n/cancel to cancel\")\n\n\ndef run_scan(bot, update, cursor):\n\tquery = update.callback_query\n\tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")\n\tdata = cursor.fetchall()\n\tif data[0][2] != None:\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telse:\n\t\tr = str(randint(0, 99))\n\t        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        \tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                \t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        \t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n\ndef custom_scan_id_input(bot, update):\n\tprint \"inside input method with data: \" + update.message.text\n\tcustomId = update.message.text\n\ttry:\n\t\tint(customId)\n\texcept ValueError:\n\t\tprint \"invalid number\"\n\t\tupdate.message.reply_text(\"Not a valid number\")\n\telse:\n\t\tprint \"valid number\"\n        \tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n        \tcursor = connection.cursor ()\n\t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))\n\t        data = cursor.fetchall()\n\t\tcursor.close()\n\t\tconnection.close()\n\t\tif data:\n\t\t\tprint \"scan ID was found in the db\"\n\t\t\tprint \"data[0][0] is: \" + str(data[0][0])\n\t\t\tif data[0][0] == None:\n\t\t\t\tprint \"EndDate of scan is empty\"\n\t\t\t\tupdate.message.reply_text(\"This scan hasn't finished yet\")\n\t\t\telse:\n\t\t\t\tprint \"Valid scan found\"\n\t\t\t\treply_markup = telegram.ReplyKeyboardRemove()\n\t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)\n\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))\n\t\t\t\treturn ConversationHandler.END\n\t\telse:\n\t\t\tprint \"Scan ID not found in db\"\n\t\t\tupdate.message.reply_text(\"This scan ID doesn't exist\")\n\n\ndef add_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef edit_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef get_domains():\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef domains_contain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef help(bot, update):\n\tupdate.message.reply_text(\"click /start to start :)\")\n\n\ndef error(bot, update, error):\n\tlogger.warning('Update \"%s\" caused error \"%s\"', update, error)\n\t\t\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treply_markup = telegram.ReplyKeyboardRemove()\n\tupdate.message.reply_text(\"canceled! Click or type /start to start again\", reply_markup=reply_markup)\n\treturn ConversationHandler.END\n\n\ndef main():\n\t# Create the EventHandler and pass it your bot's token.\n\tupdater = Updater(telegram_bot_token)\n\n\t# Get the dispatcher to register handlers\n\tdp = updater.dispatcher\n\n\t# Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t\tBUTTON: [CallbackQueryHandler(button),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n\t\t\tCUSTOM_SCAN_ID_INPUT: [MessageHandler(Filters.text, custom_scan_id_input),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n                        ADD_DOMAIN: [MessageHandler(Filters.text, add_domain),\n                                           CommandHandler('cancel', cancel)],\n                        EDIT_DOMAIN: [MessageHandler(Filters.text, edit_domain),\n                                           CommandHandler('cancel', cancel)],\n                        GET_DOMAINS: [MessageHandler(Filters.text, get_domains),\n                                           CommandHandler('cancel', cancel)],\n                        CONTAINS: [MessageHandler(Filters.text, domains_contain),\n                                           CommandHandler('cancel', cancel)]\n\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\n\t# log all errors\n\tdp.add_error_handler(error)\n\n\t# Start the Bot\n\tupdater.start_polling()\n\n\t# Run the bot until you press Ctrl-C or the process receives SIGINT,\n\t# SIGTERM or SIGABRT. This should be used most of the time, since\n\t# start_polling() is non-blocking and will stop the bot gracefully.\n\tupdater.idle()\n\n\nif __name__ == '__main__':\n\tmain()\n", "source_code_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport logging, datetime, MySQLdb, os, telegram\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nfrom random import randint\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\nlogger = logging.getLogger(__name__)\n\nBUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n\ndef start(bot, update):\n\tuser = update.message.from_user\n\thour = datetime.datetime.now().hour\n\tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])\n\n\tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n\treply_markup = InlineKeyboardMarkup(keyboard)\n\tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n\tprint \"button before\"\n\treturn BUTTON\n\n\ndef button(bot, update):\n\tquery = update.callback_query\n\t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button\n\n\tprint \"button func called with: \" + query.data\n\tchoice = query.data.split('-')[0]\n\tr = str(randint(0, 99))\n\n\theader_1 = \"Catagory:\"\n\tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + r)]]\n\n\theader_2 = \"Action:\"\n\tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n\t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n\t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n\theader_3 = \"Action:\"\n\tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n\t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n\t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n        header_5 = \"Action:\"\n        keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n                         InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n\t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]\n\n        header_6 = \"Which type of domains?\"\n        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='all-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n\n        header_7 = \"How many domains?\"\n        keyboard_7 = [[InlineKeyboardButton(\"Top 20\", callback_data='limit-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='nolimit-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_data-' + r)]]\n\n\n\t#ToDO: Transform into a swtich\n\tif choice == \"back\":\n\t\tbot.edit_message_text(header_1, reply_markup=InlineKeyboardMarkup(keyboard_1), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"close\":\n\t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)\n\telif choice == \"scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"data\":\n\t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\tcursor = connection.cursor ()\n\n\tif choice == \"latest\":\n\t\tget_latest_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\telif choice == \"custom\":\n\t\tget_custom_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\t\treturn CUSTOM_SCAN_ID_INPUT\n\telif choice == \"run\":\n\t\trun_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\n        if choice == \"add\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\treturn ADD_DOMAIN\n        elif choice == \"edit\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return EDIT_DOMAIN\n        elif choice == \"get\":\n                cursor.close()\n                connection.close()\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"topdomais\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = False\n\t\treturn BUTTON\n        elif choice == \"subdomains\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = True\n\t\treturn BUTTON\n        elif choice == \"contains\":\n\t\tbot.send_message(text=\"What is the search string?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return CONTAINS\n        elif choice == \"back_data\":\n                bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"back_get\":\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"active\":\n\t\tglobal active\n\t\tactive = True\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n        elif choice == \"all\":\n                global active\n                active = False\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"nolimit\":\n\t\tglobal subdomains\n\t\tif subdomains:\n                        global limit\n                        limit = False\n\t\t\tbot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\treturn GET_DOMAINS\n\t\telse:\n\t\t\tglobal limit\n\t\t\tlimit = False\n\t\t\tget_topdomains()\n        elif choice == \"limit\":\n                global subdomains\n                if subdomains:\n                        global limit\n                        limit = True\n                        bot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                        return GET_DOMAINS\n                else:\n                        global limit\n                        limit = True\n\t\t\tget_topdomains()\n\n\tif choice == \"yes_scan\":\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telif choice == \"back_scan\" or choice == \"no_scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\ndef get_latest_scan(bot, update, cursor):\n\tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))\n\telse:\n\t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\n\ndef get_custom_scan(bot, update, cursor):\n\tquery = update.callback_query\n\n\tcursor.execute (\"SELECT ScanID FROM scans where EndDate is not null ORDER BY ScanID DESC LIMIT 10\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tlatestScanIds = sorted([str(x[0]) for x in data])\n\t\tfirstRow = latestScanIds[:len(latestScanIds)/2]\n\t\tsecondRow = latestScanIds[len(latestScanIds)/2:]\n\t\tcustom_keyboard = [firstRow, secondRow]\n\t\treply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\n\n\t\tif data:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\ttext=\"Which scan ID? \\n/cancel to cancel\",\n\t\t\t\treply_markup=reply_markup, ForceReply = True)\n\t\telse:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\t text=\"Which scan ID? \\n/cancel to cancel\")\n\n\ndef run_scan(bot, update, cursor):\n\tquery = update.callback_query\n\tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")\n\tdata = cursor.fetchall()\n\tif data[0][2] != None:\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telse:\n\t\tr = str(randint(0, 99))\n\t        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        \tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                \t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        \t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n\ndef custom_scan_id_input(bot, update):\n\tprint \"inside input method with data: \" + update.message.text\n\tcustomId = update.message.text\n\ttry:\n\t\tint(customId)\n\texcept ValueError:\n\t\tprint \"invalid number\"\n\t\tupdate.message.reply_text(\"Not a valid number\")\n\telse:\n\t\tprint \"valid number\"\n        \tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n        \tcursor = connection.cursor ()\n\t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))\n\t        data = cursor.fetchall()\n\t\tcursor.close()\n\t\tconnection.close()\n\t\tif data:\n\t\t\tprint \"scan ID was found in the db\"\n\t\t\tprint \"data[0][0] is: \" + str(data[0][0])\n\t\t\tif data[0][0] == None:\n\t\t\t\tprint \"EndDate of scan is empty\"\n\t\t\t\tupdate.message.reply_text(\"This scan hasn't finished yet\")\n\t\t\telse:\n\t\t\t\tprint \"Valid scan found\"\n\t\t\t\treply_markup = telegram.ReplyKeyboardRemove()\n\t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)\n\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))\n\t\t\t\treturn ConversationHandler.END\n\t\telse:\n\t\t\tprint \"Scan ID not found in db\"\n\t\t\tupdate.message.reply_text(\"This scan ID doesn't exist\")\n\n\ndef add_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef edit_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef get_domains():\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef domains_contain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef help(bot, update):\n\tupdate.message.reply_text(\"click /start to start :)\")\n\n\ndef error(bot, update, error):\n\tlogger.warning('Update \"%s\" caused error \"%s\"', update, error)\n\t\t\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treply_markup = telegram.ReplyKeyboardRemove()\n\tupdate.message.reply_text(\"canceled! Click or type /start to start again\", reply_markup=reply_markup)\n\treturn ConversationHandler.END\n\n\ndef main():\n\t# Create the EventHandler and pass it your bot's token.\n\tupdater = Updater(\"576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI\")\n\n\t# Get the dispatcher to register handlers\n\tdp = updater.dispatcher\n\n\t# Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t\tBUTTON: [CallbackQueryHandler(button),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n\t\t\tCUSTOM_SCAN_ID_INPUT: [MessageHandler(Filters.text, custom_scan_id_input),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n                        ADD_DOMAIN: [MessageHandler(Filters.text, add_domain),\n                                           CommandHandler('cancel', cancel)],\n                        EDIT_DOMAIN: [MessageHandler(Filters.text, edit_domain),\n                                           CommandHandler('cancel', cancel)],\n                        GET_DOMAINS: [MessageHandler(Filters.text, get_domains),\n                                           CommandHandler('cancel', cancel)],\n                        CONTAINS: [MessageHandler(Filters.text, domains_contain),\n                                           CommandHandler('cancel', cancel)]\n\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\n\t# log all errors\n\tdp.add_error_handler(error)\n\n\t# Start the Bot\n\tupdater.start_polling()\n\n\t# Run the bot until you press Ctrl-C or the process receives SIGINT,\n\t# SIGTERM or SIGABRT. This should be used most of the time, since\n\t# start_polling() is non-blocking and will stop the bot gracefully.\n\tupdater.idle()\n\n\nif __name__ == '__main__':\n\tmain()\n", "methods": [{"name": "start", "start_line": 20, "end_line": 32}, {"name": "button", "start_line": 35, "end_line": 187}, {"name": "get_latest_scan", "start_line": 190, "end_line": 196}, {"name": "get_custom_scan", "start_line": 199, "end_line": 217}, {"name": "run_scan", "start_line": 220, "end_line": 235}, {"name": "custom_scan_id_input", "start_line": 238, "end_line": 268}, {"name": "add_domain", "start_line": 271, "end_line": 273}, {"name": "edit_domain", "start_line": 276, "end_line": 278}, {"name": "get_domains", "start_line": 281, "end_line": 283}, {"name": "domains_contain", "start_line": 286, "end_line": 288}, {"name": "help", "start_line": 291, "end_line": 292}, {"name": "error", "start_line": 295, "end_line": 296}, {"name": "cancel", "start_line": 299, "end_line": 303}, {"name": "main", "start_line": 306, "end_line": 347}], "methods_before": [{"name": "start", "start_line": 17, "end_line": 29}, {"name": "button", "start_line": 32, "end_line": 184}, {"name": "get_latest_scan", "start_line": 187, "end_line": 193}, {"name": "get_custom_scan", "start_line": 196, "end_line": 214}, {"name": "run_scan", "start_line": 217, "end_line": 232}, {"name": "custom_scan_id_input", "start_line": 235, "end_line": 265}, {"name": "add_domain", "start_line": 268, "end_line": 270}, {"name": "edit_domain", "start_line": 273, "end_line": 275}, {"name": "get_domains", "start_line": 278, "end_line": 280}, {"name": "domains_contain", "start_line": 283, "end_line": 285}, {"name": "help", "start_line": 288, "end_line": 289}, {"name": "error", "start_line": 292, "end_line": 293}, {"name": "cancel", "start_line": 296, "end_line": 300}, {"name": "main", "start_line": 303, "end_line": 344}], "changed_methods": [{"name": "main", "start_line": 306, "end_line": 347}], "nloc": 270, "complexity": 48, "token_count": 2320}, {"old_path": null, "new_path": "tools/online.py", "filename": "online.py", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1,45 @@\n+#!/usr/bin/python\n+\n+import httplib\n+import socket\n+import re\n+import sys\n+\n+def online(host):\n+    try:\n+        socket.gethostbyname(host)\n+    except socket.gaierror:\n+        return False\n+    else:\n+        return True\n+\n+def available(host, path=\"/\"):\n+    try:\n+        conn = httplib.HTTPConnection(host, timeout=5)\n+        conn.request(\"HEAD\", path)\n+        if re.match(\"^[23]\\d\\d$\", str(conn.getresponse().status)):\n+            return True\n+    except StandardError:\n+        return False\n+\n+input_file = sys.argv[1]\n+output_file = sys.argv[2]\n+\n+input_file_open = open(input_file, 'r')\n+output_file_open = open(output_file, 'w+')\n+\n+domains = input_file_open.readlines()\n+\n+print(\"\\n-- Writing online hosts in \"+input_file+\" to \"+output_file+\" --\\n\")\n+\n+for domain in domains:\n+    domain = domain.strip()\n+    if online(domain) == True and available(domain) == True:\n+        print(\"[+]\"+domain.strip())\n+        output_file_open.write(domain+\"\\n\")\n+    else:\n+        print(\"[-]\"+domain)\n+\n+input_file_open.close()\n+output_file_open.close()\n+print(\"\\n-- Done --\")\n", "diff_parsed": {"added": [[1, "#!/usr/bin/python"], [2, ""], [3, "import httplib"], [4, "import socket"], [5, "import re"], [6, "import sys"], [7, ""], [8, "def online(host):"], [9, "    try:"], [10, "        socket.gethostbyname(host)"], [11, "    except socket.gaierror:"], [12, "        return False"], [13, "    else:"], [14, "        return True"], [15, ""], [16, "def available(host, path=\"/\"):"], [17, "    try:"], [18, "        conn = httplib.HTTPConnection(host, timeout=5)"], [19, "        conn.request(\"HEAD\", path)"], [20, "        if re.match(\"^[23]\\d\\d$\", str(conn.getresponse().status)):"], [21, "            return True"], [22, "    except StandardError:"], [23, "        return False"], [24, ""], [25, "input_file = sys.argv[1]"], [26, "output_file = sys.argv[2]"], [27, ""], [28, "input_file_open = open(input_file, 'r')"], [29, "output_file_open = open(output_file, 'w+')"], [30, ""], [31, "domains = input_file_open.readlines()"], [32, ""], [33, "print(\"\\n-- Writing online hosts in \"+input_file+\" to \"+output_file+\" --\\n\")"], [34, ""], [35, "for domain in domains:"], [36, "    domain = domain.strip()"], [37, "    if online(domain) == True and available(domain) == True:"], [38, "        print(\"[+]\"+domain.strip())"], [39, "        output_file_open.write(domain+\"\\n\")"], [40, "    else:"], [41, "        print(\"[-]\"+domain)"], [42, ""], [43, "input_file_open.close()"], [44, "output_file_open.close()"], [45, "print(\"\\n-- Done --\")"]], "deleted": []}, "added_lines": 45, "deleted_lines": 0, "source_code": "#!/usr/bin/python\n\nimport httplib\nimport socket\nimport re\nimport sys\n\ndef online(host):\n    try:\n        socket.gethostbyname(host)\n    except socket.gaierror:\n        return False\n    else:\n        return True\n\ndef available(host, path=\"/\"):\n    try:\n        conn = httplib.HTTPConnection(host, timeout=5)\n        conn.request(\"HEAD\", path)\n        if re.match(\"^[23]\\d\\d$\", str(conn.getresponse().status)):\n            return True\n    except StandardError:\n        return False\n\ninput_file = sys.argv[1]\noutput_file = sys.argv[2]\n\ninput_file_open = open(input_file, 'r')\noutput_file_open = open(output_file, 'w+')\n\ndomains = input_file_open.readlines()\n\nprint(\"\\n-- Writing online hosts in \"+input_file+\" to \"+output_file+\" --\\n\")\n\nfor domain in domains:\n    domain = domain.strip()\n    if online(domain) == True and available(domain) == True:\n        print(\"[+]\"+domain.strip())\n        output_file_open.write(domain+\"\\n\")\n    else:\n        print(\"[-]\"+domain)\n\ninput_file_open.close()\noutput_file_open.close()\nprint(\"\\n-- Done --\")\n", "source_code_before": null, "methods": [{"name": "online", "start_line": 8, "end_line": 14}, {"name": "available", "start_line": 16, "end_line": 23}], "methods_before": [], "changed_methods": [{"name": "online", "start_line": 8, "end_line": 14}, {"name": "available", "start_line": 16, "end_line": 23}], "nloc": 35, "complexity": 5, "token_count": 209}], "dmm_unit_size": 0.9655172413793104, "dmm_unit_complexity": 1.0, "dmm_unit_interfacing": 1.0},
    {"hash": "a799879cf6ffc79b20ec6c77b2730e22b3e54fce", "msg": "small changed to install script", "author": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "committer": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "author_date": "2018-05-27 02:54:59+02:00", "author_timezone": -7200, "committer_date": "2018-05-27 02:54:59+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["fd519918f2192de40d7437064df736dc6aa4a108"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 14, "insertions": 18, "lines": 32, "files": 2, "modified_files": [{"old_path": "database/db_test.py", "new_path": "database/db_test.py", "filename": "db_test.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -13,9 +13,9 @@ cursor.execute (\"\"\"\n         \"\"\".format(\"domains\"))\n \n if cursor.fetchone()[0] == 1:\n-        print \"[+] Table domains found\"\n+        print \"    [+] Table domains found\"\n else:\n-\tprint \"[-] Hmm... No table 'domains' was found in the database recon. Did you run the initialize script?\"\n+\tprint \"    [-] Hmm... No table 'domains' was found in the database recon. Did you run the initialize script?\"\n \n \n cursor.execute (\"\"\"\n@@ -25,9 +25,9 @@ cursor.execute (\"\"\"\n         \"\"\".format(\"errors\"))\n \n if cursor.fetchone()[0] == 1:\n-        print \"[+] Table errors found\"\n+        print \"    [+] Table errors found\"\n else:\n-        print \"[-] Hmm... No table 'errors' was found in the database recon. Did you run the initialize script?\"\n+        print \"    [-] Hmm... No table 'errors' was found in the database recon. Did you run the initialize script?\"\n \n cursor.execute (\"\"\"\n         SELECT COUNT(*)\n@@ -36,9 +36,9 @@ cursor.execute (\"\"\"\n         \"\"\".format(\"scans\"))\n \n if cursor.fetchone()[0] == 1:\n-        print \"[+] Table scans found\"\n+        print \"    [+] Table scans found\"\n else:\n-        print \"[-] Hmm... No table 'scans' was found in the database recon. Did you run the initialize script?\"\n+        print \"    [-] Hmm... No table 'scans' was found in the database recon. Did you run the initialize script?\"\n \n \n cursor.close ()\n", "diff_parsed": {"added": [[16, "        print \"    [+] Table domains found\""], [18, "\tprint \"    [-] Hmm... No table 'domains' was found in the database recon. Did you run the initialize script?\""], [28, "        print \"    [+] Table errors found\""], [30, "        print \"    [-] Hmm... No table 'errors' was found in the database recon. Did you run the initialize script?\""], [39, "        print \"    [+] Table scans found\""], [41, "        print \"    [-] Hmm... No table 'scans' was found in the database recon. Did you run the initialize script?\""]], "deleted": [[16, "        print \"[+] Table domains found\""], [18, "\tprint \"[-] Hmm... No table 'domains' was found in the database recon. Did you run the initialize script?\""], [28, "        print \"[+] Table errors found\""], [30, "        print \"[-] Hmm... No table 'errors' was found in the database recon. Did you run the initialize script?\""], [39, "        print \"[+] Table scans found\""], [41, "        print \"[-] Hmm... No table 'scans' was found in the database recon. Did you run the initialize script?\""]]}, "added_lines": 6, "deleted_lines": 6, "source_code": "#!/usr/bin/python\n\nimport MySQLdb\nimport sys\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\ncursor = connection.cursor ()\ncursor.execute (\"\"\"\n        SELECT COUNT(*)\n        FROM information_schema.tables\n        WHERE table_name = '{0}'\n        \"\"\".format(\"domains\"))\n\nif cursor.fetchone()[0] == 1:\n        print \"    [+] Table domains found\"\nelse:\n\tprint \"    [-] Hmm... No table 'domains' was found in the database recon. Did you run the initialize script?\"\n\n\ncursor.execute (\"\"\"\n        SELECT COUNT(*)\n        FROM information_schema.tables\n        WHERE table_name = '{0}'\n        \"\"\".format(\"errors\"))\n\nif cursor.fetchone()[0] == 1:\n        print \"    [+] Table errors found\"\nelse:\n        print \"    [-] Hmm... No table 'errors' was found in the database recon. Did you run the initialize script?\"\n\ncursor.execute (\"\"\"\n        SELECT COUNT(*)\n        FROM information_schema.tables\n        WHERE table_name = '{0}'\n        \"\"\".format(\"scans\"))\n\nif cursor.fetchone()[0] == 1:\n        print \"    [+] Table scans found\"\nelse:\n        print \"    [-] Hmm... No table 'scans' was found in the database recon. Did you run the initialize script?\"\n\n\ncursor.close ()\nconnection.close ()\nsys.exit()\n\n", "source_code_before": "#!/usr/bin/python\n\nimport MySQLdb\nimport sys\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\ncursor = connection.cursor ()\ncursor.execute (\"\"\"\n        SELECT COUNT(*)\n        FROM information_schema.tables\n        WHERE table_name = '{0}'\n        \"\"\".format(\"domains\"))\n\nif cursor.fetchone()[0] == 1:\n        print \"[+] Table domains found\"\nelse:\n\tprint \"[-] Hmm... No table 'domains' was found in the database recon. Did you run the initialize script?\"\n\n\ncursor.execute (\"\"\"\n        SELECT COUNT(*)\n        FROM information_schema.tables\n        WHERE table_name = '{0}'\n        \"\"\".format(\"errors\"))\n\nif cursor.fetchone()[0] == 1:\n        print \"[+] Table errors found\"\nelse:\n        print \"[-] Hmm... No table 'errors' was found in the database recon. Did you run the initialize script?\"\n\ncursor.execute (\"\"\"\n        SELECT COUNT(*)\n        FROM information_schema.tables\n        WHERE table_name = '{0}'\n        \"\"\".format(\"scans\"))\n\nif cursor.fetchone()[0] == 1:\n        print \"[+] Table scans found\"\nelse:\n        print \"[-] Hmm... No table 'scans' was found in the database recon. Did you run the initialize script?\"\n\n\ncursor.close ()\nconnection.close ()\nsys.exit()\n\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": 34, "complexity": 0, "token_count": 135}, {"old_path": "install.sh", "new_path": "install.sh", "filename": "install.sh", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -1,16 +1,17 @@\n- #!/usr/bin/env bash\n+#!/usr/bin/env bash\n \n # Install sublis3r\n-#git clone https://github.com/aboul3la/Sublist3r.git tools/dependencies/sublister\n+git clone https://github.com/aboul3la/Sublist3r.git tools/dependencies/sublister\n \n-#echo \"- Creating database 'recon' with tables 'domains' and 'errors' -\"\n-#python database/init_db.py\n+echo \"----------------------------------------------------------------\"\n+echo \"[+] Creating database 'recon' with tables 'domains' and 'errors'\"\n+python database/init_db.py\n \n-#echo \"- Checking if the database was created successfully -\"\n-#python database/db_test.py\n+echo \"[+] Checking if the database was created successfully\"\n+python database/db_test.py\n \n-echo \"- Adding a cron task to run 'run.py' every 12 hours. You can edit this with the command 'crontab -e' -\"\n-echo \"Check?: Adding the path to crontab. If this isn't the right path to the file, please edit this with the command 'crontab -e'\"\n+echo \"[+] Adding a cron task to run 'run.py' every 12 hours. You can edit this with the command 'crontab -e'\"\n+echo \"[?] Adding the path to crontab. If this isn't the right path to the file, please edit this with the command 'crontab -e'\"\n #write out current crontab\n crontab -l > mycron\n #echo new cron into cron file\n@@ -18,3 +19,6 @@ echo \"0 */12 * * * python $(pwd)/run.py\" >> mycron\n #install new cron file\n crontab mycron\n rm mycron\n+\n+echo \"[!] All set!\"\n+echo \"[!] Now lets run main.py to get started with adding domains\"\n", "diff_parsed": {"added": [[1, "#!/usr/bin/env bash"], [4, "git clone https://github.com/aboul3la/Sublist3r.git tools/dependencies/sublister"], [6, "echo \"----------------------------------------------------------------\""], [7, "echo \"[+] Creating database 'recon' with tables 'domains' and 'errors'\""], [8, "python database/init_db.py"], [10, "echo \"[+] Checking if the database was created successfully\""], [11, "python database/db_test.py"], [13, "echo \"[+] Adding a cron task to run 'run.py' every 12 hours. You can edit this with the command 'crontab -e'\""], [14, "echo \"[?] Adding the path to crontab. If this isn't the right path to the file, please edit this with the command 'crontab -e'\""], [22, ""], [23, "echo \"[!] All set!\""], [24, "echo \"[!] Now lets run main.py to get started with adding domains\""]], "deleted": [[1, " #!/usr/bin/env bash"], [4, "#git clone https://github.com/aboul3la/Sublist3r.git tools/dependencies/sublister"], [6, "#echo \"- Creating database 'recon' with tables 'domains' and 'errors' -\""], [7, "#python database/init_db.py"], [9, "#echo \"- Checking if the database was created successfully -\""], [10, "#python database/db_test.py"], [12, "echo \"- Adding a cron task to run 'run.py' every 12 hours. You can edit this with the command 'crontab -e' -\""], [13, "echo \"Check?: Adding the path to crontab. If this isn't the right path to the file, please edit this with the command 'crontab -e'\""]]}, "added_lines": 12, "deleted_lines": 8, "source_code": "#!/usr/bin/env bash\n\n# Install sublis3r\ngit clone https://github.com/aboul3la/Sublist3r.git tools/dependencies/sublister\n\necho \"----------------------------------------------------------------\"\necho \"[+] Creating database 'recon' with tables 'domains' and 'errors'\"\npython database/init_db.py\n\necho \"[+] Checking if the database was created successfully\"\npython database/db_test.py\n\necho \"[+] Adding a cron task to run 'run.py' every 12 hours. You can edit this with the command 'crontab -e'\"\necho \"[?] Adding the path to crontab. If this isn't the right path to the file, please edit this with the command 'crontab -e'\"\n#write out current crontab\ncrontab -l > mycron\n#echo new cron into cron file\necho \"0 */12 * * * python $(pwd)/run.py\" >> mycron\n#install new cron file\ncrontab mycron\nrm mycron\n\necho \"[!] All set!\"\necho \"[!] Now lets run main.py to get started with adding domains\"\n", "source_code_before": " #!/usr/bin/env bash\n\n# Install sublis3r\n#git clone https://github.com/aboul3la/Sublist3r.git tools/dependencies/sublister\n\n#echo \"- Creating database 'recon' with tables 'domains' and 'errors' -\"\n#python database/init_db.py\n\n#echo \"- Checking if the database was created successfully -\"\n#python database/db_test.py\n\necho \"- Adding a cron task to run 'run.py' every 12 hours. You can edit this with the command 'crontab -e' -\"\necho \"Check?: Adding the path to crontab. If this isn't the right path to the file, please edit this with the command 'crontab -e'\"\n#write out current crontab\ncrontab -l > mycron\n#echo new cron into cron file\necho \"0 */12 * * * python $(pwd)/run.py\" >> mycron\n#install new cron file\ncrontab mycron\nrm mycron\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "4836fb0f9bd698fdac3cd71fad55c48050406bda", "msg": "Add readme", "author": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "committer": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "author_date": "2018-05-27 02:57:12+02:00", "author_timezone": -7200, "committer_date": "2018-05-27 02:57:12+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["a799879cf6ffc79b20ec6c77b2730e22b3e54fce"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 0, "insertions": 1, "lines": 1, "files": 1, "modified_files": [{"old_path": null, "new_path": "README.md", "filename": "README.md", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1 @@\n+Framework to monitor subdomains\n", "diff_parsed": {"added": [[1, "Framework to monitor subdomains"]], "deleted": []}, "added_lines": 1, "deleted_lines": 0, "source_code": "Framework to monitor subdomains\n", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "ffb978474e7f44bb54142491bc5c6e2927c1dc26", "msg": "Initial Commit", "author": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "committer": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "author_date": "2018-05-30 23:00:59+02:00", "author_timezone": -7200, "committer_date": "2018-05-30 23:00:59+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["4836fb0f9bd698fdac3cd71fad55c48050406bda"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 79, "insertions": 213, "lines": 292, "files": 12, "modified_files": [{"old_path": "database/additional_tools/sublister_to_db.py", "new_path": "database/additional_tools/domains_db.py", "filename": "domains_db.py", "change_type": "ModificationType.RENAME", "change_type_name": "RENAME", "diff": "@@ -1,8 +1,10 @@\n #!/usr/bin/python\n import os, sys, MySQLdb\n+sys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../../\")\n+import credentials\n \n try:\n-\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n \tdomain = sys.argv[1].strip()\n \tcursor = connection.cursor()\n \tscanId = sys.argv[2]\n@@ -13,8 +15,10 @@ try:\n \tif not os.path.exists(\"/tmp/ICU/\"+domain+\"/\"):\n \t    os.makedirs(\"/tmp/ICU/\"+domain+\"/\")\n \n+\t#Add new subdomain scanners here. Make sure to let them save the output to /tmp/ICU/{domain}/doains-all.txt\n \tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n \n+\t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on\n \tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n \tdatabase_data = cursor.fetchall()\n \tdatabase_domains = [d[0] for d in database_data]\n@@ -23,34 +27,43 @@ try:\n         program = [x[3] for x in database_data if x[0] == domain][0]\n         topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n \n+\t#All the domains from the subdomain scanners\n \tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n+\t#Add all the database subdomain to it\n \tdomains_all.extend(x for x in database_domains if x not in domains_all)\n+\t#Make it unique\n+\tdomains_all = list(set(domains_all))\n \n-\tdomains_all_combined_file = open(\"/tmp/ICU/\"+domain+\"/domains-all-combined.txt\", 'w')\n-\tfor item in domains_all:\n-\t\tdomains_all_combined_file.write(\"%s\\n\" % item)\n-\n-\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all-combined.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")\n+\t#Put all the online domains in a domains-online.txt\n+\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")\n \n+\t#Convert online domains to array\n \tdomains_online = open(\"/tmp/ICU/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n \n+\t#Loop through every subdomain\n \tfor sub_domain in domains_all:\n+\t\t#Get the scanID to insert. If the domains was already in the db and isnt changed, then keep the old scanID. otherwise use the scanID of the current scan\n \t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n+\n+\t\t#If the subdomain is online\n \t\tif sub_domain in domains_online:\n \t\t\tactive=True\n+\t\t\t#If the subdomain used to be offline, give it the current scanID\n \t\t\tif sub_domain in non_active_subdomains:\n \t\t\t\tinsertScanId = scanId\n \t\telse:\n \t\t\tactive=False\n \n+\n \t\tif sub_domain:\n+\t\t\t#Insert the new values, or update them if they already existed\n \t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))\n \t\t\tconnection.commit()\n \n-\n \tcursor.close ()\n \tconnection.close ()\n except Exception as e:\n+\t#Handle the errors, and save them to the database\n \tprint \"error in sublister_to_db.py with main domain; \" + domain\n \tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in sublister_to_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n \tconnection.commit()\n", "diff_parsed": {"added": [[3, "sys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../../\")"], [4, "import credentials"], [7, "\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)"], [18, "\t#Add new subdomain scanners here. Make sure to let them save the output to /tmp/ICU/{domain}/doains-all.txt"], [21, "\t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on"], [30, "\t#All the domains from the subdomain scanners"], [32, "\t#Add all the database subdomain to it"], [34, "\t#Make it unique"], [35, "\tdomains_all = list(set(domains_all))"], [37, "\t#Put all the online domains in a domains-online.txt"], [38, "\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")"], [40, "\t#Convert online domains to array"], [43, "\t#Loop through every subdomain"], [45, "\t\t#Get the scanID to insert. If the domains was already in the db and isnt changed, then keep the old scanID. otherwise use the scanID of the current scan"], [47, ""], [48, "\t\t#If the subdomain is online"], [51, "\t\t\t#If the subdomain used to be offline, give it the current scanID"], [57, ""], [59, "\t\t\t#Insert the new values, or update them if they already existed"], [66, "\t#Handle the errors, and save them to the database"]], "deleted": [[5, "\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [29, "\tdomains_all_combined_file = open(\"/tmp/ICU/\"+domain+\"/domains-all-combined.txt\", 'w')"], [30, "\tfor item in domains_all:"], [31, "\t\tdomains_all_combined_file.write(\"%s\\n\" % item)"], [32, ""], [33, "\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all-combined.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")"], [50, ""]]}, "added_lines": 20, "deleted_lines": 7, "source_code": "#!/usr/bin/python\nimport os, sys, MySQLdb\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../../\")\nimport credentials\n\ntry:\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tdomain = sys.argv[1].strip()\n\tcursor = connection.cursor()\n\tscanId = sys.argv[2]\n\n\tif not os.path.exists(\"/tmp/ICU\"):\n\t\tos.makedirs(\"/tmp/ICU\")\n\n\tif not os.path.exists(\"/tmp/ICU/\"+domain+\"/\"):\n\t    os.makedirs(\"/tmp/ICU/\"+domain+\"/\")\n\n\t#Add new subdomain scanners here. Make sure to let them save the output to /tmp/ICU/{domain}/doains-all.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n\n\t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on\n\tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n\tdatabase_data = cursor.fetchall()\n\tdatabase_domains = [d[0] for d in database_data]\n\n        non_active_subdomains = [x[0] for x in database_data if ord(x[2]) == False]\n        program = [x[3] for x in database_data if x[0] == domain][0]\n        topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n\n\t#All the domains from the subdomain scanners\n\tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n\t#Add all the database subdomain to it\n\tdomains_all.extend(x for x in database_domains if x not in domains_all)\n\t#Make it unique\n\tdomains_all = list(set(domains_all))\n\n\t#Put all the online domains in a domains-online.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")\n\n\t#Convert online domains to array\n\tdomains_online = open(\"/tmp/ICU/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n\n\t#Loop through every subdomain\n\tfor sub_domain in domains_all:\n\t\t#Get the scanID to insert. If the domains was already in the db and isnt changed, then keep the old scanID. otherwise use the scanID of the current scan\n\t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n\n\t\t#If the subdomain is online\n\t\tif sub_domain in domains_online:\n\t\t\tactive=True\n\t\t\t#If the subdomain used to be offline, give it the current scanID\n\t\t\tif sub_domain in non_active_subdomains:\n\t\t\t\tinsertScanId = scanId\n\t\telse:\n\t\t\tactive=False\n\n\n\t\tif sub_domain:\n\t\t\t#Insert the new values, or update them if they already existed\n\t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))\n\t\t\tconnection.commit()\n\n\tcursor.close ()\n\tconnection.close ()\nexcept Exception as e:\n\t#Handle the errors, and save them to the database\n\tprint \"error in sublister_to_db.py with main domain; \" + domain\n\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in sublister_to_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n\tconnection.commit()\n\tcursor.close()\n\tconnection.close()\n\tprint e\nsys.exit()\n", "source_code_before": "#!/usr/bin/python\nimport os, sys, MySQLdb\n\ntry:\n\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\tdomain = sys.argv[1].strip()\n\tcursor = connection.cursor()\n\tscanId = sys.argv[2]\n\n\tif not os.path.exists(\"/tmp/ICU\"):\n\t\tos.makedirs(\"/tmp/ICU\")\n\n\tif not os.path.exists(\"/tmp/ICU/\"+domain+\"/\"):\n\t    os.makedirs(\"/tmp/ICU/\"+domain+\"/\")\n\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n\n\tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n\tdatabase_data = cursor.fetchall()\n\tdatabase_domains = [d[0] for d in database_data]\n\n        non_active_subdomains = [x[0] for x in database_data if ord(x[2]) == False]\n        program = [x[3] for x in database_data if x[0] == domain][0]\n        topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n\n\tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n\tdomains_all.extend(x for x in database_domains if x not in domains_all)\n\n\tdomains_all_combined_file = open(\"/tmp/ICU/\"+domain+\"/domains-all-combined.txt\", 'w')\n\tfor item in domains_all:\n\t\tdomains_all_combined_file.write(\"%s\\n\" % item)\n\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all-combined.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")\n\n\tdomains_online = open(\"/tmp/ICU/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n\n\tfor sub_domain in domains_all:\n\t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n\t\tif sub_domain in domains_online:\n\t\t\tactive=True\n\t\t\tif sub_domain in non_active_subdomains:\n\t\t\t\tinsertScanId = scanId\n\t\telse:\n\t\t\tactive=False\n\n\t\tif sub_domain:\n\t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))\n\t\t\tconnection.commit()\n\n\n\tcursor.close ()\n\tconnection.close ()\nexcept Exception as e:\n\tprint \"error in sublister_to_db.py with main domain; \" + domain\n\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in sublister_to_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n\tconnection.commit()\n\tcursor.close()\n\tconnection.close()\n\tprint e\nsys.exit()\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": 45, "complexity": 0, "token_count": 516}, {"old_path": "database/additional_tools/get_subdomains.py", "new_path": null, "filename": "get_subdomains.py", "change_type": "ModificationType.DELETE", "change_type_name": "DELETE", "diff": "@@ -1,24 +0,0 @@\n-#!/usr/bin/python\n-import os, sys, MySQLdb\n-\n-connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n-domain = sys.argv[1].strip()\n-cursor = connection.cursor()\n-\n-cursor.execute (\"select Domain from domains where TopDomainID = (select DomainID from domains where Domain = %s)\", (domain,))\n-\n-data = cursor.fetchall()\n-#Get first the values out of tuple and create an array with them\n-database_domains = [d[0] for d in data]\n-\n-for row in database_domains:\n-\tprint row\n-\n-#cursor.execute(\"select DomainID from domains where Domain = %s\", (domain,))\n-#data = cursor.fetchall()\n-#data = data[0][0]\n-#print \"also the TopDomainId = \" + str(data)\n-\n-cursor.close ()\n-connection.close ()\n-sys.exit()\n", "diff_parsed": {"added": [], "deleted": [[1, "#!/usr/bin/python"], [2, "import os, sys, MySQLdb"], [3, ""], [4, "connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [5, "domain = sys.argv[1].strip()"], [6, "cursor = connection.cursor()"], [7, ""], [8, "cursor.execute (\"select Domain from domains where TopDomainID = (select DomainID from domains where Domain = %s)\", (domain,))"], [9, ""], [10, "data = cursor.fetchall()"], [11, "#Get first the values out of tuple and create an array with them"], [12, "database_domains = [d[0] for d in data]"], [13, ""], [14, "for row in database_domains:"], [15, "\tprint row"], [16, ""], [17, "#cursor.execute(\"select DomainID from domains where Domain = %s\", (domain,))"], [18, "#data = cursor.fetchall()"], [19, "#data = data[0][0]"], [20, "#print \"also the TopDomainId = \" + str(data)"], [21, ""], [22, "cursor.close ()"], [23, "connection.close ()"], [24, "sys.exit()"]]}, "added_lines": 0, "deleted_lines": 24, "source_code": null, "source_code_before": "#!/usr/bin/python\nimport os, sys, MySQLdb\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\ndomain = sys.argv[1].strip()\ncursor = connection.cursor()\n\ncursor.execute (\"select Domain from domains where TopDomainID = (select DomainID from domains where Domain = %s)\", (domain,))\n\ndata = cursor.fetchall()\n#Get first the values out of tuple and create an array with them\ndatabase_domains = [d[0] for d in data]\n\nfor row in database_domains:\n\tprint row\n\n#cursor.execute(\"select DomainID from domains where Domain = %s\", (domain,))\n#data = cursor.fetchall()\n#data = data[0][0]\n#print \"also the TopDomainId = \" + str(data)\n\ncursor.close ()\nconnection.close ()\nsys.exit()\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}, {"old_path": "database/db_test.py", "new_path": "database/db_test.py", "filename": "db_test.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -1,9 +1,11 @@\n #!/usr/bin/python\n-\n import MySQLdb\n import sys\n+import os\n+sys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\n+import credentials\n \n-connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+connection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n \n cursor = connection.cursor ()\n cursor.execute (\"\"\"\n", "diff_parsed": {"added": [[4, "import os"], [5, "sys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")"], [6, "import credentials"], [8, "connection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)"]], "deleted": [[2, ""], [6, "connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"]]}, "added_lines": 4, "deleted_lines": 2, "source_code": "#!/usr/bin/python\nimport MySQLdb\nimport sys\nimport os\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\nimport credentials\n\nconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\ncursor = connection.cursor ()\ncursor.execute (\"\"\"\n        SELECT COUNT(*)\n        FROM information_schema.tables\n        WHERE table_name = '{0}'\n        \"\"\".format(\"domains\"))\n\nif cursor.fetchone()[0] == 1:\n        print \"    [+] Table domains found\"\nelse:\n\tprint \"    [-] Hmm... No table 'domains' was found in the database recon. Did you run the initialize script?\"\n\n\ncursor.execute (\"\"\"\n        SELECT COUNT(*)\n        FROM information_schema.tables\n        WHERE table_name = '{0}'\n        \"\"\".format(\"errors\"))\n\nif cursor.fetchone()[0] == 1:\n        print \"    [+] Table errors found\"\nelse:\n        print \"    [-] Hmm... No table 'errors' was found in the database recon. Did you run the initialize script?\"\n\ncursor.execute (\"\"\"\n        SELECT COUNT(*)\n        FROM information_schema.tables\n        WHERE table_name = '{0}'\n        \"\"\".format(\"scans\"))\n\nif cursor.fetchone()[0] == 1:\n        print \"    [+] Table scans found\"\nelse:\n        print \"    [-] Hmm... No table 'scans' was found in the database recon. Did you run the initialize script?\"\n\n\ncursor.close ()\nconnection.close ()\nsys.exit()\n\n", "source_code_before": "#!/usr/bin/python\n\nimport MySQLdb\nimport sys\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\ncursor = connection.cursor ()\ncursor.execute (\"\"\"\n        SELECT COUNT(*)\n        FROM information_schema.tables\n        WHERE table_name = '{0}'\n        \"\"\".format(\"domains\"))\n\nif cursor.fetchone()[0] == 1:\n        print \"    [+] Table domains found\"\nelse:\n\tprint \"    [-] Hmm... No table 'domains' was found in the database recon. Did you run the initialize script?\"\n\n\ncursor.execute (\"\"\"\n        SELECT COUNT(*)\n        FROM information_schema.tables\n        WHERE table_name = '{0}'\n        \"\"\".format(\"errors\"))\n\nif cursor.fetchone()[0] == 1:\n        print \"    [+] Table errors found\"\nelse:\n        print \"    [-] Hmm... No table 'errors' was found in the database recon. Did you run the initialize script?\"\n\ncursor.execute (\"\"\"\n        SELECT COUNT(*)\n        FROM information_schema.tables\n        WHERE table_name = '{0}'\n        \"\"\".format(\"scans\"))\n\nif cursor.fetchone()[0] == 1:\n        print \"    [+] Table scans found\"\nelse:\n        print \"    [-] Hmm... No table 'scans' was found in the database recon. Did you run the initialize script?\"\n\n\ncursor.close ()\nconnection.close ()\nsys.exit()\n\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": 37, "complexity": 0, "token_count": 171}, {"old_path": "database/init_db.py", "new_path": "database/init_db.py", "filename": "init_db.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -2,19 +2,18 @@\n \n import MySQLdb\n import sys\n+import os\n+sys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\n+import credentials\n \n-username = \"rjp\"\n-password = \"1484\"\n-\n-connection = MySQLdb.connect (host = \"localhost\", user = username, passwd = password)\n-\n+connection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password)\n cursor = connection.cursor ()\n \n cursor.execute (\"\"\"\n CREATE DATABASE recon;\n \"\"\")\n \n-connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+connection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n cursor = connection.cursor ()\n \n cursor.execute (\"\"\"\n", "diff_parsed": {"added": [[5, "import os"], [6, "sys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")"], [7, "import credentials"], [9, "connection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password)"], [16, "connection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)"]], "deleted": [[6, "username = \"rjp\""], [7, "password = \"1484\""], [8, ""], [9, "connection = MySQLdb.connect (host = \"localhost\", user = username, passwd = password)"], [10, ""], [17, "connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"]]}, "added_lines": 5, "deleted_lines": 6, "source_code": "#!/usr/bin/python\n\nimport MySQLdb\nimport sys\nimport os\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\nimport credentials\n\nconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password)\ncursor = connection.cursor ()\n\ncursor.execute (\"\"\"\nCREATE DATABASE recon;\n\"\"\")\n\nconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\ncursor = connection.cursor ()\n\ncursor.execute (\"\"\"\nCREATE TABLE domains\n(\n    DomainID int NOT NULL AUTO_INCREMENT,\n    Program varchar(255) not null,\n    TopDomainID int default null,\n    Active bit NOT NULL DEFAULT 0,\n    InScope bit NOT NULL DEFAULT 0,\n    Domain varchar(100) not null,\n    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n    scan_Id int,\n    PRIMARY KEY (DomainID),\n    FOREIGN KEY (TopDomainID) REFERENCES domains(DomainID),\n    UNIQUE (Domain)\n);\n\"\"\")\n\ncursor.execute (\"\"\"\nCREATE TABLE errors\n(\n    ErrorID int NOT NULL AUTO_INCREMENT,\n    Domain varchar(255),\n    ErrorDescription varchar(255),\n    Error varchar(255),\n    Script varchar(255),\n    ErrorDate timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n    scan_ID int,\n    PRIMARY KEY (ErrorID)\n);\n\"\"\")\n\n\ncursor.execute (\"\"\"\nCREATE TABLE scans \n( \n\tScanID int NOT NULL AUTO_INCREMENT, \n\tStartDate datetime NOT NULL, \n\tEndDate datetime, \n\tprimary key (ScanID) \n);\n\"\"\")\n\ncursor.close ()\nconnection.close ()\nsys.exit()\n", "source_code_before": "#!/usr/bin/python\n\nimport MySQLdb\nimport sys\n\nusername = \"rjp\"\npassword = \"1484\"\n\nconnection = MySQLdb.connect (host = \"localhost\", user = username, passwd = password)\n\ncursor = connection.cursor ()\n\ncursor.execute (\"\"\"\nCREATE DATABASE recon;\n\"\"\")\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\ncursor = connection.cursor ()\n\ncursor.execute (\"\"\"\nCREATE TABLE domains\n(\n    DomainID int NOT NULL AUTO_INCREMENT,\n    Program varchar(255) not null,\n    TopDomainID int default null,\n    Active bit NOT NULL DEFAULT 0,\n    InScope bit NOT NULL DEFAULT 0,\n    Domain varchar(100) not null,\n    LastModified timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n    scan_Id int,\n    PRIMARY KEY (DomainID),\n    FOREIGN KEY (TopDomainID) REFERENCES domains(DomainID),\n    UNIQUE (Domain)\n);\n\"\"\")\n\ncursor.execute (\"\"\"\nCREATE TABLE errors\n(\n    ErrorID int NOT NULL AUTO_INCREMENT,\n    Domain varchar(255),\n    ErrorDescription varchar(255),\n    Error varchar(255),\n    Script varchar(255),\n    ErrorDate timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,\n    scan_ID int,\n    PRIMARY KEY (ErrorID)\n);\n\"\"\")\n\n\ncursor.execute (\"\"\"\nCREATE TABLE scans \n( \n\tScanID int NOT NULL AUTO_INCREMENT, \n\tStartDate datetime NOT NULL, \n\tEndDate datetime, \n\tprimary key (ScanID) \n);\n\"\"\")\n\ncursor.close ()\nconnection.close ()\nsys.exit()\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": 53, "complexity": 0, "token_count": 139}, {"old_path": "install.sh", "new_path": "install.sh", "filename": "install.sh", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -1,10 +1,42 @@\n #!/usr/bin/env bash\n \n-# Install sublis3r\n+echo \"[+] Installing sublist3r\"\n git clone https://github.com/aboul3la/Sublist3r.git tools/dependencies/sublister\n \n echo \"----------------------------------------------------------------\"\n-echo \"[+] Creating database 'recon' with tables 'domains' and 'errors'\"\n+\n+echo \"[?] Do you want to pip install the requirements.txt?\"\n+echo \"[Y/n]\"\n+read choice_pip_requirements\n+\n+if [ $choice_pip_requirements = \"Y\" ] || [ $choice_pip_requirements = \"y\" ] || [ -z $choice_pip_requirements ]; then\n+        pip install -r requirements.txt\n+else\n+\techo\"[!] Make sure you have the right modules installed. You can check which modules are used in requirements.txt\"\n+fi\n+\n+echo \"----------------------------------------------------------------\"\n+\n+echo \"[?] What is the database username?\"\n+read database_username\n+\n+echo \"[?] What is the database password?\"\n+read database_password\n+\n+echo \"[?] What is the database server? e.g. localhost (most common), if it runs on the same server.\"\n+read database_server\n+\n+echo \"\n+database_username = \\\"$database_username\\\"\n+database_password = \\\"$database_password\\\"\n+database_server = \\\"$database_server\\\"\n+database_name = \\\"recon\\\"\n+\n+telegram_bot_token = \\\"\\\"\n+telegram_chat_id = \\\"\\\"\n+\" > \"credentials.py\"\n+\n+echo \"[+] Creating database 'recon' with tables 'domains', scans and 'errors'\"\n python database/init_db.py\n \n echo \"[+] Checking if the database was created successfully\"\n@@ -21,4 +53,11 @@ crontab mycron\n rm mycron\n \n echo \"[!] All set!\"\n-echo \"[!] Now lets run main.py to get started with adding domains\"\n+echo \"[+] If you want to use the telegram options, please add your telegram bot token in credentials.py.\"\n+echo \"[?] Do you want to run main.py? This script lets you manage your domains.\"\n+echo \"[Y/n]\"\n+read choice_main\n+\n+if [ $choice_main = \"Y\" ] || [ $choice_main = \"y\" ] || [ -z $choice_main ]; then\n+\tpython main.py\n+fi\n", "diff_parsed": {"added": [[3, "echo \"[+] Installing sublist3r\""], [7, ""], [8, "echo \"[?] Do you want to pip install the requirements.txt?\""], [9, "echo \"[Y/n]\""], [10, "read choice_pip_requirements"], [11, ""], [12, "if [ $choice_pip_requirements = \"Y\" ] || [ $choice_pip_requirements = \"y\" ] || [ -z $choice_pip_requirements ]; then"], [13, "        pip install -r requirements.txt"], [14, "else"], [15, "\techo\"[!] Make sure you have the right modules installed. You can check which modules are used in requirements.txt\""], [16, "fi"], [17, ""], [18, "echo \"----------------------------------------------------------------\""], [19, ""], [20, "echo \"[?] What is the database username?\""], [21, "read database_username"], [22, ""], [23, "echo \"[?] What is the database password?\""], [24, "read database_password"], [25, ""], [26, "echo \"[?] What is the database server? e.g. localhost (most common), if it runs on the same server.\""], [27, "read database_server"], [28, ""], [29, "echo \""], [30, "database_username = \\\"$database_username\\\""], [31, "database_password = \\\"$database_password\\\""], [32, "database_server = \\\"$database_server\\\""], [33, "database_name = \\\"recon\\\""], [34, ""], [35, "telegram_bot_token = \\\"\\\""], [36, "telegram_chat_id = \\\"\\\""], [37, "\" > \"credentials.py\""], [38, ""], [39, "echo \"[+] Creating database 'recon' with tables 'domains', scans and 'errors'\""], [56, "echo \"[+] If you want to use the telegram options, please add your telegram bot token in credentials.py.\""], [57, "echo \"[?] Do you want to run main.py? This script lets you manage your domains.\""], [58, "echo \"[Y/n]\""], [59, "read choice_main"], [60, ""], [61, "if [ $choice_main = \"Y\" ] || [ $choice_main = \"y\" ] || [ -z $choice_main ]; then"], [62, "\tpython main.py"], [63, "fi"]], "deleted": [[3, "# Install sublis3r"], [7, "echo \"[+] Creating database 'recon' with tables 'domains' and 'errors'\""], [24, "echo \"[!] Now lets run main.py to get started with adding domains\""]]}, "added_lines": 42, "deleted_lines": 3, "source_code": "#!/usr/bin/env bash\n\necho \"[+] Installing sublist3r\"\ngit clone https://github.com/aboul3la/Sublist3r.git tools/dependencies/sublister\n\necho \"----------------------------------------------------------------\"\n\necho \"[?] Do you want to pip install the requirements.txt?\"\necho \"[Y/n]\"\nread choice_pip_requirements\n\nif [ $choice_pip_requirements = \"Y\" ] || [ $choice_pip_requirements = \"y\" ] || [ -z $choice_pip_requirements ]; then\n        pip install -r requirements.txt\nelse\n\techo\"[!] Make sure you have the right modules installed. You can check which modules are used in requirements.txt\"\nfi\n\necho \"----------------------------------------------------------------\"\n\necho \"[?] What is the database username?\"\nread database_username\n\necho \"[?] What is the database password?\"\nread database_password\n\necho \"[?] What is the database server? e.g. localhost (most common), if it runs on the same server.\"\nread database_server\n\necho \"\ndatabase_username = \\\"$database_username\\\"\ndatabase_password = \\\"$database_password\\\"\ndatabase_server = \\\"$database_server\\\"\ndatabase_name = \\\"recon\\\"\n\ntelegram_bot_token = \\\"\\\"\ntelegram_chat_id = \\\"\\\"\n\" > \"credentials.py\"\n\necho \"[+] Creating database 'recon' with tables 'domains', scans and 'errors'\"\npython database/init_db.py\n\necho \"[+] Checking if the database was created successfully\"\npython database/db_test.py\n\necho \"[+] Adding a cron task to run 'run.py' every 12 hours. You can edit this with the command 'crontab -e'\"\necho \"[?] Adding the path to crontab. If this isn't the right path to the file, please edit this with the command 'crontab -e'\"\n#write out current crontab\ncrontab -l > mycron\n#echo new cron into cron file\necho \"0 */12 * * * python $(pwd)/run.py\" >> mycron\n#install new cron file\ncrontab mycron\nrm mycron\n\necho \"[!] All set!\"\necho \"[+] If you want to use the telegram options, please add your telegram bot token in credentials.py.\"\necho \"[?] Do you want to run main.py? This script lets you manage your domains.\"\necho \"[Y/n]\"\nread choice_main\n\nif [ $choice_main = \"Y\" ] || [ $choice_main = \"y\" ] || [ -z $choice_main ]; then\n\tpython main.py\nfi\n", "source_code_before": "#!/usr/bin/env bash\n\n# Install sublis3r\ngit clone https://github.com/aboul3la/Sublist3r.git tools/dependencies/sublister\n\necho \"----------------------------------------------------------------\"\necho \"[+] Creating database 'recon' with tables 'domains' and 'errors'\"\npython database/init_db.py\n\necho \"[+] Checking if the database was created successfully\"\npython database/db_test.py\n\necho \"[+] Adding a cron task to run 'run.py' every 12 hours. You can edit this with the command 'crontab -e'\"\necho \"[?] Adding the path to crontab. If this isn't the right path to the file, please edit this with the command 'crontab -e'\"\n#write out current crontab\ncrontab -l > mycron\n#echo new cron into cron file\necho \"0 */12 * * * python $(pwd)/run.py\" >> mycron\n#install new cron file\ncrontab mycron\nrm mycron\n\necho \"[!] All set!\"\necho \"[!] Now lets run main.py to get started with adding domains\"\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}, {"old_path": "main.py", "new_path": "main.py", "filename": "main.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -1,6 +1,7 @@\n #!/usr/bin/python\n \n import os, sys, MySQLdb, time\n+import credentials\n \n class bcolors:\n     HEADER = '\\033[95m'\n@@ -12,9 +13,11 @@ class bcolors:\n     BOLD = '\\033[1m'\n     UNDERLINE = '\\033[4m'\n \n-connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+connection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n cursor = connection.cursor()\n \n+def exit_program():\n+\tsys.exit()\n \n def list_subdomains():\n \tsub_domain = raw_input('[Domain] > ')\n@@ -80,8 +83,8 @@ def insert_topdomain(top_domain_par = None):\n \tprogram = raw_input('[program] > ')\n \n \tprint \"Inscope? \"\n-\tinscope = raw_input('[Inscope] > ')\n-\tif \"no\" not in inscope.lower():\n+\tinscope = raw_input('[Y/n] > ')\n+\tif \"n\" not in inscope.lower():\n \t\tinscope = 1\n \telse:\n \t\tinscope = 0\n@@ -108,8 +111,8 @@ def insert_subdomain(top_domain_par = None):\n \tif not data:\n     \t\tprint bcolors.WARNING + \"Domain not found!\" + bcolors.ENDC\n \t\tprint \"Do you want to add it? \"\n-\t\tanswer = raw_input('[yes/no] > ')\n-\t\tif \"no\" not in answer.lower():\n+\t\tanswer = raw_input('[Y/n] > ')\n+\t\tif \"n\" not in answer.lower():\n \t\t\tinsert_topdomain(top_domain)\n \t\telse:\n \t\t\traw_input(\"Press any key to go back...\")\n@@ -134,8 +137,8 @@ def insert_subdomain(top_domain_par = None):\n \n \tif does_not_exist:\n \t\tprint \"Inscope? \"\n-\t\tinscope = raw_input('[Inscope] > ')\n-\t\tif \"no\" not in inscope.lower():\n+\t\tinscope = raw_input('[Y/n] > ')\n+\t\tif \"n\" not in inscope.lower():\n \t\t\tinscope = 1\n \t\telse:\n \t\t\tinscope = 0\n@@ -146,8 +149,8 @@ def insert_subdomain(top_domain_par = None):\n \t\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n \n \tprint \"Do you want to add another one?? \"\n-\tanother_one = raw_input('[yes/no] > ')\n-\tif \"no\" not in another_one.lower():\n+\tanother_one = raw_input('[Y/n] > ')\n+\tif \"n\" not in another_one.lower():\n \n \t\tinsert_subdomain(top_domain)\n \n@@ -177,7 +180,8 @@ options = {1 : insert_topdomain,\n            3 : list_domains,\n            4 : insert_subdomain,\n \t   5 : run_subdomain_scan_on_target,\n-\t   6 : delete_top_domain\n+\t   6 : delete_top_domain,\n+           7 : exit_program\n }\n \n \n@@ -206,6 +210,7 @@ def start():\n 4. Add subdomain\n 5. Run subdomain scan on top domain\n 6. Delete a (top)domain\n+7. Exit\n \"\"\"\n \n \tprint banner.format(bcolors.HEADER, domains, sub_domains, top_domains, bcolors.ENDC)\n", "diff_parsed": {"added": [[4, "import credentials"], [16, "connection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)"], [19, "def exit_program():"], [20, "\tsys.exit()"], [86, "\tinscope = raw_input('[Y/n] > ')"], [87, "\tif \"n\" not in inscope.lower():"], [114, "\t\tanswer = raw_input('[Y/n] > ')"], [115, "\t\tif \"n\" not in answer.lower():"], [140, "\t\tinscope = raw_input('[Y/n] > ')"], [141, "\t\tif \"n\" not in inscope.lower():"], [152, "\tanother_one = raw_input('[Y/n] > ')"], [153, "\tif \"n\" not in another_one.lower():"], [183, "\t   6 : delete_top_domain,"], [184, "           7 : exit_program"], [213, "7. Exit"]], "deleted": [[15, "connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [83, "\tinscope = raw_input('[Inscope] > ')"], [84, "\tif \"no\" not in inscope.lower():"], [111, "\t\tanswer = raw_input('[yes/no] > ')"], [112, "\t\tif \"no\" not in answer.lower():"], [137, "\t\tinscope = raw_input('[Inscope] > ')"], [138, "\t\tif \"no\" not in inscope.lower():"], [149, "\tanother_one = raw_input('[yes/no] > ')"], [150, "\tif \"no\" not in another_one.lower():"], [180, "\t   6 : delete_top_domain"]]}, "added_lines": 15, "deleted_lines": 10, "source_code": "#!/usr/bin/python\n\nimport os, sys, MySQLdb, time\nimport credentials\n\nclass bcolors:\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n\nconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\ncursor = connection.cursor()\n\ndef exit_program():\n\tsys.exit()\n\ndef list_subdomains():\n\tsub_domain = raw_input('[Domain] > ')\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (sub_domain,))\n\tdata = cursor.fetchall()\n\n\tfor row in data:\n\t\tif ord(row[1]):\n\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n\t\telse:\n\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\ndef run_subdomain_scan_on_target(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the domain?\"\n\t\ttop_domain = raw_input('[Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__)) + \"/database/additional_tools/sublister_to_db.py \" + top_domain + \" NULL\")\n\ndef delete_top_domain():\n\tprint \"What is the domain? \"\n\ttop_domain = raw_input('[Domain] > ')\n\n        cursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n        data = cursor.fetchone()\n\n\ttop_domain = int(data[0])\n\n        cursor.execute(\"delete from domains where topDomainID = %s\", (top_domain,))\n        connection.commit()\n\n        cursor.execute(\"delete from domains where DomainID = %s\", (top_domain,))\n        connection.commit()\n\n        print bcolors.OKGREEN + \"Domain with its subdomains deleted\" + bcolors.ENDC\n        raw_input(\"\\nPress any key to go back...\")\n        start()\n\n\ndef insert_topdomain(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the domain? \"\n\t\ttop_domain = raw_input('[Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n\tdata = cursor.fetchone()  \n\n\tif data:\n    \t\tprint bcolors.WARNING + \"Domains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n\t\traw_input(\"Press any key to go back...\")\n\t\tstart()\n\t\n\n\tprint \"What is the program? \"\n\tprogram = raw_input('[program] > ')\n\n\tprint \"Inscope? \"\n\tinscope = raw_input('[Y/n] > ')\n\tif \"n\" not in inscope.lower():\n\t\tinscope = 1\n\telse:\n\t\tinscope = 0\n\t\n\n\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active) VALUES (%s, %s, %s, %s)\", (program, inscope, top_domain, 1))\n\tconnection.commit()\n\t\n\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\ndef insert_subdomain(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the (top)domain? \"\n\t\ttop_domain = raw_input('[(Top)Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n\tdata = cursor.fetchone()  \n\n\tif not data:\n    \t\tprint bcolors.WARNING + \"Domain not found!\" + bcolors.ENDC\n\t\tprint \"Do you want to add it? \"\n\t\tanswer = raw_input('[Y/n] > ')\n\t\tif \"n\" not in answer.lower():\n\t\t\tinsert_topdomain(top_domain)\n\t\telse:\n\t\t\traw_input(\"Press any key to go back...\")\n\t\t\tstart()\n\n\tprogram = str(data[1])\n\ttopdomainid = int(data[0])\n\n\n\n\tprint \"What is the subdomain? \"\n\tsub_domain = raw_input('[(Subdomain] > ')\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (sub_domain,))\n\tdata = cursor.fetchone()  \n\n\tif data:\n    \t\tprint bcolors.WARNING + \"Subdomains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n\t\tdoes_not_exist = False\n\telse:\n\t\tdoes_not_exist = True\n\n\tif does_not_exist:\n\t\tprint \"Inscope? \"\n\t\tinscope = raw_input('[Y/n] > ')\n\t\tif \"n\" not in inscope.lower():\n\t\t\tinscope = 1\n\t\telse:\n\t\t\tinscope = 0\n\n\t\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active, TopDomainID) VALUES (%s, %s, %s, %s, %s)\", (program, inscope, sub_domain, 1, topdomainid))\n\t\tconnection.commit()\n\t\t\n\t\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n\n\tprint \"Do you want to add another one?? \"\n\tanother_one = raw_input('[Y/n] > ')\n\tif \"n\" not in another_one.lower():\n\n\t\tinsert_subdomain(top_domain)\n\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\n\ndef list_domains():\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID is NULL\")\n\tdata = cursor.fetchall()\n\n\tfor row in data:\n\t\tif ord(row[1]):\n\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n\t\telse:\n\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n\t\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\n\n\noptions = {1 : insert_topdomain,\n           2 : list_subdomains,\n           3 : list_domains,\n           4 : insert_subdomain,\n\t   5 : run_subdomain_scan_on_target,\n\t   6 : delete_top_domain,\n           7 : exit_program\n}\n\n\ndef start():\n\tos.system('clear')\n\tcursor.execute (\"select count(*) from domains where TopDomainID is NULL;\")\n\tdata = cursor.fetchall()\n\tsub_domains = data[0][0]\n\n\tcursor.execute (\"select count(TopDomainID) from domains\")\n\tdata = cursor.fetchall()\n\ttop_domains = data[0][0]\n\n\tdomains = top_domains + sub_domains\n\n\tbanner = \"\"\" {0}---------------+-------\n Domains       | {1}   \n Top-domains   | {2}  \n Sudomains     | {3}   \n---------------+-------{4}\"\"\"\n\n\tchoices = \"\"\"\n1. Add domain\n2. List subdomains from domain\n3. List all (top)domains\n4. Add subdomain\n5. Run subdomain scan on top domain\n6. Delete a (top)domain\n7. Exit\n\"\"\"\n\n\tprint banner.format(bcolors.HEADER, domains, sub_domains, top_domains, bcolors.ENDC)\n\n\tprint choices.format()\n\n\ttry:\n\t\tnum = raw_input('> ')\n\t\tnum = int(num)\n\texcept:\n\t\tprint \"Provide a number please,\"\n\t\traw_input(\"\\nPress any key to go back...\")\n\t\tstart()\n\t\tstart()\n\n\toptions[num]()\n\n\nstart()\ncursor.close ()\nconnection.close ()\nsys.exit()\n", "source_code_before": "#!/usr/bin/python\n\nimport os, sys, MySQLdb, time\n\nclass bcolors:\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\ncursor = connection.cursor()\n\n\ndef list_subdomains():\n\tsub_domain = raw_input('[Domain] > ')\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (sub_domain,))\n\tdata = cursor.fetchall()\n\n\tfor row in data:\n\t\tif ord(row[1]):\n\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n\t\telse:\n\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\ndef run_subdomain_scan_on_target(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the domain?\"\n\t\ttop_domain = raw_input('[Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__)) + \"/database/additional_tools/sublister_to_db.py \" + top_domain + \" NULL\")\n\ndef delete_top_domain():\n\tprint \"What is the domain? \"\n\ttop_domain = raw_input('[Domain] > ')\n\n        cursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n        data = cursor.fetchone()\n\n\ttop_domain = int(data[0])\n\n        cursor.execute(\"delete from domains where topDomainID = %s\", (top_domain,))\n        connection.commit()\n\n        cursor.execute(\"delete from domains where DomainID = %s\", (top_domain,))\n        connection.commit()\n\n        print bcolors.OKGREEN + \"Domain with its subdomains deleted\" + bcolors.ENDC\n        raw_input(\"\\nPress any key to go back...\")\n        start()\n\n\ndef insert_topdomain(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the domain? \"\n\t\ttop_domain = raw_input('[Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n\tdata = cursor.fetchone()  \n\n\tif data:\n    \t\tprint bcolors.WARNING + \"Domains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n\t\traw_input(\"Press any key to go back...\")\n\t\tstart()\n\t\n\n\tprint \"What is the program? \"\n\tprogram = raw_input('[program] > ')\n\n\tprint \"Inscope? \"\n\tinscope = raw_input('[Inscope] > ')\n\tif \"no\" not in inscope.lower():\n\t\tinscope = 1\n\telse:\n\t\tinscope = 0\n\t\n\n\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active) VALUES (%s, %s, %s, %s)\", (program, inscope, top_domain, 1))\n\tconnection.commit()\n\t\n\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\ndef insert_subdomain(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the (top)domain? \"\n\t\ttop_domain = raw_input('[(Top)Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n\tdata = cursor.fetchone()  \n\n\tif not data:\n    \t\tprint bcolors.WARNING + \"Domain not found!\" + bcolors.ENDC\n\t\tprint \"Do you want to add it? \"\n\t\tanswer = raw_input('[yes/no] > ')\n\t\tif \"no\" not in answer.lower():\n\t\t\tinsert_topdomain(top_domain)\n\t\telse:\n\t\t\traw_input(\"Press any key to go back...\")\n\t\t\tstart()\n\n\tprogram = str(data[1])\n\ttopdomainid = int(data[0])\n\n\n\n\tprint \"What is the subdomain? \"\n\tsub_domain = raw_input('[(Subdomain] > ')\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (sub_domain,))\n\tdata = cursor.fetchone()  \n\n\tif data:\n    \t\tprint bcolors.WARNING + \"Subdomains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n\t\tdoes_not_exist = False\n\telse:\n\t\tdoes_not_exist = True\n\n\tif does_not_exist:\n\t\tprint \"Inscope? \"\n\t\tinscope = raw_input('[Inscope] > ')\n\t\tif \"no\" not in inscope.lower():\n\t\t\tinscope = 1\n\t\telse:\n\t\t\tinscope = 0\n\n\t\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active, TopDomainID) VALUES (%s, %s, %s, %s, %s)\", (program, inscope, sub_domain, 1, topdomainid))\n\t\tconnection.commit()\n\t\t\n\t\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n\n\tprint \"Do you want to add another one?? \"\n\tanother_one = raw_input('[yes/no] > ')\n\tif \"no\" not in another_one.lower():\n\n\t\tinsert_subdomain(top_domain)\n\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\n\ndef list_domains():\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID is NULL\")\n\tdata = cursor.fetchall()\n\n\tfor row in data:\n\t\tif ord(row[1]):\n\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n\t\telse:\n\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n\t\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\n\n\noptions = {1 : insert_topdomain,\n           2 : list_subdomains,\n           3 : list_domains,\n           4 : insert_subdomain,\n\t   5 : run_subdomain_scan_on_target,\n\t   6 : delete_top_domain\n}\n\n\ndef start():\n\tos.system('clear')\n\tcursor.execute (\"select count(*) from domains where TopDomainID is NULL;\")\n\tdata = cursor.fetchall()\n\tsub_domains = data[0][0]\n\n\tcursor.execute (\"select count(TopDomainID) from domains\")\n\tdata = cursor.fetchall()\n\ttop_domains = data[0][0]\n\n\tdomains = top_domains + sub_domains\n\n\tbanner = \"\"\" {0}---------------+-------\n Domains       | {1}   \n Top-domains   | {2}  \n Sudomains     | {3}   \n---------------+-------{4}\"\"\"\n\n\tchoices = \"\"\"\n1. Add domain\n2. List subdomains from domain\n3. List all (top)domains\n4. Add subdomain\n5. Run subdomain scan on top domain\n6. Delete a (top)domain\n\"\"\"\n\n\tprint banner.format(bcolors.HEADER, domains, sub_domains, top_domains, bcolors.ENDC)\n\n\tprint choices.format()\n\n\ttry:\n\t\tnum = raw_input('> ')\n\t\tnum = int(num)\n\texcept:\n\t\tprint \"Provide a number please,\"\n\t\traw_input(\"\\nPress any key to go back...\")\n\t\tstart()\n\t\tstart()\n\n\toptions[num]()\n\n\nstart()\ncursor.close ()\nconnection.close ()\nsys.exit()\n", "methods": [{"name": "exit_program", "start_line": 19, "end_line": 20}, {"name": "list_subdomains", "start_line": 22, "end_line": 34}, {"name": "run_subdomain_scan_on_target", "start_line": 37, "end_line": 44}, {"name": "delete_top_domain", "start_line": 46, "end_line": 63}, {"name": "insert_topdomain", "start_line": 66, "end_line": 98}, {"name": "insert_subdomain", "start_line": 101, "end_line": 158}, {"name": "list_domains", "start_line": 162, "end_line": 173}, {"name": "start", "start_line": 188, "end_line": 229}], "methods_before": [{"name": "list_subdomains", "start_line": 19, "end_line": 31}, {"name": "run_subdomain_scan_on_target", "start_line": 34, "end_line": 41}, {"name": "delete_top_domain", "start_line": 43, "end_line": 60}, {"name": "insert_topdomain", "start_line": 63, "end_line": 95}, {"name": "insert_subdomain", "start_line": 98, "end_line": 155}, {"name": "list_domains", "start_line": 159, "end_line": 170}, {"name": "start", "start_line": 184, "end_line": 224}], "changed_methods": [{"name": "insert_subdomain", "start_line": 101, "end_line": 158}, {"name": "insert_topdomain", "start_line": 66, "end_line": 98}, {"name": "exit_program", "start_line": 19, "end_line": 20}, {"name": "start", "start_line": 188, "end_line": 229}], "nloc": 171, "complexity": 24, "token_count": 963}, {"old_path": null, "new_path": "requirements.txt", "filename": "requirements.txt", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1,15 @@\n+mysql-python==1.2.3\n+telegram==0.0.1\n+python-telegram-bot==10.0.1\n+\n+\n+# All the modules used are:\n+\n+# MySQLdb\n+# telegram\n+# random\n+# sys\n+# os\n+# datetime\n+# logging\n+# time\n", "diff_parsed": {"added": [[1, "mysql-python==1.2.3"], [2, "telegram==0.0.1"], [3, "python-telegram-bot==10.0.1"], [4, ""], [5, ""], [6, "# All the modules used are:"], [7, ""], [8, "# MySQLdb"], [9, "# telegram"], [10, "# random"], [11, "# sys"], [12, "# os"], [13, "# datetime"], [14, "# logging"], [15, "# time"]], "deleted": []}, "added_lines": 15, "deleted_lines": 0, "source_code": "mysql-python==1.2.3\ntelegram==0.0.1\npython-telegram-bot==10.0.1\n\n\n# All the modules used are:\n\n# MySQLdb\n# telegram\n# random\n# sys\n# os\n# datetime\n# logging\n# time\n", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}, {"old_path": "run.py", "new_path": "run.py", "filename": "run.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -1,8 +1,8 @@\n #!/usr/bin/python\n try:\n-\timport sys, os, MySQLdb, datetime\n+\timport sys, os, MySQLdb, datetime, credentials\n \n-\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n \tcursor = connection.cursor ()\n \n \tcursor.execute (\"insert into scans (StartDate) values (CURRENT_TIMESTAMP)\")\n@@ -14,9 +14,9 @@ try:\n \n \tfor row in data:\n \t\tprint \"Running sublister on \" + row[0]\n-\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/database/additional_tools/sublister_to_db.py \" + row[0] + \" \" + str(scanId))\n+\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/database/additional_tools/domains_db.py \" + row[0] + \" \" + str(scanId))\n \n-\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n \tcursor = connection.cursor ()\n \tcursor.execute (\"update scans set EndDate = CURRENT_TIMESTAMP where ScanID = %s\", (scanId))\n \tconnection.commit()\n@@ -25,5 +25,9 @@ try:\n \tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/telegram/notify.py \" + str(scanId))\n except Exception, e:\n \tprint \"error: \" + str(e)\n+\n+\tif not os.path.exists(os.path.dirname(os.path.abspath(__file__))  + \"/logs\"):\n+                os.makedirs(os.path.dirname(os.path.abspath(__file__))  + \"/logs\")\n+\n \twith open(os.path.dirname(os.path.abspath(__file__))  + '/logs/run_logs.txt', 'w+') as the_file:\n \t\tthe_file.write(str(e) + \"\\n\")\n", "diff_parsed": {"added": [[3, "\timport sys, os, MySQLdb, datetime, credentials"], [5, "\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)"], [17, "\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/database/additional_tools/domains_db.py \" + row[0] + \" \" + str(scanId))"], [19, "\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)"], [28, ""], [29, "\tif not os.path.exists(os.path.dirname(os.path.abspath(__file__))  + \"/logs\"):"], [30, "                os.makedirs(os.path.dirname(os.path.abspath(__file__))  + \"/logs\")"], [31, ""]], "deleted": [[3, "\timport sys, os, MySQLdb, datetime"], [5, "\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [17, "\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/database/additional_tools/sublister_to_db.py \" + row[0] + \" \" + str(scanId))"], [19, "\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"]]}, "added_lines": 8, "deleted_lines": 4, "source_code": "#!/usr/bin/python\ntry:\n\timport sys, os, MySQLdb, datetime, credentials\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tcursor.execute (\"insert into scans (StartDate) values (CURRENT_TIMESTAMP)\")\n\tconnection.commit()\n\tscanId = cursor.lastrowid\n\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\n\tdata = cursor.fetchall ()\n\tconnection.close()\n\n\tfor row in data:\n\t\tprint \"Running sublister on \" + row[0]\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/database/additional_tools/domains_db.py \" + row[0] + \" \" + str(scanId))\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\tcursor.execute (\"update scans set EndDate = CURRENT_TIMESTAMP where ScanID = %s\", (scanId))\n\tconnection.commit()\n\tconnection.close()\n\n\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/telegram/notify.py \" + str(scanId))\nexcept Exception, e:\n\tprint \"error: \" + str(e)\n\n\tif not os.path.exists(os.path.dirname(os.path.abspath(__file__))  + \"/logs\"):\n                os.makedirs(os.path.dirname(os.path.abspath(__file__))  + \"/logs\")\n\n\twith open(os.path.dirname(os.path.abspath(__file__))  + '/logs/run_logs.txt', 'w+') as the_file:\n\t\tthe_file.write(str(e) + \"\\n\")\n", "source_code_before": "#!/usr/bin/python\ntry:\n\timport sys, os, MySQLdb, datetime\n\n\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\tcursor = connection.cursor ()\n\n\tcursor.execute (\"insert into scans (StartDate) values (CURRENT_TIMESTAMP)\")\n\tconnection.commit()\n\tscanId = cursor.lastrowid\n\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\n\tdata = cursor.fetchall ()\n\tconnection.close()\n\n\tfor row in data:\n\t\tprint \"Running sublister on \" + row[0]\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/database/additional_tools/sublister_to_db.py \" + row[0] + \" \" + str(scanId))\n\n\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\tcursor = connection.cursor ()\n\tcursor.execute (\"update scans set EndDate = CURRENT_TIMESTAMP where ScanID = %s\", (scanId))\n\tconnection.commit()\n\tconnection.close()\n\n\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/telegram/notify.py \" + str(scanId))\nexcept Exception, e:\n\tprint \"error: \" + str(e)\n\twith open(os.path.dirname(os.path.abspath(__file__))  + '/logs/run_logs.txt', 'w+') as the_file:\n\t\tthe_file.write(str(e) + \"\\n\")\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": 25, "complexity": 0, "token_count": 315}, {"old_path": "telegram/bot.py", "new_path": "telegram/bot.py", "filename": "bot.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -1,23 +1,30 @@\n #!/usr/bin/env python\n # -*- coding: utf-8 -*-\n \n-import logging, datetime, MySQLdb, os, telegram\n+import logging, datetime, MySQLdb, os, telegram, sys\n from telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\n from telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\n from random import randint\n+sys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\n+import credentials\n+\n \n # Enable logging\n logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n \t\t\t\t\tlevel=logging.INFO)\n \n-telegram_bot_token = \"576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI\"\n-\n+telegram_bot_token = credentials.telegram_bot_token\n \n logger = logging.getLogger(__name__)\n \n BUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n \n def start(bot, update):\n+\tprint \"---------- Start -----------\"\n+\tif str(update.message.chat_id) != str(credentials.telegram_chat_id):\n+\t\tupdate.message.reply_text(\"Not authorized! If you think this is a mistake, please check if your chat_id is in credentials.py. You can also run setup.py in /telegram to setup the right credentials for your telegram.\")\n+\t\treturn\n+\n \tuser = update.message.from_user\n \thour = datetime.datetime.now().hour\n \tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])\n@@ -35,8 +42,6 @@ def start(bot, update):\n def button(bot, update):\n \tquery = update.callback_query\n \t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button\n-\n-\tprint \"button func called with: \" + query.data\n \tchoice = query.data.split('-')[0]\n \tr = str(randint(0, 99))\n \n@@ -85,6 +90,7 @@ def button(bot, update):\n \t\treturn BUTTON\n \telif choice == \"close\":\n \t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)\n+\t\treturn ConversationHandler.END\n \telif choice == \"scan\":\n \t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n \t\treturn BUTTON\n@@ -92,7 +98,7 @@ def button(bot, update):\n \t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n \t\treturn BUTTON\n \n-\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n \tcursor = connection.cursor ()\n \n \tif choice == \"latest\":\n@@ -221,18 +227,22 @@ def run_scan(bot, update, cursor):\n \tquery = update.callback_query\n \tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")\n \tdata = cursor.fetchall()\n-\tif data[0][2] != None:\n+\ttry:\n+\t\tif data[0][2] != None:\n+\t\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n+\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n+\t\telse:\n+\t\t\tr = str(randint(0, 99))\n+\t        \theader_4 = \"It looks like a scan is already running. Want to start a new one?\"\n+        \t\tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n+                \t\t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n+                        \t\t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n+\t\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n+\t\t\treturn BUTTON\n+\texcept Exception, e:\n+\t\tprint \"error: \" + str(e)\n \t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n-\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n-\telse:\n-\t\tr = str(randint(0, 99))\n-\t        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n-        \tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n-                \t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n-                        \t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n-\n-\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n-                return BUTTON\n+\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n \n \n def custom_scan_id_input(bot, update):\n@@ -245,7 +255,7 @@ def custom_scan_id_input(bot, update):\n \t\tupdate.message.reply_text(\"Not a valid number\")\n \telse:\n \t\tprint \"valid number\"\n-        \tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+\t\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n         \tcursor = connection.cursor ()\n \t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))\n \t        data = cursor.fetchall()\n", "diff_parsed": {"added": [[4, "import logging, datetime, MySQLdb, os, telegram, sys"], [8, "sys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")"], [9, "import credentials"], [10, ""], [16, "telegram_bot_token = credentials.telegram_bot_token"], [23, "\tprint \"---------- Start -----------\""], [24, "\tif str(update.message.chat_id) != str(credentials.telegram_chat_id):"], [25, "\t\tupdate.message.reply_text(\"Not authorized! If you think this is a mistake, please check if your chat_id is in credentials.py. You can also run setup.py in /telegram to setup the right credentials for your telegram.\")"], [26, "\t\treturn"], [27, ""], [93, "\t\treturn ConversationHandler.END"], [101, "\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)"], [230, "\ttry:"], [231, "\t\tif data[0][2] != None:"], [232, "\t\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)"], [233, "\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")"], [234, "\t\telse:"], [235, "\t\t\tr = str(randint(0, 99))"], [236, "\t        \theader_4 = \"It looks like a scan is already running. Want to start a new one?\""], [237, "        \t\tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),"], [238, "                \t\t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],"], [239, "                        \t\t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]"], [240, "\t\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)"], [241, "\t\t\treturn BUTTON"], [242, "\texcept Exception, e:"], [243, "\t\tprint \"error: \" + str(e)"], [245, "\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")"], [258, "\t\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)"]], "deleted": [[4, "import logging, datetime, MySQLdb, os, telegram"], [13, "telegram_bot_token = \"576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI\""], [14, ""], [38, ""], [39, "\tprint \"button func called with: \" + query.data"], [95, "\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [224, "\tif data[0][2] != None:"], [226, "\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")"], [227, "\telse:"], [228, "\t\tr = str(randint(0, 99))"], [229, "\t        header_4 = \"It looks like a scan is already running. Want to start a new one?\""], [230, "        \tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),"], [231, "                \t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],"], [232, "                        \t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]"], [233, ""], [234, "\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)"], [235, "                return BUTTON"], [248, "        \tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"]]}, "added_lines": 28, "deleted_lines": 18, "source_code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport logging, datetime, MySQLdb, os, telegram, sys\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nfrom random import randint\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\nimport credentials\n\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\ntelegram_bot_token = credentials.telegram_bot_token\n\nlogger = logging.getLogger(__name__)\n\nBUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n\ndef start(bot, update):\n\tprint \"---------- Start -----------\"\n\tif str(update.message.chat_id) != str(credentials.telegram_chat_id):\n\t\tupdate.message.reply_text(\"Not authorized! If you think this is a mistake, please check if your chat_id is in credentials.py. You can also run setup.py in /telegram to setup the right credentials for your telegram.\")\n\t\treturn\n\n\tuser = update.message.from_user\n\thour = datetime.datetime.now().hour\n\tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])\n\n\tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n\treply_markup = InlineKeyboardMarkup(keyboard)\n\tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n\tprint \"button before\"\n\treturn BUTTON\n\n\ndef button(bot, update):\n\tquery = update.callback_query\n\t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button\n\tchoice = query.data.split('-')[0]\n\tr = str(randint(0, 99))\n\n\theader_1 = \"Catagory:\"\n\tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + r)]]\n\n\theader_2 = \"Action:\"\n\tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n\t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n\t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n\theader_3 = \"Action:\"\n\tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n\t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n\t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n        header_5 = \"Action:\"\n        keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n                         InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n\t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]\n\n        header_6 = \"Which type of domains?\"\n        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='all-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n\n        header_7 = \"How many domains?\"\n        keyboard_7 = [[InlineKeyboardButton(\"Top 20\", callback_data='limit-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='nolimit-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_data-' + r)]]\n\n\n\t#ToDO: Transform into a swtich\n\tif choice == \"back\":\n\t\tbot.edit_message_text(header_1, reply_markup=InlineKeyboardMarkup(keyboard_1), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"close\":\n\t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn ConversationHandler.END\n\telif choice == \"scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"data\":\n\t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif choice == \"latest\":\n\t\tget_latest_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\telif choice == \"custom\":\n\t\tget_custom_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\t\treturn CUSTOM_SCAN_ID_INPUT\n\telif choice == \"run\":\n\t\trun_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\n        if choice == \"add\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\treturn ADD_DOMAIN\n        elif choice == \"edit\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return EDIT_DOMAIN\n        elif choice == \"get\":\n                cursor.close()\n                connection.close()\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"topdomais\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = False\n\t\treturn BUTTON\n        elif choice == \"subdomains\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = True\n\t\treturn BUTTON\n        elif choice == \"contains\":\n\t\tbot.send_message(text=\"What is the search string?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return CONTAINS\n        elif choice == \"back_data\":\n                bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"back_get\":\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"active\":\n\t\tglobal active\n\t\tactive = True\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n        elif choice == \"all\":\n                global active\n                active = False\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"nolimit\":\n\t\tglobal subdomains\n\t\tif subdomains:\n                        global limit\n                        limit = False\n\t\t\tbot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\treturn GET_DOMAINS\n\t\telse:\n\t\t\tglobal limit\n\t\t\tlimit = False\n\t\t\tget_topdomains()\n        elif choice == \"limit\":\n                global subdomains\n                if subdomains:\n                        global limit\n                        limit = True\n                        bot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                        return GET_DOMAINS\n                else:\n                        global limit\n                        limit = True\n\t\t\tget_topdomains()\n\n\tif choice == \"yes_scan\":\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telif choice == \"back_scan\" or choice == \"no_scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\ndef get_latest_scan(bot, update, cursor):\n\tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))\n\telse:\n\t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\n\ndef get_custom_scan(bot, update, cursor):\n\tquery = update.callback_query\n\n\tcursor.execute (\"SELECT ScanID FROM scans where EndDate is not null ORDER BY ScanID DESC LIMIT 10\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tlatestScanIds = sorted([str(x[0]) for x in data])\n\t\tfirstRow = latestScanIds[:len(latestScanIds)/2]\n\t\tsecondRow = latestScanIds[len(latestScanIds)/2:]\n\t\tcustom_keyboard = [firstRow, secondRow]\n\t\treply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\n\n\t\tif data:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\ttext=\"Which scan ID? \\n/cancel to cancel\",\n\t\t\t\treply_markup=reply_markup, ForceReply = True)\n\t\telse:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\t text=\"Which scan ID? \\n/cancel to cancel\")\n\n\ndef run_scan(bot, update, cursor):\n\tquery = update.callback_query\n\tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")\n\tdata = cursor.fetchall()\n\ttry:\n\t\tif data[0][2] != None:\n\t\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\t\telse:\n\t\t\tr = str(randint(0, 99))\n\t        \theader_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        \t\tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                \t\t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        \t\t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\t\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\t\treturn BUTTON\n\texcept Exception, e:\n\t\tprint \"error: \" + str(e)\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\n\ndef custom_scan_id_input(bot, update):\n\tprint \"inside input method with data: \" + update.message.text\n\tcustomId = update.message.text\n\ttry:\n\t\tint(customId)\n\texcept ValueError:\n\t\tprint \"invalid number\"\n\t\tupdate.message.reply_text(\"Not a valid number\")\n\telse:\n\t\tprint \"valid number\"\n\t\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n        \tcursor = connection.cursor ()\n\t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))\n\t        data = cursor.fetchall()\n\t\tcursor.close()\n\t\tconnection.close()\n\t\tif data:\n\t\t\tprint \"scan ID was found in the db\"\n\t\t\tprint \"data[0][0] is: \" + str(data[0][0])\n\t\t\tif data[0][0] == None:\n\t\t\t\tprint \"EndDate of scan is empty\"\n\t\t\t\tupdate.message.reply_text(\"This scan hasn't finished yet\")\n\t\t\telse:\n\t\t\t\tprint \"Valid scan found\"\n\t\t\t\treply_markup = telegram.ReplyKeyboardRemove()\n\t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)\n\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))\n\t\t\t\treturn ConversationHandler.END\n\t\telse:\n\t\t\tprint \"Scan ID not found in db\"\n\t\t\tupdate.message.reply_text(\"This scan ID doesn't exist\")\n\n\ndef add_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef edit_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef get_domains():\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef domains_contain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef help(bot, update):\n\tupdate.message.reply_text(\"click /start to start :)\")\n\n\ndef error(bot, update, error):\n\tlogger.warning('Update \"%s\" caused error \"%s\"', update, error)\n\t\t\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treply_markup = telegram.ReplyKeyboardRemove()\n\tupdate.message.reply_text(\"canceled! Click or type /start to start again\", reply_markup=reply_markup)\n\treturn ConversationHandler.END\n\n\ndef main():\n\t# Create the EventHandler and pass it your bot's token.\n\tupdater = Updater(telegram_bot_token)\n\n\t# Get the dispatcher to register handlers\n\tdp = updater.dispatcher\n\n\t# Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t\tBUTTON: [CallbackQueryHandler(button),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n\t\t\tCUSTOM_SCAN_ID_INPUT: [MessageHandler(Filters.text, custom_scan_id_input),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n                        ADD_DOMAIN: [MessageHandler(Filters.text, add_domain),\n                                           CommandHandler('cancel', cancel)],\n                        EDIT_DOMAIN: [MessageHandler(Filters.text, edit_domain),\n                                           CommandHandler('cancel', cancel)],\n                        GET_DOMAINS: [MessageHandler(Filters.text, get_domains),\n                                           CommandHandler('cancel', cancel)],\n                        CONTAINS: [MessageHandler(Filters.text, domains_contain),\n                                           CommandHandler('cancel', cancel)]\n\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\n\t# log all errors\n\tdp.add_error_handler(error)\n\n\t# Start the Bot\n\tupdater.start_polling()\n\n\t# Run the bot until you press Ctrl-C or the process receives SIGINT,\n\t# SIGTERM or SIGABRT. This should be used most of the time, since\n\t# start_polling() is non-blocking and will stop the bot gracefully.\n\tupdater.idle()\n\n\nif __name__ == '__main__':\n\tmain()\n", "source_code_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport logging, datetime, MySQLdb, os, telegram\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nfrom random import randint\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\ntelegram_bot_token = \"576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI\"\n\n\nlogger = logging.getLogger(__name__)\n\nBUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n\ndef start(bot, update):\n\tuser = update.message.from_user\n\thour = datetime.datetime.now().hour\n\tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])\n\n\tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n\treply_markup = InlineKeyboardMarkup(keyboard)\n\tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n\tprint \"button before\"\n\treturn BUTTON\n\n\ndef button(bot, update):\n\tquery = update.callback_query\n\t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button\n\n\tprint \"button func called with: \" + query.data\n\tchoice = query.data.split('-')[0]\n\tr = str(randint(0, 99))\n\n\theader_1 = \"Catagory:\"\n\tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + r)]]\n\n\theader_2 = \"Action:\"\n\tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n\t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n\t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n\theader_3 = \"Action:\"\n\tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n\t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n\t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n        header_5 = \"Action:\"\n        keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n                         InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n\t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]\n\n        header_6 = \"Which type of domains?\"\n        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='all-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n\n        header_7 = \"How many domains?\"\n        keyboard_7 = [[InlineKeyboardButton(\"Top 20\", callback_data='limit-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='nolimit-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_data-' + r)]]\n\n\n\t#ToDO: Transform into a swtich\n\tif choice == \"back\":\n\t\tbot.edit_message_text(header_1, reply_markup=InlineKeyboardMarkup(keyboard_1), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"close\":\n\t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)\n\telif choice == \"scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"data\":\n\t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n\tcursor = connection.cursor ()\n\n\tif choice == \"latest\":\n\t\tget_latest_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\telif choice == \"custom\":\n\t\tget_custom_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\t\treturn CUSTOM_SCAN_ID_INPUT\n\telif choice == \"run\":\n\t\trun_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\n        if choice == \"add\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\treturn ADD_DOMAIN\n        elif choice == \"edit\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return EDIT_DOMAIN\n        elif choice == \"get\":\n                cursor.close()\n                connection.close()\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"topdomais\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = False\n\t\treturn BUTTON\n        elif choice == \"subdomains\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = True\n\t\treturn BUTTON\n        elif choice == \"contains\":\n\t\tbot.send_message(text=\"What is the search string?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return CONTAINS\n        elif choice == \"back_data\":\n                bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"back_get\":\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"active\":\n\t\tglobal active\n\t\tactive = True\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n        elif choice == \"all\":\n                global active\n                active = False\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"nolimit\":\n\t\tglobal subdomains\n\t\tif subdomains:\n                        global limit\n                        limit = False\n\t\t\tbot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\treturn GET_DOMAINS\n\t\telse:\n\t\t\tglobal limit\n\t\t\tlimit = False\n\t\t\tget_topdomains()\n        elif choice == \"limit\":\n                global subdomains\n                if subdomains:\n                        global limit\n                        limit = True\n                        bot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                        return GET_DOMAINS\n                else:\n                        global limit\n                        limit = True\n\t\t\tget_topdomains()\n\n\tif choice == \"yes_scan\":\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telif choice == \"back_scan\" or choice == \"no_scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\ndef get_latest_scan(bot, update, cursor):\n\tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))\n\telse:\n\t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\n\ndef get_custom_scan(bot, update, cursor):\n\tquery = update.callback_query\n\n\tcursor.execute (\"SELECT ScanID FROM scans where EndDate is not null ORDER BY ScanID DESC LIMIT 10\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tlatestScanIds = sorted([str(x[0]) for x in data])\n\t\tfirstRow = latestScanIds[:len(latestScanIds)/2]\n\t\tsecondRow = latestScanIds[len(latestScanIds)/2:]\n\t\tcustom_keyboard = [firstRow, secondRow]\n\t\treply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\n\n\t\tif data:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\ttext=\"Which scan ID? \\n/cancel to cancel\",\n\t\t\t\treply_markup=reply_markup, ForceReply = True)\n\t\telse:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\t text=\"Which scan ID? \\n/cancel to cancel\")\n\n\ndef run_scan(bot, update, cursor):\n\tquery = update.callback_query\n\tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")\n\tdata = cursor.fetchall()\n\tif data[0][2] != None:\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telse:\n\t\tr = str(randint(0, 99))\n\t        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        \tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                \t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        \t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n\ndef custom_scan_id_input(bot, update):\n\tprint \"inside input method with data: \" + update.message.text\n\tcustomId = update.message.text\n\ttry:\n\t\tint(customId)\n\texcept ValueError:\n\t\tprint \"invalid number\"\n\t\tupdate.message.reply_text(\"Not a valid number\")\n\telse:\n\t\tprint \"valid number\"\n        \tconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n        \tcursor = connection.cursor ()\n\t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))\n\t        data = cursor.fetchall()\n\t\tcursor.close()\n\t\tconnection.close()\n\t\tif data:\n\t\t\tprint \"scan ID was found in the db\"\n\t\t\tprint \"data[0][0] is: \" + str(data[0][0])\n\t\t\tif data[0][0] == None:\n\t\t\t\tprint \"EndDate of scan is empty\"\n\t\t\t\tupdate.message.reply_text(\"This scan hasn't finished yet\")\n\t\t\telse:\n\t\t\t\tprint \"Valid scan found\"\n\t\t\t\treply_markup = telegram.ReplyKeyboardRemove()\n\t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)\n\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))\n\t\t\t\treturn ConversationHandler.END\n\t\telse:\n\t\t\tprint \"Scan ID not found in db\"\n\t\t\tupdate.message.reply_text(\"This scan ID doesn't exist\")\n\n\ndef add_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef edit_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef get_domains():\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef domains_contain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef help(bot, update):\n\tupdate.message.reply_text(\"click /start to start :)\")\n\n\ndef error(bot, update, error):\n\tlogger.warning('Update \"%s\" caused error \"%s\"', update, error)\n\t\t\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treply_markup = telegram.ReplyKeyboardRemove()\n\tupdate.message.reply_text(\"canceled! Click or type /start to start again\", reply_markup=reply_markup)\n\treturn ConversationHandler.END\n\n\ndef main():\n\t# Create the EventHandler and pass it your bot's token.\n\tupdater = Updater(telegram_bot_token)\n\n\t# Get the dispatcher to register handlers\n\tdp = updater.dispatcher\n\n\t# Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t\tBUTTON: [CallbackQueryHandler(button),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n\t\t\tCUSTOM_SCAN_ID_INPUT: [MessageHandler(Filters.text, custom_scan_id_input),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n                        ADD_DOMAIN: [MessageHandler(Filters.text, add_domain),\n                                           CommandHandler('cancel', cancel)],\n                        EDIT_DOMAIN: [MessageHandler(Filters.text, edit_domain),\n                                           CommandHandler('cancel', cancel)],\n                        GET_DOMAINS: [MessageHandler(Filters.text, get_domains),\n                                           CommandHandler('cancel', cancel)],\n                        CONTAINS: [MessageHandler(Filters.text, domains_contain),\n                                           CommandHandler('cancel', cancel)]\n\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\n\t# log all errors\n\tdp.add_error_handler(error)\n\n\t# Start the Bot\n\tupdater.start_polling()\n\n\t# Run the bot until you press Ctrl-C or the process receives SIGINT,\n\t# SIGTERM or SIGABRT. This should be used most of the time, since\n\t# start_polling() is non-blocking and will stop the bot gracefully.\n\tupdater.idle()\n\n\nif __name__ == '__main__':\n\tmain()\n", "methods": [{"name": "start", "start_line": 22, "end_line": 39}, {"name": "button", "start_line": 42, "end_line": 193}, {"name": "get_latest_scan", "start_line": 196, "end_line": 202}, {"name": "get_custom_scan", "start_line": 205, "end_line": 223}, {"name": "run_scan", "start_line": 226, "end_line": 245}, {"name": "custom_scan_id_input", "start_line": 248, "end_line": 278}, {"name": "add_domain", "start_line": 281, "end_line": 283}, {"name": "edit_domain", "start_line": 286, "end_line": 288}, {"name": "get_domains", "start_line": 291, "end_line": 293}, {"name": "domains_contain", "start_line": 296, "end_line": 298}, {"name": "help", "start_line": 301, "end_line": 302}, {"name": "error", "start_line": 305, "end_line": 306}, {"name": "cancel", "start_line": 309, "end_line": 313}, {"name": "main", "start_line": 316, "end_line": 357}], "methods_before": [{"name": "start", "start_line": 20, "end_line": 32}, {"name": "button", "start_line": 35, "end_line": 187}, {"name": "get_latest_scan", "start_line": 190, "end_line": 196}, {"name": "get_custom_scan", "start_line": 199, "end_line": 217}, {"name": "run_scan", "start_line": 220, "end_line": 235}, {"name": "custom_scan_id_input", "start_line": 238, "end_line": 268}, {"name": "add_domain", "start_line": 271, "end_line": 273}, {"name": "edit_domain", "start_line": 276, "end_line": 278}, {"name": "get_domains", "start_line": 281, "end_line": 283}, {"name": "domains_contain", "start_line": 286, "end_line": 288}, {"name": "help", "start_line": 291, "end_line": 292}, {"name": "error", "start_line": 295, "end_line": 296}, {"name": "cancel", "start_line": 299, "end_line": 303}, {"name": "main", "start_line": 306, "end_line": 347}], "changed_methods": [{"name": "run_scan", "start_line": 226, "end_line": 245}, {"name": "custom_scan_id_input", "start_line": 248, "end_line": 278}, {"name": "start", "start_line": 22, "end_line": 39}, {"name": "button", "start_line": 42, "end_line": 193}], "nloc": 282, "complexity": 50, "token_count": 2478}, {"old_path": "telegram/notify.py", "new_path": "telegram/notify.py", "filename": "notify.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -1,12 +1,18 @@\n #!/usr/bin/python\n \n-import sys, datetime, MySQLdb, telegram\n+import sys, datetime, MySQLdb, telegram, os\n+sys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\n+import credentials\n \n-bot = telegram.Bot('576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI')\n+if credentials.telegram_bot_token == \"\" or credentials.telegram_chat_id == \"\":\n+\tprint \"[+] No telegram bot token and/or telegram chat id set in credentials.py\"\n+\tsys.exit()\n+\n+bot = telegram.Bot(credentials.telegram_bot_token)\n scanId = sys.argv[1]\n message = \"*\" + str(datetime.datetime.now().replace(microsecond=0)) + \"*\"\n \n-connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\n+connection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n cursor = connection.cursor()\n \n cursor.execute (\"select * from domains where scan_Id = %s and Active order by TopDomainID\", (scanId))\n@@ -36,4 +42,4 @@ elif len(newSubDomains) == 1:\n \n message += \"\"\n \n-bot.send_message(chat_id=476443218, text=message, parse_mode=telegram.ParseMode.MARKDOWN)\n+bot.send_message(chat_id=credentials.telegram_chat_id, text=message, parse_mode=telegram.ParseMode.MARKDOWN)\n", "diff_parsed": {"added": [[3, "import sys, datetime, MySQLdb, telegram, os"], [4, "sys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")"], [5, "import credentials"], [7, "if credentials.telegram_bot_token == \"\" or credentials.telegram_chat_id == \"\":"], [8, "\tprint \"[+] No telegram bot token and/or telegram chat id set in credentials.py\""], [9, "\tsys.exit()"], [10, ""], [11, "bot = telegram.Bot(credentials.telegram_bot_token)"], [15, "connection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)"], [45, "bot.send_message(chat_id=credentials.telegram_chat_id, text=message, parse_mode=telegram.ParseMode.MARKDOWN)"]], "deleted": [[3, "import sys, datetime, MySQLdb, telegram"], [5, "bot = telegram.Bot('576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI')"], [9, "connection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")"], [39, "bot.send_message(chat_id=476443218, text=message, parse_mode=telegram.ParseMode.MARKDOWN)"]]}, "added_lines": 10, "deleted_lines": 4, "source_code": "#!/usr/bin/python\n\nimport sys, datetime, MySQLdb, telegram, os\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\nimport credentials\n\nif credentials.telegram_bot_token == \"\" or credentials.telegram_chat_id == \"\":\n\tprint \"[+] No telegram bot token and/or telegram chat id set in credentials.py\"\n\tsys.exit()\n\nbot = telegram.Bot(credentials.telegram_bot_token)\nscanId = sys.argv[1]\nmessage = \"*\" + str(datetime.datetime.now().replace(microsecond=0)) + \"*\"\n\nconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\ncursor = connection.cursor()\n\ncursor.execute (\"select * from domains where scan_Id = %s and Active order by TopDomainID\", (scanId))\nnewSubDomains = cursor.fetchall()\n\ncursor.execute (\"select * from errors where scan_Id = %s order by ErrorDate\", (scanId))\nerrors = cursor.fetchall()\n\nconnection.close()\n\nmessage += \"\\n_Scan \" + str(scanId) + \"_\"\n\nmessage += \"\\n\"\n\nif len(errors) > 1:\n        message += \"\\n(\" + str(len(errors)) + \"  Errors)\"\nelif len(errors) == 1:\n        message += \"\\n(\" + str(len(errors)) + \"  Error)\"\n\nif len(errors) > 0:\n\tmessage += \"\\n--------------\"\n\nif len(newSubDomains) > 1:\n\tmessage += \"\\n\\[+] \" + str(len(newSubDomains)) + \" New subdomains:\"\nelif len(newSubDomains) == 1:\n\tmessage += \"\\n\\[+] \" + str(len(newSubDomains)) + \" New subdomain:\"\n\nmessage += \"\"\n\nbot.send_message(chat_id=credentials.telegram_chat_id, text=message, parse_mode=telegram.ParseMode.MARKDOWN)\n", "source_code_before": "#!/usr/bin/python\n\nimport sys, datetime, MySQLdb, telegram\n\nbot = telegram.Bot('576071746:AAH2TYv_IDgh4r-bAnO9yE0LioSewbDuVPI')\nscanId = sys.argv[1]\nmessage = \"*\" + str(datetime.datetime.now().replace(microsecond=0)) + \"*\"\n\nconnection = MySQLdb.connect (host = \"localhost\", user = \"rjp\", passwd = \"1484\", db = \"recon\")\ncursor = connection.cursor()\n\ncursor.execute (\"select * from domains where scan_Id = %s and Active order by TopDomainID\", (scanId))\nnewSubDomains = cursor.fetchall()\n\ncursor.execute (\"select * from errors where scan_Id = %s order by ErrorDate\", (scanId))\nerrors = cursor.fetchall()\n\nconnection.close()\n\nmessage += \"\\n_Scan \" + str(scanId) + \"_\"\n\nmessage += \"\\n\"\n\nif len(errors) > 1:\n        message += \"\\n(\" + str(len(errors)) + \"  Errors)\"\nelif len(errors) == 1:\n        message += \"\\n(\" + str(len(errors)) + \"  Error)\"\n\nif len(errors) > 0:\n\tmessage += \"\\n--------------\"\n\nif len(newSubDomains) > 1:\n\tmessage += \"\\n\\[+] \" + str(len(newSubDomains)) + \" New subdomains:\"\nelif len(newSubDomains) == 1:\n\tmessage += \"\\n\\[+] \" + str(len(newSubDomains)) + \" New subdomain:\"\n\nmessage += \"\"\n\nbot.send_message(chat_id=476443218, text=message, parse_mode=telegram.ParseMode.MARKDOWN)\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": 30, "complexity": 0, "token_count": 306}, {"old_path": null, "new_path": "telegram/setup.py", "filename": "setup.py", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1,66 @@\n+#!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n+import telegram, sys, os, logging, datetime\n+from telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\n+from telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\n+sys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\n+import credentials\n+\n+telegram_bot_token = credentials.telegram_bot_token\n+\n+\n+# Enable logging\n+logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n+\t\t\t\t\tlevel=logging.INFO)\n+\n+logger = logging.getLogger(__name__)\n+\n+def start(bot, update):\n+\tuser = update.message.from_user\n+\tchat_id = str(update.message.chat_id)\n+\n+\twith open(os.path.dirname(os.path.abspath(__file__)) + \"/../credentials.py\") as f:\n+\t\tvar_lines = f.readlines()\n+\t\tvar_lines = [x.strip() for x in var_lines]\n+\tf.close()\n+\n+\tnew_lines = []\n+\n+\tfor line in var_lines:\n+\t\tif line.startswith(\"telegram_chat_id\"):\n+\t\t\tnew_lines.append(\"telegram_chat_id = \\\"\" + str(chat_id) + \"\\\"\")\n+\t\telse:\n+\t\t\tnew_lines.append(line)\n+\n+\tcreds = open(os.path.dirname(os.path.abspath(__file__)) + \"/../credentials.py\", 'w')\n+\tfor item in new_lines:\n+\t\tif item:\n+\t\t\tcreds.write(\"%s\\n\" % item)\n+\tcreds.close()\n+\tupdate.message.reply_text(\"Welcome \" + str(user['first_name']) + \"! The telegram setup is successfully finished.\")\n+\tprint \"Success! You can now close the setup with ctr + c\"\n+\treturn ConversationHandler.END\n+\n+def main():\n+\tupdater = Updater(telegram_bot_token)\n+\tdp = updater.dispatcher\n+\n+\tconv_handler = ConversationHandler(\n+\t\tentry_points=[CommandHandler('start', start)],\n+\n+\t\tstates={\n+\t\t},\n+\n+\t\tfallbacks=[CommandHandler('cancel', cancel)]\n+\t)\n+\n+\tdp.add_handler(conv_handler)\n+\tupdater.start_polling()\n+\tupdater.idle()\n+\n+def cancel(bot, update):\n+\tprint \"canceled\"\n+\treturn ConversationHandler.END\n+\n+if __name__ == '__main__':\n+\tmain()\n", "diff_parsed": {"added": [[1, "#!/usr/bin/env python"], [2, "# -*- coding: utf-8 -*-"], [3, "import telegram, sys, os, logging, datetime"], [4, "from telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)"], [5, "from telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters"], [6, "sys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")"], [7, "import credentials"], [8, ""], [9, "telegram_bot_token = credentials.telegram_bot_token"], [10, ""], [11, ""], [12, "# Enable logging"], [13, "logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',"], [14, "\t\t\t\t\tlevel=logging.INFO)"], [15, ""], [16, "logger = logging.getLogger(__name__)"], [17, ""], [18, "def start(bot, update):"], [19, "\tuser = update.message.from_user"], [20, "\tchat_id = str(update.message.chat_id)"], [21, ""], [22, "\twith open(os.path.dirname(os.path.abspath(__file__)) + \"/../credentials.py\") as f:"], [23, "\t\tvar_lines = f.readlines()"], [24, "\t\tvar_lines = [x.strip() for x in var_lines]"], [25, "\tf.close()"], [26, ""], [27, "\tnew_lines = []"], [28, ""], [29, "\tfor line in var_lines:"], [30, "\t\tif line.startswith(\"telegram_chat_id\"):"], [31, "\t\t\tnew_lines.append(\"telegram_chat_id = \\\"\" + str(chat_id) + \"\\\"\")"], [32, "\t\telse:"], [33, "\t\t\tnew_lines.append(line)"], [34, ""], [35, "\tcreds = open(os.path.dirname(os.path.abspath(__file__)) + \"/../credentials.py\", 'w')"], [36, "\tfor item in new_lines:"], [37, "\t\tif item:"], [38, "\t\t\tcreds.write(\"%s\\n\" % item)"], [39, "\tcreds.close()"], [40, "\tupdate.message.reply_text(\"Welcome \" + str(user['first_name']) + \"! The telegram setup is successfully finished.\")"], [41, "\tprint \"Success! You can now close the setup with ctr + c\""], [42, "\treturn ConversationHandler.END"], [43, ""], [44, "def main():"], [45, "\tupdater = Updater(telegram_bot_token)"], [46, "\tdp = updater.dispatcher"], [47, ""], [48, "\tconv_handler = ConversationHandler("], [49, "\t\tentry_points=[CommandHandler('start', start)],"], [50, ""], [51, "\t\tstates={"], [52, "\t\t},"], [53, ""], [54, "\t\tfallbacks=[CommandHandler('cancel', cancel)]"], [55, "\t)"], [56, ""], [57, "\tdp.add_handler(conv_handler)"], [58, "\tupdater.start_polling()"], [59, "\tupdater.idle()"], [60, ""], [61, "def cancel(bot, update):"], [62, "\tprint \"canceled\""], [63, "\treturn ConversationHandler.END"], [64, ""], [65, "if __name__ == '__main__':"], [66, "\tmain()"]], "deleted": []}, "added_lines": 66, "deleted_lines": 0, "source_code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport telegram, sys, os, logging, datetime\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\nimport credentials\n\ntelegram_bot_token = credentials.telegram_bot_token\n\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\nlogger = logging.getLogger(__name__)\n\ndef start(bot, update):\n\tuser = update.message.from_user\n\tchat_id = str(update.message.chat_id)\n\n\twith open(os.path.dirname(os.path.abspath(__file__)) + \"/../credentials.py\") as f:\n\t\tvar_lines = f.readlines()\n\t\tvar_lines = [x.strip() for x in var_lines]\n\tf.close()\n\n\tnew_lines = []\n\n\tfor line in var_lines:\n\t\tif line.startswith(\"telegram_chat_id\"):\n\t\t\tnew_lines.append(\"telegram_chat_id = \\\"\" + str(chat_id) + \"\\\"\")\n\t\telse:\n\t\t\tnew_lines.append(line)\n\n\tcreds = open(os.path.dirname(os.path.abspath(__file__)) + \"/../credentials.py\", 'w')\n\tfor item in new_lines:\n\t\tif item:\n\t\t\tcreds.write(\"%s\\n\" % item)\n\tcreds.close()\n\tupdate.message.reply_text(\"Welcome \" + str(user['first_name']) + \"! The telegram setup is successfully finished.\")\n\tprint \"Success! You can now close the setup with ctr + c\"\n\treturn ConversationHandler.END\n\ndef main():\n\tupdater = Updater(telegram_bot_token)\n\tdp = updater.dispatcher\n\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\tupdater.start_polling()\n\tupdater.idle()\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treturn ConversationHandler.END\n\nif __name__ == '__main__':\n\tmain()\n", "source_code_before": null, "methods": [{"name": "start", "start_line": 18, "end_line": 42}, {"name": "main", "start_line": 44, "end_line": 59}, {"name": "cancel", "start_line": 61, "end_line": 63}], "methods_before": [], "changed_methods": [{"name": "main", "start_line": 44, "end_line": 59}, {"name": "start", "start_line": 18, "end_line": 42}, {"name": "cancel", "start_line": 61, "end_line": 63}], "nloc": 47, "complexity": 8, "token_count": 357}, {"old_path": "tools/dependencies/sublister", "new_path": null, "filename": "sublister", "change_type": "ModificationType.DELETE", "change_type_name": "DELETE", "diff": "@@ -1 +0,0 @@\n-Subproject commit 832d544fa643928f7fd5a5a556a4bbe5624bbce0\n", "diff_parsed": {"added": [], "deleted": [[1, "Subproject commit 832d544fa643928f7fd5a5a556a4bbe5624bbce0"]]}, "added_lines": 0, "deleted_lines": 1, "source_code": null, "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": 0.14285714285714285, "dmm_unit_complexity": 0.5714285714285714, "dmm_unit_interfacing": 0.8775510204081632},
    {"hash": "406a1e7ffdcee61262053c77b3388393e10f9024", "msg": "Updates", "author": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "committer": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "author_date": "2018-05-31 11:08:34+02:00", "author_timezone": -7200, "committer_date": "2018-05-31 11:08:34+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["ffb978474e7f44bb54142491bc5c6e2927c1dc26"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 0, "insertions": 1, "lines": 1, "files": 1, "modified_files": [{"old_path": null, "new_path": "logs/run_logs.txt", "filename": "run_logs.txt", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1 @@\n+No module named credentials\n", "diff_parsed": {"added": [[1, "No module named credentials"]], "deleted": []}, "added_lines": 1, "deleted_lines": 0, "source_code": "No module named credentials\n", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "4e349b9e5b6a8abcb82c506e06e500e9fcfa9afe", "msg": "Updates", "author": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "committer": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "author_date": "2018-05-31 11:10:06+02:00", "author_timezone": -7200, "committer_date": "2018-05-31 11:10:06+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["406a1e7ffdcee61262053c77b3388393e10f9024"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 1, "insertions": 0, "lines": 1, "files": 1, "modified_files": [{"old_path": "logs/run_logs.txt", "new_path": null, "filename": "run_logs.txt", "change_type": "ModificationType.DELETE", "change_type_name": "DELETE", "diff": "@@ -1 +0,0 @@\n-No module named credentials\n", "diff_parsed": {"added": [], "deleted": [[1, "No module named credentials"]]}, "added_lines": 0, "deleted_lines": 1, "source_code": null, "source_code_before": "No module named credentials\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "17348d82ac736f16eb4ee99de6ed73e58ccc25a9", "msg": "small updates", "author": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "committer": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "author_date": "2018-05-31 12:24:59+02:00", "author_timezone": -7200, "committer_date": "2018-05-31 12:24:59+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["4e349b9e5b6a8abcb82c506e06e500e9fcfa9afe"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 5, "insertions": 36, "lines": 41, "files": 6, "modified_files": [{"old_path": "README.md", "new_path": "README.md", "filename": "README.md", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -1 +1,21 @@\n-Framework to monitor subdomains\n+## \ud83d\udccc Description\n+\n+# Install\n+```bash ./install.sh ``` The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always \n+change these credentials later on.\n+\n+# Telegram\n+ICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot \n+token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id \n+to credentials.py so it can be used for authentication with the bot, and to send the notifications to.\n+\n+# Modules\n+The following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time.\n+ \n+the install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then \n+install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to \n+install MySQLdb.\n+\n+# Extra\n+To get ICU up and running, requires some simple skills. \ud83d\udc4c *Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - \n+[003random.com](https://poc-server.com/blog/)*\n", "diff_parsed": {"added": [[1, "## \ud83d\udccc Description"], [2, ""], [3, "# Install"], [4, "```bash ./install.sh ``` The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always"], [5, "change these credentials later on."], [6, ""], [7, "# Telegram"], [8, "ICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot"], [9, "token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id"], [10, "to credentials.py so it can be used for authentication with the bot, and to send the notifications to."], [11, ""], [12, "# Modules"], [13, "The following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time."], [14, ""], [15, "the install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then"], [16, "install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to"], [17, "install MySQLdb."], [18, ""], [19, "# Extra"], [20, "To get ICU up and running, requires some simple skills. \ud83d\udc4c *Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) -"], [21, "[003random.com](https://poc-server.com/blog/)*"]], "deleted": [[1, "Framework to monitor subdomains"]]}, "added_lines": 21, "deleted_lines": 1, "source_code": "## \ud83d\udccc Description\n\n# Install\n```bash ./install.sh ``` The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always \nchange these credentials later on.\n\n# Telegram\nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot \ntoken [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id \nto credentials.py so it can be used for authentication with the bot, and to send the notifications to.\n\n# Modules\nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time.\n \nthe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then \ninstall these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to \ninstall MySQLdb.\n\n# Extra\nTo get ICU up and running, requires some simple skills. \ud83d\udc4c *Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - \n[003random.com](https://poc-server.com/blog/)*\n", "source_code_before": "Framework to monitor subdomains\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}, {"old_path": null, "new_path": "credentials.py", "filename": "credentials.py", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1,9 @@\n+\n+database_username = \"rjp\"\n+database_password = \"1484\"\n+database_server = \"localhost\"\n+database_name = \"recon\"\n+\n+telegram_bot_token = \"\"\n+telegram_chat_id = \"\"\n+\n", "diff_parsed": {"added": [[1, ""], [2, "database_username = \"rjp\""], [3, "database_password = \"1484\""], [4, "database_server = \"localhost\""], [5, "database_name = \"recon\""], [6, ""], [7, "telegram_bot_token = \"\""], [8, "telegram_chat_id = \"\""], [9, ""]], "deleted": []}, "added_lines": 9, "deleted_lines": 0, "source_code": "\ndatabase_username = \"rjp\"\ndatabase_password = \"1484\"\ndatabase_server = \"localhost\"\ndatabase_name = \"recon\"\n\ntelegram_bot_token = \"\"\ntelegram_chat_id = \"\"\n\n", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": 6, "complexity": 0, "token_count": 18}, {"old_path": "credentials.pyc", "new_path": "credentials.pyc", "filename": "credentials.pyc", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "Binary files /dev/null and b/credentials.pyc differ\n", "diff_parsed": {"added": [], "deleted": []}, "added_lines": 0, "deleted_lines": 0, "source_code": "\u0003\r\n\u001f\u000f[c\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000@\u0000\u0000\u0000s(\u0000\u0000\u0000d\u0000\u0000Z\u0000\u0000d\u0001\u0000Z\u0001\u0000d\u0002\u0000Z\u0002\u0000d\u0003\u0000Z\u0003\u0000d\u0004\u0000Z\u0004\u0000d\u0004\u0000Z\u0005\u0000d\u0005\u0000S(\u0006\u0000\u0000\u0000t\u0003\u0000\u0000\u0000rjpt\u0004\u0000\u0000\u00001484t\t\u0000\u0000\u0000localhostt\u0005\u0000\u0000\u0000recont\u0000\u0000\u0000\u0000N(\u0006\u0000\u0000\u0000t\u0011\u0000\u0000\u0000database_usernamet\u0011\u0000\u0000\u0000database_passwordt\u000f\u0000\u0000\u0000database_servert\r\u0000\u0000\u0000database_namet\u0012\u0000\u0000\u0000telegram_bot_tokent\u0010\u0000\u0000\u0000telegram_chat_id(\u0000\u0000\u0000\u0000(\u0000\u0000\u0000\u0000(\u0000\u0000\u0000\u0000s(\u0000\u0000\u0000/home/rjp/ICU/database/../credentials.pyt\b\u0000\u0000\u0000<module>\u0002\u0000\u0000\u0000s\n\u0000\u0000\u0000\u0006\u0001\u0006\u0001\u0006\u0001\u0006\u0002\u0006\u0001", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}, {"old_path": "database/additional_tools/domains_db.py", "new_path": "database/additional_tools/domains_db.py", "filename": "domains_db.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -1,5 +1,5 @@\n #!/usr/bin/python\n-import os, sys, MySQLdb\n+import os, sys, MySQLdb, time\n sys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../../\")\n import credentials\n \n@@ -17,7 +17,7 @@ try:\n \n \t#Add new subdomain scanners here. Make sure to let them save the output to /tmp/ICU/{domain}/doains-all.txt\n \tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n-\n+\ttime.sleep(6)\n \t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on\n \tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n \tdatabase_data = cursor.fetchall()\n@@ -64,8 +64,8 @@ try:\n \tconnection.close ()\n except Exception as e:\n \t#Handle the errors, and save them to the database\n-\tprint \"error in sublister_to_db.py with main domain; \" + domain\n-\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in sublister_to_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n+\tprint \"error in domains_db.py with main domain; \" + domain\n+\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in domains_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n \tconnection.commit()\n \tcursor.close()\n \tconnection.close()\n", "diff_parsed": {"added": [[2, "import os, sys, MySQLdb, time"], [20, "\ttime.sleep(6)"], [67, "\tprint \"error in domains_db.py with main domain; \" + domain"], [68, "\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in domains_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))"]], "deleted": [[2, "import os, sys, MySQLdb"], [20, ""], [67, "\tprint \"error in sublister_to_db.py with main domain; \" + domain"], [68, "\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in sublister_to_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))"]]}, "added_lines": 4, "deleted_lines": 4, "source_code": "#!/usr/bin/python\nimport os, sys, MySQLdb, time\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../../\")\nimport credentials\n\ntry:\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tdomain = sys.argv[1].strip()\n\tcursor = connection.cursor()\n\tscanId = sys.argv[2]\n\n\tif not os.path.exists(\"/tmp/ICU\"):\n\t\tos.makedirs(\"/tmp/ICU\")\n\n\tif not os.path.exists(\"/tmp/ICU/\"+domain+\"/\"):\n\t    os.makedirs(\"/tmp/ICU/\"+domain+\"/\")\n\n\t#Add new subdomain scanners here. Make sure to let them save the output to /tmp/ICU/{domain}/doains-all.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n\ttime.sleep(6)\n\t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on\n\tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n\tdatabase_data = cursor.fetchall()\n\tdatabase_domains = [d[0] for d in database_data]\n\n        non_active_subdomains = [x[0] for x in database_data if ord(x[2]) == False]\n        program = [x[3] for x in database_data if x[0] == domain][0]\n        topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n\n\t#All the domains from the subdomain scanners\n\tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n\t#Add all the database subdomain to it\n\tdomains_all.extend(x for x in database_domains if x not in domains_all)\n\t#Make it unique\n\tdomains_all = list(set(domains_all))\n\n\t#Put all the online domains in a domains-online.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")\n\n\t#Convert online domains to array\n\tdomains_online = open(\"/tmp/ICU/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n\n\t#Loop through every subdomain\n\tfor sub_domain in domains_all:\n\t\t#Get the scanID to insert. If the domains was already in the db and isnt changed, then keep the old scanID. otherwise use the scanID of the current scan\n\t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n\n\t\t#If the subdomain is online\n\t\tif sub_domain in domains_online:\n\t\t\tactive=True\n\t\t\t#If the subdomain used to be offline, give it the current scanID\n\t\t\tif sub_domain in non_active_subdomains:\n\t\t\t\tinsertScanId = scanId\n\t\telse:\n\t\t\tactive=False\n\n\n\t\tif sub_domain:\n\t\t\t#Insert the new values, or update them if they already existed\n\t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))\n\t\t\tconnection.commit()\n\n\tcursor.close ()\n\tconnection.close ()\nexcept Exception as e:\n\t#Handle the errors, and save them to the database\n\tprint \"error in domains_db.py with main domain; \" + domain\n\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in domains_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n\tconnection.commit()\n\tcursor.close()\n\tconnection.close()\n\tprint e\nsys.exit()\n", "source_code_before": "#!/usr/bin/python\nimport os, sys, MySQLdb\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../../\")\nimport credentials\n\ntry:\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tdomain = sys.argv[1].strip()\n\tcursor = connection.cursor()\n\tscanId = sys.argv[2]\n\n\tif not os.path.exists(\"/tmp/ICU\"):\n\t\tos.makedirs(\"/tmp/ICU\")\n\n\tif not os.path.exists(\"/tmp/ICU/\"+domain+\"/\"):\n\t    os.makedirs(\"/tmp/ICU/\"+domain+\"/\")\n\n\t#Add new subdomain scanners here. Make sure to let them save the output to /tmp/ICU/{domain}/doains-all.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n\n\t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on\n\tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n\tdatabase_data = cursor.fetchall()\n\tdatabase_domains = [d[0] for d in database_data]\n\n        non_active_subdomains = [x[0] for x in database_data if ord(x[2]) == False]\n        program = [x[3] for x in database_data if x[0] == domain][0]\n        topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n\n\t#All the domains from the subdomain scanners\n\tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n\t#Add all the database subdomain to it\n\tdomains_all.extend(x for x in database_domains if x not in domains_all)\n\t#Make it unique\n\tdomains_all = list(set(domains_all))\n\n\t#Put all the online domains in a domains-online.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")\n\n\t#Convert online domains to array\n\tdomains_online = open(\"/tmp/ICU/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n\n\t#Loop through every subdomain\n\tfor sub_domain in domains_all:\n\t\t#Get the scanID to insert. If the domains was already in the db and isnt changed, then keep the old scanID. otherwise use the scanID of the current scan\n\t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n\n\t\t#If the subdomain is online\n\t\tif sub_domain in domains_online:\n\t\t\tactive=True\n\t\t\t#If the subdomain used to be offline, give it the current scanID\n\t\t\tif sub_domain in non_active_subdomains:\n\t\t\t\tinsertScanId = scanId\n\t\telse:\n\t\t\tactive=False\n\n\n\t\tif sub_domain:\n\t\t\t#Insert the new values, or update them if they already existed\n\t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))\n\t\t\tconnection.commit()\n\n\tcursor.close ()\n\tconnection.close ()\nexcept Exception as e:\n\t#Handle the errors, and save them to the database\n\tprint \"error in sublister_to_db.py with main domain; \" + domain\n\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in sublister_to_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n\tconnection.commit()\n\tcursor.close()\n\tconnection.close()\n\tprint e\nsys.exit()\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": 46, "complexity": 0, "token_count": 524}, {"old_path": null, "new_path": "logs/run_logs.txt", "filename": "run_logs.txt", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1 @@\n+No module named credentials\n", "diff_parsed": {"added": [[1, "No module named credentials"]], "deleted": []}, "added_lines": 1, "deleted_lines": 0, "source_code": "No module named credentials\n", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "d8169a58af67587614b720b126560c1fd5bc0598", "msg": "small updates", "author": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "committer": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "author_date": "2018-05-31 12:28:33+02:00", "author_timezone": -7200, "committer_date": "2018-05-31 12:28:33+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["17348d82ac736f16eb4ee99de6ed73e58ccc25a9"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 13, "insertions": 2, "lines": 15, "files": 6, "modified_files": [{"old_path": "credentials.py", "new_path": null, "filename": "credentials.py", "change_type": "ModificationType.DELETE", "change_type_name": "DELETE", "diff": "@@ -1,9 +0,0 @@\n-\n-database_username = \"rjp\"\n-database_password = \"1484\"\n-database_server = \"localhost\"\n-database_name = \"recon\"\n-\n-telegram_bot_token = \"\"\n-telegram_chat_id = \"\"\n-\n", "diff_parsed": {"added": [], "deleted": [[1, ""], [2, "database_username = \"rjp\""], [3, "database_password = \"1484\""], [4, "database_server = \"localhost\""], [5, "database_name = \"recon\""], [6, ""], [7, "telegram_bot_token = \"\""], [8, "telegram_chat_id = \"\""], [9, ""]]}, "added_lines": 0, "deleted_lines": 9, "source_code": null, "source_code_before": "\ndatabase_username = \"rjp\"\ndatabase_password = \"1484\"\ndatabase_server = \"localhost\"\ndatabase_name = \"recon\"\n\ntelegram_bot_token = \"\"\ntelegram_chat_id = \"\"\n\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}, {"old_path": "credentials.pyc", "new_path": "credentials.pyc", "filename": "credentials.pyc", "change_type": "ModificationType.DELETE", "change_type_name": "DELETE", "diff": "Binary files a/credentials.pyc and /dev/null differ\n", "diff_parsed": {"added": [], "deleted": []}, "added_lines": 0, "deleted_lines": 0, "source_code": null, "source_code_before": "\u0003\r\n\u001f\u000f[c\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000@\u0000\u0000\u0000s(\u0000\u0000\u0000d\u0000\u0000Z\u0000\u0000d\u0001\u0000Z\u0001\u0000d\u0002\u0000Z\u0002\u0000d\u0003\u0000Z\u0003\u0000d\u0004\u0000Z\u0004\u0000d\u0004\u0000Z\u0005\u0000d\u0005\u0000S(\u0006\u0000\u0000\u0000t\u0003\u0000\u0000\u0000rjpt\u0004\u0000\u0000\u00001484t\t\u0000\u0000\u0000localhostt\u0005\u0000\u0000\u0000recont\u0000\u0000\u0000\u0000N(\u0006\u0000\u0000\u0000t\u0011\u0000\u0000\u0000database_usernamet\u0011\u0000\u0000\u0000database_passwordt\u000f\u0000\u0000\u0000database_servert\r\u0000\u0000\u0000database_namet\u0012\u0000\u0000\u0000telegram_bot_tokent\u0010\u0000\u0000\u0000telegram_chat_id(\u0000\u0000\u0000\u0000(\u0000\u0000\u0000\u0000(\u0000\u0000\u0000\u0000s(\u0000\u0000\u0000/home/rjp/ICU/database/../credentials.pyt\b\u0000\u0000\u0000<module>\u0002\u0000\u0000\u0000s\n\u0000\u0000\u0000\u0006\u0001\u0006\u0001\u0006\u0001\u0006\u0002\u0006\u0001", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}, {"old_path": "database/additional_tools/domains_db.py", "new_path": "database/additional_tools/domains_db.py", "filename": "domains_db.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -17,7 +17,7 @@ try:\n \n \t#Add new subdomain scanners here. Make sure to let them save the output to /tmp/ICU/{domain}/doains-all.txt\n \tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n-\ttime.sleep(6)\n+\ttime.sleep(2)\n \t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on\n \tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n \tdatabase_data = cursor.fetchall()\n", "diff_parsed": {"added": [[20, "\ttime.sleep(2)"]], "deleted": [[20, "\ttime.sleep(6)"]]}, "added_lines": 1, "deleted_lines": 1, "source_code": "#!/usr/bin/python\nimport os, sys, MySQLdb, time\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../../\")\nimport credentials\n\ntry:\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tdomain = sys.argv[1].strip()\n\tcursor = connection.cursor()\n\tscanId = sys.argv[2]\n\n\tif not os.path.exists(\"/tmp/ICU\"):\n\t\tos.makedirs(\"/tmp/ICU\")\n\n\tif not os.path.exists(\"/tmp/ICU/\"+domain+\"/\"):\n\t    os.makedirs(\"/tmp/ICU/\"+domain+\"/\")\n\n\t#Add new subdomain scanners here. Make sure to let them save the output to /tmp/ICU/{domain}/doains-all.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n\ttime.sleep(2)\n\t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on\n\tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n\tdatabase_data = cursor.fetchall()\n\tdatabase_domains = [d[0] for d in database_data]\n\n        non_active_subdomains = [x[0] for x in database_data if ord(x[2]) == False]\n        program = [x[3] for x in database_data if x[0] == domain][0]\n        topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n\n\t#All the domains from the subdomain scanners\n\tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n\t#Add all the database subdomain to it\n\tdomains_all.extend(x for x in database_domains if x not in domains_all)\n\t#Make it unique\n\tdomains_all = list(set(domains_all))\n\n\t#Put all the online domains in a domains-online.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")\n\n\t#Convert online domains to array\n\tdomains_online = open(\"/tmp/ICU/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n\n\t#Loop through every subdomain\n\tfor sub_domain in domains_all:\n\t\t#Get the scanID to insert. If the domains was already in the db and isnt changed, then keep the old scanID. otherwise use the scanID of the current scan\n\t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n\n\t\t#If the subdomain is online\n\t\tif sub_domain in domains_online:\n\t\t\tactive=True\n\t\t\t#If the subdomain used to be offline, give it the current scanID\n\t\t\tif sub_domain in non_active_subdomains:\n\t\t\t\tinsertScanId = scanId\n\t\telse:\n\t\t\tactive=False\n\n\n\t\tif sub_domain:\n\t\t\t#Insert the new values, or update them if they already existed\n\t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))\n\t\t\tconnection.commit()\n\n\tcursor.close ()\n\tconnection.close ()\nexcept Exception as e:\n\t#Handle the errors, and save them to the database\n\tprint \"error in domains_db.py with main domain; \" + domain\n\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in domains_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n\tconnection.commit()\n\tcursor.close()\n\tconnection.close()\n\tprint e\nsys.exit()\n", "source_code_before": "#!/usr/bin/python\nimport os, sys, MySQLdb, time\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../../\")\nimport credentials\n\ntry:\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tdomain = sys.argv[1].strip()\n\tcursor = connection.cursor()\n\tscanId = sys.argv[2]\n\n\tif not os.path.exists(\"/tmp/ICU\"):\n\t\tos.makedirs(\"/tmp/ICU\")\n\n\tif not os.path.exists(\"/tmp/ICU/\"+domain+\"/\"):\n\t    os.makedirs(\"/tmp/ICU/\"+domain+\"/\")\n\n\t#Add new subdomain scanners here. Make sure to let them save the output to /tmp/ICU/{domain}/doains-all.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n\ttime.sleep(6)\n\t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on\n\tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n\tdatabase_data = cursor.fetchall()\n\tdatabase_domains = [d[0] for d in database_data]\n\n        non_active_subdomains = [x[0] for x in database_data if ord(x[2]) == False]\n        program = [x[3] for x in database_data if x[0] == domain][0]\n        topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n\n\t#All the domains from the subdomain scanners\n\tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n\t#Add all the database subdomain to it\n\tdomains_all.extend(x for x in database_domains if x not in domains_all)\n\t#Make it unique\n\tdomains_all = list(set(domains_all))\n\n\t#Put all the online domains in a domains-online.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")\n\n\t#Convert online domains to array\n\tdomains_online = open(\"/tmp/ICU/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n\n\t#Loop through every subdomain\n\tfor sub_domain in domains_all:\n\t\t#Get the scanID to insert. If the domains was already in the db and isnt changed, then keep the old scanID. otherwise use the scanID of the current scan\n\t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n\n\t\t#If the subdomain is online\n\t\tif sub_domain in domains_online:\n\t\t\tactive=True\n\t\t\t#If the subdomain used to be offline, give it the current scanID\n\t\t\tif sub_domain in non_active_subdomains:\n\t\t\t\tinsertScanId = scanId\n\t\telse:\n\t\t\tactive=False\n\n\n\t\tif sub_domain:\n\t\t\t#Insert the new values, or update them if they already existed\n\t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))\n\t\t\tconnection.commit()\n\n\tcursor.close ()\n\tconnection.close ()\nexcept Exception as e:\n\t#Handle the errors, and save them to the database\n\tprint \"error in domains_db.py with main domain; \" + domain\n\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in domains_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n\tconnection.commit()\n\tcursor.close()\n\tconnection.close()\n\tprint e\nsys.exit()\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": 46, "complexity": 0, "token_count": 524}, {"old_path": "logs/run_logs.txt", "new_path": null, "filename": "run_logs.txt", "change_type": "ModificationType.DELETE", "change_type_name": "DELETE", "diff": "@@ -1 +0,0 @@\n-No module named credentials\n", "diff_parsed": {"added": [], "deleted": [[1, "No module named credentials"]]}, "added_lines": 0, "deleted_lines": 1, "source_code": null, "source_code_before": "No module named credentials\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}, {"old_path": "main.py", "new_path": "main.py", "filename": "main.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -41,7 +41,7 @@ def run_subdomain_scan_on_target(top_domain_par = None):\n \telse:\n \t\ttop_domain = top_domain_par\n \n-\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__)) + \"/database/additional_tools/sublister_to_db.py \" + top_domain + \" NULL\")\n+\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__)) + \"/database/additional_tools/domains_db.py \" + top_domain + \" NULL\")\n \n def delete_top_domain():\n \tprint \"What is the domain? \"\n", "diff_parsed": {"added": [[44, "\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__)) + \"/database/additional_tools/domains_db.py \" + top_domain + \" NULL\")"]], "deleted": [[44, "\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__)) + \"/database/additional_tools/sublister_to_db.py \" + top_domain + \" NULL\")"]]}, "added_lines": 1, "deleted_lines": 1, "source_code": "#!/usr/bin/python\n\nimport os, sys, MySQLdb, time\nimport credentials\n\nclass bcolors:\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n\nconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\ncursor = connection.cursor()\n\ndef exit_program():\n\tsys.exit()\n\ndef list_subdomains():\n\tsub_domain = raw_input('[Domain] > ')\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (sub_domain,))\n\tdata = cursor.fetchall()\n\n\tfor row in data:\n\t\tif ord(row[1]):\n\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n\t\telse:\n\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\ndef run_subdomain_scan_on_target(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the domain?\"\n\t\ttop_domain = raw_input('[Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__)) + \"/database/additional_tools/domains_db.py \" + top_domain + \" NULL\")\n\ndef delete_top_domain():\n\tprint \"What is the domain? \"\n\ttop_domain = raw_input('[Domain] > ')\n\n        cursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n        data = cursor.fetchone()\n\n\ttop_domain = int(data[0])\n\n        cursor.execute(\"delete from domains where topDomainID = %s\", (top_domain,))\n        connection.commit()\n\n        cursor.execute(\"delete from domains where DomainID = %s\", (top_domain,))\n        connection.commit()\n\n        print bcolors.OKGREEN + \"Domain with its subdomains deleted\" + bcolors.ENDC\n        raw_input(\"\\nPress any key to go back...\")\n        start()\n\n\ndef insert_topdomain(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the domain? \"\n\t\ttop_domain = raw_input('[Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n\tdata = cursor.fetchone()  \n\n\tif data:\n    \t\tprint bcolors.WARNING + \"Domains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n\t\traw_input(\"Press any key to go back...\")\n\t\tstart()\n\t\n\n\tprint \"What is the program? \"\n\tprogram = raw_input('[program] > ')\n\n\tprint \"Inscope? \"\n\tinscope = raw_input('[Y/n] > ')\n\tif \"n\" not in inscope.lower():\n\t\tinscope = 1\n\telse:\n\t\tinscope = 0\n\t\n\n\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active) VALUES (%s, %s, %s, %s)\", (program, inscope, top_domain, 1))\n\tconnection.commit()\n\t\n\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\ndef insert_subdomain(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the (top)domain? \"\n\t\ttop_domain = raw_input('[(Top)Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n\tdata = cursor.fetchone()  \n\n\tif not data:\n    \t\tprint bcolors.WARNING + \"Domain not found!\" + bcolors.ENDC\n\t\tprint \"Do you want to add it? \"\n\t\tanswer = raw_input('[Y/n] > ')\n\t\tif \"n\" not in answer.lower():\n\t\t\tinsert_topdomain(top_domain)\n\t\telse:\n\t\t\traw_input(\"Press any key to go back...\")\n\t\t\tstart()\n\n\tprogram = str(data[1])\n\ttopdomainid = int(data[0])\n\n\n\n\tprint \"What is the subdomain? \"\n\tsub_domain = raw_input('[(Subdomain] > ')\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (sub_domain,))\n\tdata = cursor.fetchone()  \n\n\tif data:\n    \t\tprint bcolors.WARNING + \"Subdomains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n\t\tdoes_not_exist = False\n\telse:\n\t\tdoes_not_exist = True\n\n\tif does_not_exist:\n\t\tprint \"Inscope? \"\n\t\tinscope = raw_input('[Y/n] > ')\n\t\tif \"n\" not in inscope.lower():\n\t\t\tinscope = 1\n\t\telse:\n\t\t\tinscope = 0\n\n\t\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active, TopDomainID) VALUES (%s, %s, %s, %s, %s)\", (program, inscope, sub_domain, 1, topdomainid))\n\t\tconnection.commit()\n\t\t\n\t\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n\n\tprint \"Do you want to add another one?? \"\n\tanother_one = raw_input('[Y/n] > ')\n\tif \"n\" not in another_one.lower():\n\n\t\tinsert_subdomain(top_domain)\n\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\n\ndef list_domains():\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID is NULL\")\n\tdata = cursor.fetchall()\n\n\tfor row in data:\n\t\tif ord(row[1]):\n\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n\t\telse:\n\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n\t\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\n\n\noptions = {1 : insert_topdomain,\n           2 : list_subdomains,\n           3 : list_domains,\n           4 : insert_subdomain,\n\t   5 : run_subdomain_scan_on_target,\n\t   6 : delete_top_domain,\n           7 : exit_program\n}\n\n\ndef start():\n\tos.system('clear')\n\tcursor.execute (\"select count(*) from domains where TopDomainID is NULL;\")\n\tdata = cursor.fetchall()\n\tsub_domains = data[0][0]\n\n\tcursor.execute (\"select count(TopDomainID) from domains\")\n\tdata = cursor.fetchall()\n\ttop_domains = data[0][0]\n\n\tdomains = top_domains + sub_domains\n\n\tbanner = \"\"\" {0}---------------+-------\n Domains       | {1}   \n Top-domains   | {2}  \n Sudomains     | {3}   \n---------------+-------{4}\"\"\"\n\n\tchoices = \"\"\"\n1. Add domain\n2. List subdomains from domain\n3. List all (top)domains\n4. Add subdomain\n5. Run subdomain scan on top domain\n6. Delete a (top)domain\n7. Exit\n\"\"\"\n\n\tprint banner.format(bcolors.HEADER, domains, sub_domains, top_domains, bcolors.ENDC)\n\n\tprint choices.format()\n\n\ttry:\n\t\tnum = raw_input('> ')\n\t\tnum = int(num)\n\texcept:\n\t\tprint \"Provide a number please,\"\n\t\traw_input(\"\\nPress any key to go back...\")\n\t\tstart()\n\t\tstart()\n\n\toptions[num]()\n\n\nstart()\ncursor.close ()\nconnection.close ()\nsys.exit()\n", "source_code_before": "#!/usr/bin/python\n\nimport os, sys, MySQLdb, time\nimport credentials\n\nclass bcolors:\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n\nconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\ncursor = connection.cursor()\n\ndef exit_program():\n\tsys.exit()\n\ndef list_subdomains():\n\tsub_domain = raw_input('[Domain] > ')\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (sub_domain,))\n\tdata = cursor.fetchall()\n\n\tfor row in data:\n\t\tif ord(row[1]):\n\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n\t\telse:\n\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\ndef run_subdomain_scan_on_target(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the domain?\"\n\t\ttop_domain = raw_input('[Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__)) + \"/database/additional_tools/sublister_to_db.py \" + top_domain + \" NULL\")\n\ndef delete_top_domain():\n\tprint \"What is the domain? \"\n\ttop_domain = raw_input('[Domain] > ')\n\n        cursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n        data = cursor.fetchone()\n\n\ttop_domain = int(data[0])\n\n        cursor.execute(\"delete from domains where topDomainID = %s\", (top_domain,))\n        connection.commit()\n\n        cursor.execute(\"delete from domains where DomainID = %s\", (top_domain,))\n        connection.commit()\n\n        print bcolors.OKGREEN + \"Domain with its subdomains deleted\" + bcolors.ENDC\n        raw_input(\"\\nPress any key to go back...\")\n        start()\n\n\ndef insert_topdomain(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the domain? \"\n\t\ttop_domain = raw_input('[Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n\tdata = cursor.fetchone()  \n\n\tif data:\n    \t\tprint bcolors.WARNING + \"Domains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n\t\traw_input(\"Press any key to go back...\")\n\t\tstart()\n\t\n\n\tprint \"What is the program? \"\n\tprogram = raw_input('[program] > ')\n\n\tprint \"Inscope? \"\n\tinscope = raw_input('[Y/n] > ')\n\tif \"n\" not in inscope.lower():\n\t\tinscope = 1\n\telse:\n\t\tinscope = 0\n\t\n\n\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active) VALUES (%s, %s, %s, %s)\", (program, inscope, top_domain, 1))\n\tconnection.commit()\n\t\n\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\ndef insert_subdomain(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the (top)domain? \"\n\t\ttop_domain = raw_input('[(Top)Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n\tdata = cursor.fetchone()  \n\n\tif not data:\n    \t\tprint bcolors.WARNING + \"Domain not found!\" + bcolors.ENDC\n\t\tprint \"Do you want to add it? \"\n\t\tanswer = raw_input('[Y/n] > ')\n\t\tif \"n\" not in answer.lower():\n\t\t\tinsert_topdomain(top_domain)\n\t\telse:\n\t\t\traw_input(\"Press any key to go back...\")\n\t\t\tstart()\n\n\tprogram = str(data[1])\n\ttopdomainid = int(data[0])\n\n\n\n\tprint \"What is the subdomain? \"\n\tsub_domain = raw_input('[(Subdomain] > ')\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (sub_domain,))\n\tdata = cursor.fetchone()  \n\n\tif data:\n    \t\tprint bcolors.WARNING + \"Subdomains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n\t\tdoes_not_exist = False\n\telse:\n\t\tdoes_not_exist = True\n\n\tif does_not_exist:\n\t\tprint \"Inscope? \"\n\t\tinscope = raw_input('[Y/n] > ')\n\t\tif \"n\" not in inscope.lower():\n\t\t\tinscope = 1\n\t\telse:\n\t\t\tinscope = 0\n\n\t\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active, TopDomainID) VALUES (%s, %s, %s, %s, %s)\", (program, inscope, sub_domain, 1, topdomainid))\n\t\tconnection.commit()\n\t\t\n\t\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n\n\tprint \"Do you want to add another one?? \"\n\tanother_one = raw_input('[Y/n] > ')\n\tif \"n\" not in another_one.lower():\n\n\t\tinsert_subdomain(top_domain)\n\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\n\ndef list_domains():\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID is NULL\")\n\tdata = cursor.fetchall()\n\n\tfor row in data:\n\t\tif ord(row[1]):\n\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n\t\telse:\n\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n\t\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\n\n\noptions = {1 : insert_topdomain,\n           2 : list_subdomains,\n           3 : list_domains,\n           4 : insert_subdomain,\n\t   5 : run_subdomain_scan_on_target,\n\t   6 : delete_top_domain,\n           7 : exit_program\n}\n\n\ndef start():\n\tos.system('clear')\n\tcursor.execute (\"select count(*) from domains where TopDomainID is NULL;\")\n\tdata = cursor.fetchall()\n\tsub_domains = data[0][0]\n\n\tcursor.execute (\"select count(TopDomainID) from domains\")\n\tdata = cursor.fetchall()\n\ttop_domains = data[0][0]\n\n\tdomains = top_domains + sub_domains\n\n\tbanner = \"\"\" {0}---------------+-------\n Domains       | {1}   \n Top-domains   | {2}  \n Sudomains     | {3}   \n---------------+-------{4}\"\"\"\n\n\tchoices = \"\"\"\n1. Add domain\n2. List subdomains from domain\n3. List all (top)domains\n4. Add subdomain\n5. Run subdomain scan on top domain\n6. Delete a (top)domain\n7. Exit\n\"\"\"\n\n\tprint banner.format(bcolors.HEADER, domains, sub_domains, top_domains, bcolors.ENDC)\n\n\tprint choices.format()\n\n\ttry:\n\t\tnum = raw_input('> ')\n\t\tnum = int(num)\n\texcept:\n\t\tprint \"Provide a number please,\"\n\t\traw_input(\"\\nPress any key to go back...\")\n\t\tstart()\n\t\tstart()\n\n\toptions[num]()\n\n\nstart()\ncursor.close ()\nconnection.close ()\nsys.exit()\n", "methods": [{"name": "exit_program", "start_line": 19, "end_line": 20}, {"name": "list_subdomains", "start_line": 22, "end_line": 34}, {"name": "run_subdomain_scan_on_target", "start_line": 37, "end_line": 44}, {"name": "delete_top_domain", "start_line": 46, "end_line": 63}, {"name": "insert_topdomain", "start_line": 66, "end_line": 98}, {"name": "insert_subdomain", "start_line": 101, "end_line": 158}, {"name": "list_domains", "start_line": 162, "end_line": 173}, {"name": "start", "start_line": 188, "end_line": 229}], "methods_before": [{"name": "exit_program", "start_line": 19, "end_line": 20}, {"name": "list_subdomains", "start_line": 22, "end_line": 34}, {"name": "run_subdomain_scan_on_target", "start_line": 37, "end_line": 44}, {"name": "delete_top_domain", "start_line": 46, "end_line": 63}, {"name": "insert_topdomain", "start_line": 66, "end_line": 98}, {"name": "insert_subdomain", "start_line": 101, "end_line": 158}, {"name": "list_domains", "start_line": 162, "end_line": 173}, {"name": "start", "start_line": 188, "end_line": 229}], "changed_methods": [{"name": "run_subdomain_scan_on_target", "start_line": 37, "end_line": 44}], "nloc": 171, "complexity": 24, "token_count": 963}, {"old_path": "tools/dependencies/sublister", "new_path": null, "filename": "sublister", "change_type": "ModificationType.DELETE", "change_type_name": "DELETE", "diff": "@@ -1 +0,0 @@\n-Subproject commit 832d544fa643928f7fd5a5a556a4bbe5624bbce0\n", "diff_parsed": {"added": [], "deleted": [[1, "Subproject commit 832d544fa643928f7fd5a5a556a4bbe5624bbce0"]]}, "added_lines": 0, "deleted_lines": 1, "source_code": null, "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "4d4bf27590223ea90b3e2d962afd5f55bf5dc35e", "msg": "Added web interface", "author": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "committer": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "author_date": "2018-05-31 23:38:52+02:00", "author_timezone": -7200, "committer_date": "2018-05-31 23:38:52+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["d8169a58af67587614b720b126560c1fd5bc0598"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 1, "insertions": 333, "lines": 334, "files": 2, "modified_files": [{"old_path": "install.sh", "new_path": "install.sh", "filename": "install.sh", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -9,7 +9,7 @@ echo \"[?] Do you want to pip install the requirements.txt?\"\n echo \"[Y/n]\"\n read choice_pip_requirements\n \n-if [ $choice_pip_requirements = \"Y\" ] || [ $choice_pip_requirements = \"y\" ] || [ -z $choice_pip_requirements ]; then\n+if [ \"$choice_pip_requirements\" == \"Y\" ] || [ \"$choice_pip_requirements\" == \"y\" ] || [ -z \"$choice_pip_requirements\" ]; then\n         pip install -r requirements.txt\n else\n \techo\"[!] Make sure you have the right modules installed. You can check which modules are used in requirements.txt\"\n@@ -42,6 +42,8 @@ python database/init_db.py\n echo \"[+] Checking if the database was created successfully\"\n python database/db_test.py\n \n+echo \"----------------------------------------------------------------\"\n+\n echo \"[+] Adding a cron task to run 'run.py' every 12 hours. You can edit this with the command 'crontab -e'\"\n echo \"[?] Adding the path to crontab. If this isn't the right path to the file, please edit this with the command 'crontab -e'\"\n #write out current crontab\n@@ -51,8 +53,25 @@ echo \"0 */12 * * * python $(pwd)/run.py\" >> mycron\n #install new cron file\n crontab mycron\n rm mycron\n+echo \"[+] Crontab task created!\"\n+\n+echo \"----------------------------------------------------------------\"\n+\n+echo \"[?] Do you want to create ICU.php? A simple web interface for the domains.\"\n+echo \"[Y/n]\"\n+read choice_web\n+\n+if [ \"$choice_web\" == \"Y\" ] || [ \"$choice_web\" == \"y\" ] || [ -z \"$choice_web\" ]; then\n+        ./web/setup.sh \"$database_username\" \"$database_password\" \"$database_server\"\n+\techo \"[+] ICU.php was added.\"\n+fi\n+\n+echo \"----------------------------------------------------------------\"\n \n echo \"[!] All set!\"\n+\n+echo \"----------------------------------------------------------------\"\n+\n echo \"[+] If you want to use the telegram options, please add your telegram bot token in credentials.py.\"\n echo \"[?] Do you want to run main.py? This script lets you manage your domains.\"\n echo \"[Y/n]\"\n", "diff_parsed": {"added": [[12, "if [ \"$choice_pip_requirements\" == \"Y\" ] || [ \"$choice_pip_requirements\" == \"y\" ] || [ -z \"$choice_pip_requirements\" ]; then"], [45, "echo \"----------------------------------------------------------------\""], [46, ""], [56, "echo \"[+] Crontab task created!\""], [57, ""], [58, "echo \"----------------------------------------------------------------\""], [59, ""], [60, "echo \"[?] Do you want to create ICU.php? A simple web interface for the domains.\""], [61, "echo \"[Y/n]\""], [62, "read choice_web"], [63, ""], [64, "if [ \"$choice_web\" == \"Y\" ] || [ \"$choice_web\" == \"y\" ] || [ -z \"$choice_web\" ]; then"], [65, "        ./web/setup.sh \"$database_username\" \"$database_password\" \"$database_server\""], [66, "\techo \"[+] ICU.php was added.\""], [67, "fi"], [68, ""], [69, "echo \"----------------------------------------------------------------\""], [72, ""], [73, "echo \"----------------------------------------------------------------\""], [74, ""]], "deleted": [[12, "if [ $choice_pip_requirements = \"Y\" ] || [ $choice_pip_requirements = \"y\" ] || [ -z $choice_pip_requirements ]; then"]]}, "added_lines": 20, "deleted_lines": 1, "source_code": "#!/usr/bin/env bash\n\necho \"[+] Installing sublist3r\"\ngit clone https://github.com/aboul3la/Sublist3r.git tools/dependencies/sublister\n\necho \"----------------------------------------------------------------\"\n\necho \"[?] Do you want to pip install the requirements.txt?\"\necho \"[Y/n]\"\nread choice_pip_requirements\n\nif [ \"$choice_pip_requirements\" == \"Y\" ] || [ \"$choice_pip_requirements\" == \"y\" ] || [ -z \"$choice_pip_requirements\" ]; then\n        pip install -r requirements.txt\nelse\n\techo\"[!] Make sure you have the right modules installed. You can check which modules are used in requirements.txt\"\nfi\n\necho \"----------------------------------------------------------------\"\n\necho \"[?] What is the database username?\"\nread database_username\n\necho \"[?] What is the database password?\"\nread database_password\n\necho \"[?] What is the database server? e.g. localhost (most common), if it runs on the same server.\"\nread database_server\n\necho \"\ndatabase_username = \\\"$database_username\\\"\ndatabase_password = \\\"$database_password\\\"\ndatabase_server = \\\"$database_server\\\"\ndatabase_name = \\\"recon\\\"\n\ntelegram_bot_token = \\\"\\\"\ntelegram_chat_id = \\\"\\\"\n\" > \"credentials.py\"\n\necho \"[+] Creating database 'recon' with tables 'domains', scans and 'errors'\"\npython database/init_db.py\n\necho \"[+] Checking if the database was created successfully\"\npython database/db_test.py\n\necho \"----------------------------------------------------------------\"\n\necho \"[+] Adding a cron task to run 'run.py' every 12 hours. You can edit this with the command 'crontab -e'\"\necho \"[?] Adding the path to crontab. If this isn't the right path to the file, please edit this with the command 'crontab -e'\"\n#write out current crontab\ncrontab -l > mycron\n#echo new cron into cron file\necho \"0 */12 * * * python $(pwd)/run.py\" >> mycron\n#install new cron file\ncrontab mycron\nrm mycron\necho \"[+] Crontab task created!\"\n\necho \"----------------------------------------------------------------\"\n\necho \"[?] Do you want to create ICU.php? A simple web interface for the domains.\"\necho \"[Y/n]\"\nread choice_web\n\nif [ \"$choice_web\" == \"Y\" ] || [ \"$choice_web\" == \"y\" ] || [ -z \"$choice_web\" ]; then\n        ./web/setup.sh \"$database_username\" \"$database_password\" \"$database_server\"\n\techo \"[+] ICU.php was added.\"\nfi\n\necho \"----------------------------------------------------------------\"\n\necho \"[!] All set!\"\n\necho \"----------------------------------------------------------------\"\n\necho \"[+] If you want to use the telegram options, please add your telegram bot token in credentials.py.\"\necho \"[?] Do you want to run main.py? This script lets you manage your domains.\"\necho \"[Y/n]\"\nread choice_main\n\nif [ $choice_main = \"Y\" ] || [ $choice_main = \"y\" ] || [ -z $choice_main ]; then\n\tpython main.py\nfi\n", "source_code_before": "#!/usr/bin/env bash\n\necho \"[+] Installing sublist3r\"\ngit clone https://github.com/aboul3la/Sublist3r.git tools/dependencies/sublister\n\necho \"----------------------------------------------------------------\"\n\necho \"[?] Do you want to pip install the requirements.txt?\"\necho \"[Y/n]\"\nread choice_pip_requirements\n\nif [ $choice_pip_requirements = \"Y\" ] || [ $choice_pip_requirements = \"y\" ] || [ -z $choice_pip_requirements ]; then\n        pip install -r requirements.txt\nelse\n\techo\"[!] Make sure you have the right modules installed. You can check which modules are used in requirements.txt\"\nfi\n\necho \"----------------------------------------------------------------\"\n\necho \"[?] What is the database username?\"\nread database_username\n\necho \"[?] What is the database password?\"\nread database_password\n\necho \"[?] What is the database server? e.g. localhost (most common), if it runs on the same server.\"\nread database_server\n\necho \"\ndatabase_username = \\\"$database_username\\\"\ndatabase_password = \\\"$database_password\\\"\ndatabase_server = \\\"$database_server\\\"\ndatabase_name = \\\"recon\\\"\n\ntelegram_bot_token = \\\"\\\"\ntelegram_chat_id = \\\"\\\"\n\" > \"credentials.py\"\n\necho \"[+] Creating database 'recon' with tables 'domains', scans and 'errors'\"\npython database/init_db.py\n\necho \"[+] Checking if the database was created successfully\"\npython database/db_test.py\n\necho \"[+] Adding a cron task to run 'run.py' every 12 hours. You can edit this with the command 'crontab -e'\"\necho \"[?] Adding the path to crontab. If this isn't the right path to the file, please edit this with the command 'crontab -e'\"\n#write out current crontab\ncrontab -l > mycron\n#echo new cron into cron file\necho \"0 */12 * * * python $(pwd)/run.py\" >> mycron\n#install new cron file\ncrontab mycron\nrm mycron\n\necho \"[!] All set!\"\necho \"[+] If you want to use the telegram options, please add your telegram bot token in credentials.py.\"\necho \"[?] Do you want to run main.py? This script lets you manage your domains.\"\necho \"[Y/n]\"\nread choice_main\n\nif [ $choice_main = \"Y\" ] || [ $choice_main = \"y\" ] || [ -z $choice_main ]; then\n\tpython main.py\nfi\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}, {"old_path": null, "new_path": "web/setup.sh", "filename": "setup.sh", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "@@ -0,0 +1,313 @@\n+echo \"\n+<html>\n+<head>\n+  <link rel=\\\"stylesheet\\\" href=\\\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\\\">\n+   <link rel=\\\"stylesheet\\\" href=\\\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\\\">\n+  <script src=\\\"https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js\\\"></script>\n+  <script src=\\\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\\\"></script>\n+</head>\n+<body>\n+<div id=\\\"top-image\\\" style=\\\"overflow-y: scroll;\\\">\n+<?php\n+\\$servername = \\\"$3\\\";\n+\\$username = \\\"$1\\\";\n+\\$password = \\\"$2\\\";\n+\\$dbname = \\\"recon\\\";\n+\n+\\$conn = new mysqli(\\$servername, \\$username, \\$password, \\$dbname);\n+\n+if (\\$conn->connect_error) {\n+    die(\\\"Connection failed: \\\" . \\$conn->connect_error);\n+}\n+\n+\\$sql = \\\"SELECT * FROM domains ORDER BY Active\\\";\n+\n+\\$result = \\$conn->query(\\$sql);\n+\n+if (\\$result->num_rows > 0) {\n+    while(\\$row = \\$result->fetch_assoc()) {\n+        \\$rows[] = \\$row;\n+   }\n+} else {\n+    echo \\\"0 results\\\";\n+}\n+\\$conn->close();\n+\n+\\$domains = array();\n+\n+        foreach (\\$rows as \\$r) {\n+                if(empty(\\$r[\\\"TopDomainID\\\"])){\n+                        \\$subdomains = array();\n+                        foreach (\\$rows as \\$r2) {\n+                                if(\\$r2[\\\"TopDomainID\\\"] == \\$r[\\\"DomainID\\\"]){\n+                                        array_push(\\$subdomains, \\$r2);\n+                                }\n+                        }\n+                        array_push(\\$domains, array(\\$r, \\$subdomains));\n+                }\n+\n+        }\n+?>\n+\n+<ul id=\\\"accordion\\\" class=\\\"accordion\\\">\n+        <li>\n+                <div class=\\\"link\\\" style=\\\"\\\">\n+                        <i class=\\\"fa fa-search\\\" style=\\\"margin-top: 5px;\\\" ></i>\n+                        <input type=\\\"text\\\" class=\\\"form-control\\\" id=\\\"search\\\">\n+                </div>\n+        </li>\n+        <?php\n+                foreach (\\$domains as &\\$domain) {\n+                        if(\\$domain != ''){\n+                        echo '\n+                        <li><div class=\\\"link top-domain\\\"><i class=\\\"fa fa-globe\\\"></i>'.\\$domain[0][\\\"Domain\\\"].'<i class=\\\"fa fa-chevron-down\\\"></i></div>\n+                                <ul class=\\\"submenu\\\">';\n+                                        \\$domain[1] = array_reverse(\\$domain[1], true);\n+                                        foreach (\\$domain[1] as \\$d) {\n+                                                echo '<li class=\\\"subdomain\\\" added=\\\"'.\\$d[\\\"LastModified\\\"].'\\\" active=\\\"'.\\$d[\\\"Active\\\"].'\\\" inscope=\\\"'.\\$d[\\\"InScope\\\"].'\\\" program=\\\"'.\\$d[\\\"Program\\\"].'\\\"><a href=\\\"#\\\">'.\\$d[\\\"Domain\\\"].'</a></li>';\n+                                        }\n+                        echo '</ul></li>';\n+                        }\n+                }\n+        ?>\n+</ul>\n+\n+<style>\n+.modal-backdrop {\n+top: -5000px !important;\n+position: static;\n+}\n+\n+#top-image {\n+background:url('http://goldwallpapers.com/uploads/posts/google-data-center-wallpaper/google_data_center_wallpaper_013.jpg') -25px -50px;\n+position:fixed ;\n+top:0;\n+width:100%;\n+z-index:0;\n+  height:100%;\n+  background-size: calc(100% + 50px);\n+}\n+\n+* {\n+        margin: 0;\n+        padding: 0;\n+        -webkit-box-sizing: border-box;\n+        -moz-box-sizing: border-box;\n+        box-sizing: border-box;\n+}\n+\n+body {\n+        background: #2d2c41;\n+        font-family: 'Open Sans', Arial, Helvetica, Sans-serif, Verdana, Tahoma;\n+}\n+\n+ul {\n+        list-style-type: none;\n+}\n+\n+a {\n+        color: #b63b4d;\n+        text-decoration: none;\n+}\n+\n+/** =======================\n+ * Contenedor Principal\n+ ===========================*/\n+h1 {\n+        color: #FFF;\n+        font-size: 24px;\n+        font-weight: 400;\n+        text-align: center;\n+        margin-top: 80px;\n+ }\n+\n+h1 a {\n+        color: #c12c42;\n+        font-size: 16px;\n+ }\n+\n+ .accordion {\n+        width: 100%;\n+        max-width: 360px;\n+        margin: 30px auto 20px;\n+        background: #FFF;\n+        -webkit-border-radius: 4px;\n+        -moz-border-radius: 4px;\n+        border-radius: 4px;\n+ }\n+\n+.accordion .link {\n+        cursor: pointer;\n+        display: block;\n+        padding: 15px 15px 15px 42px;\n+        color: #4D4D4D;\n+        font-size: 14px;\n+        font-weight: 700;\n+        border-bottom: 1px solid #CCC;\n+        position: relative;\n+        -webkit-transition: all 0.4s ease;\n+        -o-transition: all 0.4s ease;\n+        transition: all 0.4s ease;\n+}\n+\n+.accordion li:last-child .link {\n+        border-bottom: 0;\n+}\n+\n+.accordion li i {\n+        position: absolute;\n+        top: 16px;\n+        left: 12px;\n+        font-size: 18px;\n+        color: #595959;\n+        -webkit-transition: all 0.4s ease;\n+        -o-transition: all 0.4s ease;\n+        transition: all 0.4s ease;\n+}\n+\n+.accordion li i.fa-chevron-down {\n+        right: 12px;\n+        left: auto;\n+        font-size: 16px;\n+}\n+\n+.accordion li.open .link {\n+        color: #b63b4d;\n+}\n+\n+.accordion li.open i {\n+        color: #b63b4d;\n+}\n+.accordion li.open i.fa-chevron-down {\n+        -webkit-transform: rotate(180deg);\n+        -ms-transform: rotate(180deg);\n+        -o-transform: rotate(180deg);\n+        transform: rotate(180deg);\n+}\n+\n+.accordion li.default .submenu {display: block;}\n+/**\n+ * Submenu\n+ -----------------------------*/\n+ .submenu {\n+        display: none;\n+        background: #FE8103;\n+        font-size: 14px;\n+ }\n+\n+ .submenu li {\n+        border-bottom: 1px solid white;\n+ }\n+\n+ .submenu a {\n+        display: block;\n+        text-decoration: none;\n+        color: #d9d9d9;\n+        padding: 12px;\n+        padding-left: 42px;\n+        -webkit-transition: all 0.25s ease;\n+        -o-transition: all 0.25s ease;\n+        transition: all 0.25s ease;\n+ }\n+\n+ .submenu a:hover {\n+        background: #801B0C;\n+        color: #FFF;\n+ }\n+\n+\n+</style>\n+\n+\n+<!-- Modal -->\n+<div id=\\\"myModal\\\" class=\\\"modal fade\\\" role=\\\"dialog\\\">\n+  <div class=\\\"modal-dialog\\\">\n+\n+    <!-- Modal content-->\n+    <div class=\\\"modal-content\\\">\n+      <div class=\\\"modal-header\\\">\n+        <button type=\\\"button\\\" class=\\\"close\\\" data-dismiss=\\\"modal\\\">&times;</button>\n+        <h4 class=\\\"modal-title\\\">Info</h4>\n+      </div>\n+      <div class=\\\"modal-body\\\">\n+        <p>body text</p>\n+      </div>\n+      <div class=\\\"modal-footer\\\">\n+        <button type=\\\"button\\\" class=\\\"btn btn-default\\\" data-dismiss=\\\"modal\\\">Close</button>\n+      </div>\n+    </div>\n+\n+  </div>\n+</div>\n+\n+\n+<script>\n+\\$(function() {\n+\n+var movementStrength = 25;\n+var height = movementStrength / \\$(window).height();\n+var width = movementStrength / \\$(window).width();\n+\\$(\\\"body\\\").mousemove(function(e){\n+          var pageX = e.pageX - (\\$(window).width() / 2);\n+          var pageY = e.pageY - (\\$(window).height() / 2);\n+          var newvalueX = width * pageX * -1 - 25;\n+          var newvalueY = height * pageY * -1 - 50;\n+          \\$('#top-image').css(\\\"background-position\\\", newvalueX+\\\"px     \\\"+newvalueY+\\\"px\\\");\n+});\n+\\$(\\\"#search\\\").keyup(function(){\n+        \\$('.top-domain').each(function(i, obj) {\n+                if(\\$(this).text().indexOf(\\$(\\\"#search\\\").val()) == -1){\n+                        \\$(this).hide();\n+                }else{\n+                        \\$(this).show();\n+                }\n+        });\n+});\n+\n+\n+\\$(\\\".subdomain\\\").on('click',function(){\n+        \\$(\\\".modal-body\\\").text(\\\"\\\");\n+        \\$(\\\".modal-body\\\").append(\\\"Domain: <b>\\\"+\\$(this).children().text()+\\\"</b>\\\");\n+        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");\n+        \\$(\\\".modal-body\\\").append(\\\"Last Modified: <b>\\\"+\\$(this).attr(\\\"added\\\")+\\\"</b>\\\");\n+        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");\n+        \\$(\\\".modal-body\\\").append(\\\"Active: <b>\\\"+\\$(this).attr(\\\"active\\\").replace(\\\"1\\\", \\\"Yes\\\").replace(\\\"0\\\", \\\"No\\\")+\\\"</b>\\\");\n+        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");\n+        \\$(\\\".modal-body\\\").append(\\\"Inscope: <b>\\\"+\\$(this).attr(\\\"inscope\\\").replace(\\\"1\\\", \\\"Yes\\\").replace(\\\"0\\\", \\\"No\\\")+\\\"</b>\\\");\n+        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");\n+        \\$(\\\".modal-body\\\").append(\\\"Program: <b>\\\"+\\$(this).attr(\\\"program\\\")+\\\"</b>\\\");\n+\n+\n+        \\$('#myModal').modal('show');\n+});\n+\n+        var Accordion = function(el, multiple) {\n+                this.el = el || {};\n+                this.multiple = multiple || false;\n+\n+                // Variables privadas\n+                var links = this.el.find('.link');\n+                // Evento\n+                links.on('click', {el: this.el, multiple: this.multiple}, this.dropdown)\n+        }\n+\n+        Accordion.prototype.dropdown = function(e) {\n+                var \\$el = e.data.el;\n+                        \\$this = \\$(this),\n+                        \\$next = \\$this.next();\n+\n+                \\$next.slideToggle();\n+                \\$this.parent().toggleClass('open');\n+\n+                if (!e.data.multiple) {\n+                        \\$el.find('.submenu').not(\\$next).slideUp().parent().removeClass('open');\n+                };\n+        }\n+\n+        var accordion = new Accordion(\\$('#accordion'), false);\n+});\n+</script>\n+</div>\n+</body>\n+\n+\" > /var/www/html/ICU.php\n", "diff_parsed": {"added": [[1, "echo \""], [2, "<html>"], [3, "<head>"], [4, "  <link rel=\\\"stylesheet\\\" href=\\\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\\\">"], [5, "   <link rel=\\\"stylesheet\\\" href=\\\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\\\">"], [6, "  <script src=\\\"https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js\\\"></script>"], [7, "  <script src=\\\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\\\"></script>"], [8, "</head>"], [9, "<body>"], [10, "<div id=\\\"top-image\\\" style=\\\"overflow-y: scroll;\\\">"], [11, "<?php"], [12, "\\$servername = \\\"$3\\\";"], [13, "\\$username = \\\"$1\\\";"], [14, "\\$password = \\\"$2\\\";"], [15, "\\$dbname = \\\"recon\\\";"], [16, ""], [17, "\\$conn = new mysqli(\\$servername, \\$username, \\$password, \\$dbname);"], [18, ""], [19, "if (\\$conn->connect_error) {"], [20, "    die(\\\"Connection failed: \\\" . \\$conn->connect_error);"], [21, "}"], [22, ""], [23, "\\$sql = \\\"SELECT * FROM domains ORDER BY Active\\\";"], [24, ""], [25, "\\$result = \\$conn->query(\\$sql);"], [26, ""], [27, "if (\\$result->num_rows > 0) {"], [28, "    while(\\$row = \\$result->fetch_assoc()) {"], [29, "        \\$rows[] = \\$row;"], [30, "   }"], [31, "} else {"], [32, "    echo \\\"0 results\\\";"], [33, "}"], [34, "\\$conn->close();"], [35, ""], [36, "\\$domains = array();"], [37, ""], [38, "        foreach (\\$rows as \\$r) {"], [39, "                if(empty(\\$r[\\\"TopDomainID\\\"])){"], [40, "                        \\$subdomains = array();"], [41, "                        foreach (\\$rows as \\$r2) {"], [42, "                                if(\\$r2[\\\"TopDomainID\\\"] == \\$r[\\\"DomainID\\\"]){"], [43, "                                        array_push(\\$subdomains, \\$r2);"], [44, "                                }"], [45, "                        }"], [46, "                        array_push(\\$domains, array(\\$r, \\$subdomains));"], [47, "                }"], [48, ""], [49, "        }"], [50, "?>"], [51, ""], [52, "<ul id=\\\"accordion\\\" class=\\\"accordion\\\">"], [53, "        <li>"], [54, "                <div class=\\\"link\\\" style=\\\"\\\">"], [55, "                        <i class=\\\"fa fa-search\\\" style=\\\"margin-top: 5px;\\\" ></i>"], [56, "                        <input type=\\\"text\\\" class=\\\"form-control\\\" id=\\\"search\\\">"], [57, "                </div>"], [58, "        </li>"], [59, "        <?php"], [60, "                foreach (\\$domains as &\\$domain) {"], [61, "                        if(\\$domain != ''){"], [62, "                        echo '"], [63, "                        <li><div class=\\\"link top-domain\\\"><i class=\\\"fa fa-globe\\\"></i>'.\\$domain[0][\\\"Domain\\\"].'<i class=\\\"fa fa-chevron-down\\\"></i></div>"], [64, "                                <ul class=\\\"submenu\\\">';"], [65, "                                        \\$domain[1] = array_reverse(\\$domain[1], true);"], [66, "                                        foreach (\\$domain[1] as \\$d) {"], [67, "                                                echo '<li class=\\\"subdomain\\\" added=\\\"'.\\$d[\\\"LastModified\\\"].'\\\" active=\\\"'.\\$d[\\\"Active\\\"].'\\\" inscope=\\\"'.\\$d[\\\"InScope\\\"].'\\\" program=\\\"'.\\$d[\\\"Program\\\"].'\\\"><a href=\\\"#\\\">'.\\$d[\\\"Domain\\\"].'</a></li>';"], [68, "                                        }"], [69, "                        echo '</ul></li>';"], [70, "                        }"], [71, "                }"], [72, "        ?>"], [73, "</ul>"], [74, ""], [75, "<style>"], [76, ".modal-backdrop {"], [77, "top: -5000px !important;"], [78, "position: static;"], [79, "}"], [80, ""], [81, "#top-image {"], [82, "background:url('http://goldwallpapers.com/uploads/posts/google-data-center-wallpaper/google_data_center_wallpaper_013.jpg') -25px -50px;"], [83, "position:fixed ;"], [84, "top:0;"], [85, "width:100%;"], [86, "z-index:0;"], [87, "  height:100%;"], [88, "  background-size: calc(100% + 50px);"], [89, "}"], [90, ""], [91, "* {"], [92, "        margin: 0;"], [93, "        padding: 0;"], [94, "        -webkit-box-sizing: border-box;"], [95, "        -moz-box-sizing: border-box;"], [96, "        box-sizing: border-box;"], [97, "}"], [98, ""], [99, "body {"], [100, "        background: #2d2c41;"], [101, "        font-family: 'Open Sans', Arial, Helvetica, Sans-serif, Verdana, Tahoma;"], [102, "}"], [103, ""], [104, "ul {"], [105, "        list-style-type: none;"], [106, "}"], [107, ""], [108, "a {"], [109, "        color: #b63b4d;"], [110, "        text-decoration: none;"], [111, "}"], [112, ""], [113, "/** ======================="], [114, " * Contenedor Principal"], [115, " ===========================*/"], [116, "h1 {"], [117, "        color: #FFF;"], [118, "        font-size: 24px;"], [119, "        font-weight: 400;"], [120, "        text-align: center;"], [121, "        margin-top: 80px;"], [122, " }"], [123, ""], [124, "h1 a {"], [125, "        color: #c12c42;"], [126, "        font-size: 16px;"], [127, " }"], [128, ""], [129, " .accordion {"], [130, "        width: 100%;"], [131, "        max-width: 360px;"], [132, "        margin: 30px auto 20px;"], [133, "        background: #FFF;"], [134, "        -webkit-border-radius: 4px;"], [135, "        -moz-border-radius: 4px;"], [136, "        border-radius: 4px;"], [137, " }"], [138, ""], [139, ".accordion .link {"], [140, "        cursor: pointer;"], [141, "        display: block;"], [142, "        padding: 15px 15px 15px 42px;"], [143, "        color: #4D4D4D;"], [144, "        font-size: 14px;"], [145, "        font-weight: 700;"], [146, "        border-bottom: 1px solid #CCC;"], [147, "        position: relative;"], [148, "        -webkit-transition: all 0.4s ease;"], [149, "        -o-transition: all 0.4s ease;"], [150, "        transition: all 0.4s ease;"], [151, "}"], [152, ""], [153, ".accordion li:last-child .link {"], [154, "        border-bottom: 0;"], [155, "}"], [156, ""], [157, ".accordion li i {"], [158, "        position: absolute;"], [159, "        top: 16px;"], [160, "        left: 12px;"], [161, "        font-size: 18px;"], [162, "        color: #595959;"], [163, "        -webkit-transition: all 0.4s ease;"], [164, "        -o-transition: all 0.4s ease;"], [165, "        transition: all 0.4s ease;"], [166, "}"], [167, ""], [168, ".accordion li i.fa-chevron-down {"], [169, "        right: 12px;"], [170, "        left: auto;"], [171, "        font-size: 16px;"], [172, "}"], [173, ""], [174, ".accordion li.open .link {"], [175, "        color: #b63b4d;"], [176, "}"], [177, ""], [178, ".accordion li.open i {"], [179, "        color: #b63b4d;"], [180, "}"], [181, ".accordion li.open i.fa-chevron-down {"], [182, "        -webkit-transform: rotate(180deg);"], [183, "        -ms-transform: rotate(180deg);"], [184, "        -o-transform: rotate(180deg);"], [185, "        transform: rotate(180deg);"], [186, "}"], [187, ""], [188, ".accordion li.default .submenu {display: block;}"], [189, "/**"], [190, " * Submenu"], [191, " -----------------------------*/"], [192, " .submenu {"], [193, "        display: none;"], [194, "        background: #FE8103;"], [195, "        font-size: 14px;"], [196, " }"], [197, ""], [198, " .submenu li {"], [199, "        border-bottom: 1px solid white;"], [200, " }"], [201, ""], [202, " .submenu a {"], [203, "        display: block;"], [204, "        text-decoration: none;"], [205, "        color: #d9d9d9;"], [206, "        padding: 12px;"], [207, "        padding-left: 42px;"], [208, "        -webkit-transition: all 0.25s ease;"], [209, "        -o-transition: all 0.25s ease;"], [210, "        transition: all 0.25s ease;"], [211, " }"], [212, ""], [213, " .submenu a:hover {"], [214, "        background: #801B0C;"], [215, "        color: #FFF;"], [216, " }"], [217, ""], [218, ""], [219, "</style>"], [220, ""], [221, ""], [222, "<!-- Modal -->"], [223, "<div id=\\\"myModal\\\" class=\\\"modal fade\\\" role=\\\"dialog\\\">"], [224, "  <div class=\\\"modal-dialog\\\">"], [225, ""], [226, "    <!-- Modal content-->"], [227, "    <div class=\\\"modal-content\\\">"], [228, "      <div class=\\\"modal-header\\\">"], [229, "        <button type=\\\"button\\\" class=\\\"close\\\" data-dismiss=\\\"modal\\\">&times;</button>"], [230, "        <h4 class=\\\"modal-title\\\">Info</h4>"], [231, "      </div>"], [232, "      <div class=\\\"modal-body\\\">"], [233, "        <p>body text</p>"], [234, "      </div>"], [235, "      <div class=\\\"modal-footer\\\">"], [236, "        <button type=\\\"button\\\" class=\\\"btn btn-default\\\" data-dismiss=\\\"modal\\\">Close</button>"], [237, "      </div>"], [238, "    </div>"], [239, ""], [240, "  </div>"], [241, "</div>"], [242, ""], [243, ""], [244, "<script>"], [245, "\\$(function() {"], [246, ""], [247, "var movementStrength = 25;"], [248, "var height = movementStrength / \\$(window).height();"], [249, "var width = movementStrength / \\$(window).width();"], [250, "\\$(\\\"body\\\").mousemove(function(e){"], [251, "          var pageX = e.pageX - (\\$(window).width() / 2);"], [252, "          var pageY = e.pageY - (\\$(window).height() / 2);"], [253, "          var newvalueX = width * pageX * -1 - 25;"], [254, "          var newvalueY = height * pageY * -1 - 50;"], [255, "          \\$('#top-image').css(\\\"background-position\\\", newvalueX+\\\"px     \\\"+newvalueY+\\\"px\\\");"], [256, "});"], [257, "\\$(\\\"#search\\\").keyup(function(){"], [258, "        \\$('.top-domain').each(function(i, obj) {"], [259, "                if(\\$(this).text().indexOf(\\$(\\\"#search\\\").val()) == -1){"], [260, "                        \\$(this).hide();"], [261, "                }else{"], [262, "                        \\$(this).show();"], [263, "                }"], [264, "        });"], [265, "});"], [266, ""], [267, ""], [268, "\\$(\\\".subdomain\\\").on('click',function(){"], [269, "        \\$(\\\".modal-body\\\").text(\\\"\\\");"], [270, "        \\$(\\\".modal-body\\\").append(\\\"Domain: <b>\\\"+\\$(this).children().text()+\\\"</b>\\\");"], [271, "        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");"], [272, "        \\$(\\\".modal-body\\\").append(\\\"Last Modified: <b>\\\"+\\$(this).attr(\\\"added\\\")+\\\"</b>\\\");"], [273, "        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");"], [274, "        \\$(\\\".modal-body\\\").append(\\\"Active: <b>\\\"+\\$(this).attr(\\\"active\\\").replace(\\\"1\\\", \\\"Yes\\\").replace(\\\"0\\\", \\\"No\\\")+\\\"</b>\\\");"], [275, "        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");"], [276, "        \\$(\\\".modal-body\\\").append(\\\"Inscope: <b>\\\"+\\$(this).attr(\\\"inscope\\\").replace(\\\"1\\\", \\\"Yes\\\").replace(\\\"0\\\", \\\"No\\\")+\\\"</b>\\\");"], [277, "        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");"], [278, "        \\$(\\\".modal-body\\\").append(\\\"Program: <b>\\\"+\\$(this).attr(\\\"program\\\")+\\\"</b>\\\");"], [279, ""], [280, ""], [281, "        \\$('#myModal').modal('show');"], [282, "});"], [283, ""], [284, "        var Accordion = function(el, multiple) {"], [285, "                this.el = el || {};"], [286, "                this.multiple = multiple || false;"], [287, ""], [288, "                // Variables privadas"], [289, "                var links = this.el.find('.link');"], [290, "                // Evento"], [291, "                links.on('click', {el: this.el, multiple: this.multiple}, this.dropdown)"], [292, "        }"], [293, ""], [294, "        Accordion.prototype.dropdown = function(e) {"], [295, "                var \\$el = e.data.el;"], [296, "                        \\$this = \\$(this),"], [297, "                        \\$next = \\$this.next();"], [298, ""], [299, "                \\$next.slideToggle();"], [300, "                \\$this.parent().toggleClass('open');"], [301, ""], [302, "                if (!e.data.multiple) {"], [303, "                        \\$el.find('.submenu').not(\\$next).slideUp().parent().removeClass('open');"], [304, "                };"], [305, "        }"], [306, ""], [307, "        var accordion = new Accordion(\\$('#accordion'), false);"], [308, "});"], [309, "</script>"], [310, "</div>"], [311, "</body>"], [312, ""], [313, "\" > /var/www/html/ICU.php"]], "deleted": []}, "added_lines": 313, "deleted_lines": 0, "source_code": "echo \"\n<html>\n<head>\n  <link rel=\\\"stylesheet\\\" href=\\\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\\\">\n   <link rel=\\\"stylesheet\\\" href=\\\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\\\">\n  <script src=\\\"https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js\\\"></script>\n  <script src=\\\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\\\"></script>\n</head>\n<body>\n<div id=\\\"top-image\\\" style=\\\"overflow-y: scroll;\\\">\n<?php\n\\$servername = \\\"$3\\\";\n\\$username = \\\"$1\\\";\n\\$password = \\\"$2\\\";\n\\$dbname = \\\"recon\\\";\n\n\\$conn = new mysqli(\\$servername, \\$username, \\$password, \\$dbname);\n\nif (\\$conn->connect_error) {\n    die(\\\"Connection failed: \\\" . \\$conn->connect_error);\n}\n\n\\$sql = \\\"SELECT * FROM domains ORDER BY Active\\\";\n\n\\$result = \\$conn->query(\\$sql);\n\nif (\\$result->num_rows > 0) {\n    while(\\$row = \\$result->fetch_assoc()) {\n        \\$rows[] = \\$row;\n   }\n} else {\n    echo \\\"0 results\\\";\n}\n\\$conn->close();\n\n\\$domains = array();\n\n        foreach (\\$rows as \\$r) {\n                if(empty(\\$r[\\\"TopDomainID\\\"])){\n                        \\$subdomains = array();\n                        foreach (\\$rows as \\$r2) {\n                                if(\\$r2[\\\"TopDomainID\\\"] == \\$r[\\\"DomainID\\\"]){\n                                        array_push(\\$subdomains, \\$r2);\n                                }\n                        }\n                        array_push(\\$domains, array(\\$r, \\$subdomains));\n                }\n\n        }\n?>\n\n<ul id=\\\"accordion\\\" class=\\\"accordion\\\">\n        <li>\n                <div class=\\\"link\\\" style=\\\"\\\">\n                        <i class=\\\"fa fa-search\\\" style=\\\"margin-top: 5px;\\\" ></i>\n                        <input type=\\\"text\\\" class=\\\"form-control\\\" id=\\\"search\\\">\n                </div>\n        </li>\n        <?php\n                foreach (\\$domains as &\\$domain) {\n                        if(\\$domain != ''){\n                        echo '\n                        <li><div class=\\\"link top-domain\\\"><i class=\\\"fa fa-globe\\\"></i>'.\\$domain[0][\\\"Domain\\\"].'<i class=\\\"fa fa-chevron-down\\\"></i></div>\n                                <ul class=\\\"submenu\\\">';\n                                        \\$domain[1] = array_reverse(\\$domain[1], true);\n                                        foreach (\\$domain[1] as \\$d) {\n                                                echo '<li class=\\\"subdomain\\\" added=\\\"'.\\$d[\\\"LastModified\\\"].'\\\" active=\\\"'.\\$d[\\\"Active\\\"].'\\\" inscope=\\\"'.\\$d[\\\"InScope\\\"].'\\\" program=\\\"'.\\$d[\\\"Program\\\"].'\\\"><a href=\\\"#\\\">'.\\$d[\\\"Domain\\\"].'</a></li>';\n                                        }\n                        echo '</ul></li>';\n                        }\n                }\n        ?>\n</ul>\n\n<style>\n.modal-backdrop {\ntop: -5000px !important;\nposition: static;\n}\n\n#top-image {\nbackground:url('http://goldwallpapers.com/uploads/posts/google-data-center-wallpaper/google_data_center_wallpaper_013.jpg') -25px -50px;\nposition:fixed ;\ntop:0;\nwidth:100%;\nz-index:0;\n  height:100%;\n  background-size: calc(100% + 50px);\n}\n\n* {\n        margin: 0;\n        padding: 0;\n        -webkit-box-sizing: border-box;\n        -moz-box-sizing: border-box;\n        box-sizing: border-box;\n}\n\nbody {\n        background: #2d2c41;\n        font-family: 'Open Sans', Arial, Helvetica, Sans-serif, Verdana, Tahoma;\n}\n\nul {\n        list-style-type: none;\n}\n\na {\n        color: #b63b4d;\n        text-decoration: none;\n}\n\n/** =======================\n * Contenedor Principal\n ===========================*/\nh1 {\n        color: #FFF;\n        font-size: 24px;\n        font-weight: 400;\n        text-align: center;\n        margin-top: 80px;\n }\n\nh1 a {\n        color: #c12c42;\n        font-size: 16px;\n }\n\n .accordion {\n        width: 100%;\n        max-width: 360px;\n        margin: 30px auto 20px;\n        background: #FFF;\n        -webkit-border-radius: 4px;\n        -moz-border-radius: 4px;\n        border-radius: 4px;\n }\n\n.accordion .link {\n        cursor: pointer;\n        display: block;\n        padding: 15px 15px 15px 42px;\n        color: #4D4D4D;\n        font-size: 14px;\n        font-weight: 700;\n        border-bottom: 1px solid #CCC;\n        position: relative;\n        -webkit-transition: all 0.4s ease;\n        -o-transition: all 0.4s ease;\n        transition: all 0.4s ease;\n}\n\n.accordion li:last-child .link {\n        border-bottom: 0;\n}\n\n.accordion li i {\n        position: absolute;\n        top: 16px;\n        left: 12px;\n        font-size: 18px;\n        color: #595959;\n        -webkit-transition: all 0.4s ease;\n        -o-transition: all 0.4s ease;\n        transition: all 0.4s ease;\n}\n\n.accordion li i.fa-chevron-down {\n        right: 12px;\n        left: auto;\n        font-size: 16px;\n}\n\n.accordion li.open .link {\n        color: #b63b4d;\n}\n\n.accordion li.open i {\n        color: #b63b4d;\n}\n.accordion li.open i.fa-chevron-down {\n        -webkit-transform: rotate(180deg);\n        -ms-transform: rotate(180deg);\n        -o-transform: rotate(180deg);\n        transform: rotate(180deg);\n}\n\n.accordion li.default .submenu {display: block;}\n/**\n * Submenu\n -----------------------------*/\n .submenu {\n        display: none;\n        background: #FE8103;\n        font-size: 14px;\n }\n\n .submenu li {\n        border-bottom: 1px solid white;\n }\n\n .submenu a {\n        display: block;\n        text-decoration: none;\n        color: #d9d9d9;\n        padding: 12px;\n        padding-left: 42px;\n        -webkit-transition: all 0.25s ease;\n        -o-transition: all 0.25s ease;\n        transition: all 0.25s ease;\n }\n\n .submenu a:hover {\n        background: #801B0C;\n        color: #FFF;\n }\n\n\n</style>\n\n\n<!-- Modal -->\n<div id=\\\"myModal\\\" class=\\\"modal fade\\\" role=\\\"dialog\\\">\n  <div class=\\\"modal-dialog\\\">\n\n    <!-- Modal content-->\n    <div class=\\\"modal-content\\\">\n      <div class=\\\"modal-header\\\">\n        <button type=\\\"button\\\" class=\\\"close\\\" data-dismiss=\\\"modal\\\">&times;</button>\n        <h4 class=\\\"modal-title\\\">Info</h4>\n      </div>\n      <div class=\\\"modal-body\\\">\n        <p>body text</p>\n      </div>\n      <div class=\\\"modal-footer\\\">\n        <button type=\\\"button\\\" class=\\\"btn btn-default\\\" data-dismiss=\\\"modal\\\">Close</button>\n      </div>\n    </div>\n\n  </div>\n</div>\n\n\n<script>\n\\$(function() {\n\nvar movementStrength = 25;\nvar height = movementStrength / \\$(window).height();\nvar width = movementStrength / \\$(window).width();\n\\$(\\\"body\\\").mousemove(function(e){\n          var pageX = e.pageX - (\\$(window).width() / 2);\n          var pageY = e.pageY - (\\$(window).height() / 2);\n          var newvalueX = width * pageX * -1 - 25;\n          var newvalueY = height * pageY * -1 - 50;\n          \\$('#top-image').css(\\\"background-position\\\", newvalueX+\\\"px     \\\"+newvalueY+\\\"px\\\");\n});\n\\$(\\\"#search\\\").keyup(function(){\n        \\$('.top-domain').each(function(i, obj) {\n                if(\\$(this).text().indexOf(\\$(\\\"#search\\\").val()) == -1){\n                        \\$(this).hide();\n                }else{\n                        \\$(this).show();\n                }\n        });\n});\n\n\n\\$(\\\".subdomain\\\").on('click',function(){\n        \\$(\\\".modal-body\\\").text(\\\"\\\");\n        \\$(\\\".modal-body\\\").append(\\\"Domain: <b>\\\"+\\$(this).children().text()+\\\"</b>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"Last Modified: <b>\\\"+\\$(this).attr(\\\"added\\\")+\\\"</b>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"Active: <b>\\\"+\\$(this).attr(\\\"active\\\").replace(\\\"1\\\", \\\"Yes\\\").replace(\\\"0\\\", \\\"No\\\")+\\\"</b>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"Inscope: <b>\\\"+\\$(this).attr(\\\"inscope\\\").replace(\\\"1\\\", \\\"Yes\\\").replace(\\\"0\\\", \\\"No\\\")+\\\"</b>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"Program: <b>\\\"+\\$(this).attr(\\\"program\\\")+\\\"</b>\\\");\n\n\n        \\$('#myModal').modal('show');\n});\n\n        var Accordion = function(el, multiple) {\n                this.el = el || {};\n                this.multiple = multiple || false;\n\n                // Variables privadas\n                var links = this.el.find('.link');\n                // Evento\n                links.on('click', {el: this.el, multiple: this.multiple}, this.dropdown)\n        }\n\n        Accordion.prototype.dropdown = function(e) {\n                var \\$el = e.data.el;\n                        \\$this = \\$(this),\n                        \\$next = \\$this.next();\n\n                \\$next.slideToggle();\n                \\$this.parent().toggleClass('open');\n\n                if (!e.data.multiple) {\n                        \\$el.find('.submenu').not(\\$next).slideUp().parent().removeClass('open');\n                };\n        }\n\n        var accordion = new Accordion(\\$('#accordion'), false);\n});\n</script>\n</div>\n</body>\n\n\" > /var/www/html/ICU.php\n", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "37f6eb4512fb9cd4a426e144fd36938684149234", "msg": "small updates", "author": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "committer": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "author_date": "2018-05-31 23:47:07+02:00", "author_timezone": -7200, "committer_date": "2018-05-31 23:47:07+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["4d4bf27590223ea90b3e2d962afd5f55bf5dc35e"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 16, "insertions": 14, "lines": 30, "files": 1, "modified_files": [{"old_path": "README.md", "new_path": "README.md", "filename": "README.md", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -1,21 +1,19 @@\n-## \ud83d\udccc Description\n+## \ud83d\udccc Description \n \n-# Install\n-```bash ./install.sh ``` The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always \n-change these credentials later on.\n+# Install \n+```bash ./install.sh ``` The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n \n-# Telegram\n-ICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot \n-token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id \n-to credentials.py so it can be used for authentication with the bot, and to send the notifications to.\n-\n-# Modules\n-The following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time.\n+# Telegram \n+ICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n+ \n+# Modules \n+The following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n  \n-the install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then \n-install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to \n-install MySQLdb.\n+The install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n \n # Extra\n-To get ICU up and running, requires some simple skills. \ud83d\udc4c *Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - \n-[003random.com](https://poc-server.com/blog/)*\n+To get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n+ \n+ \n+*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n+\n", "diff_parsed": {"added": [[1, "## \ud83d\udccc Description"], [3, "# Install"], [4, "```bash ./install.sh ``` The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on."], [6, "# Telegram"], [7, "ICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to."], [8, ""], [9, "# Modules"], [10, "The following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time."], [12, "The install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb."], [15, "To get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter."], [16, ""], [17, ""], [18, "*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*"], [19, ""]], "deleted": [[1, "## \ud83d\udccc Description"], [3, "# Install"], [4, "```bash ./install.sh ``` The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always"], [5, "change these credentials later on."], [7, "# Telegram"], [8, "ICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot"], [9, "token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id"], [10, "to credentials.py so it can be used for authentication with the bot, and to send the notifications to."], [11, ""], [12, "# Modules"], [13, "The following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time."], [15, "the install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then"], [16, "install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to"], [17, "install MySQLdb."], [20, "To get ICU up and running, requires some simple skills. \ud83d\udc4c *Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) -"], [21, "[003random.com](https://poc-server.com/blog/)*"]]}, "added_lines": 14, "deleted_lines": 16, "source_code": "## \ud83d\udccc Description \n\n# Install \n```bash ./install.sh ``` The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n", "source_code_before": "## \ud83d\udccc Description\n\n# Install\n```bash ./install.sh ``` The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always \nchange these credentials later on.\n\n# Telegram\nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot \ntoken [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id \nto credentials.py so it can be used for authentication with the bot, and to send the notifications to.\n\n# Modules\nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time.\n \nthe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then \ninstall these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to \ninstall MySQLdb.\n\n# Extra\nTo get ICU up and running, requires some simple skills. \ud83d\udc4c *Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - \n[003random.com](https://poc-server.com/blog/)*\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "846f91c2ce56911d51ea21ecb5a640fdcb840eda", "msg": "small telegram update", "author": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "committer": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "author_date": "2018-06-01 00:10:22+02:00", "author_timezone": -7200, "committer_date": "2018-06-01 00:10:22+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["37f6eb4512fb9cd4a426e144fd36938684149234"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 0, "insertions": 2, "lines": 2, "files": 1, "modified_files": [{"old_path": "telegram/setup.py", "new_path": "telegram/setup.py", "filename": "setup.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -45,6 +45,8 @@ def main():\n \tupdater = Updater(telegram_bot_token)\n \tdp = updater.dispatcher\n \n+\tprint \"[!] Send /start to the bot.\"\n+\n \tconv_handler = ConversationHandler(\n \t\tentry_points=[CommandHandler('start', start)],\n \n", "diff_parsed": {"added": [[48, "\tprint \"[!] Send /start to the bot.\""], [49, ""]], "deleted": []}, "added_lines": 2, "deleted_lines": 0, "source_code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport telegram, sys, os, logging, datetime\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\nimport credentials\n\ntelegram_bot_token = credentials.telegram_bot_token\n\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\nlogger = logging.getLogger(__name__)\n\ndef start(bot, update):\n\tuser = update.message.from_user\n\tchat_id = str(update.message.chat_id)\n\n\twith open(os.path.dirname(os.path.abspath(__file__)) + \"/../credentials.py\") as f:\n\t\tvar_lines = f.readlines()\n\t\tvar_lines = [x.strip() for x in var_lines]\n\tf.close()\n\n\tnew_lines = []\n\n\tfor line in var_lines:\n\t\tif line.startswith(\"telegram_chat_id\"):\n\t\t\tnew_lines.append(\"telegram_chat_id = \\\"\" + str(chat_id) + \"\\\"\")\n\t\telse:\n\t\t\tnew_lines.append(line)\n\n\tcreds = open(os.path.dirname(os.path.abspath(__file__)) + \"/../credentials.py\", 'w')\n\tfor item in new_lines:\n\t\tif item:\n\t\t\tcreds.write(\"%s\\n\" % item)\n\tcreds.close()\n\tupdate.message.reply_text(\"Welcome \" + str(user['first_name']) + \"! The telegram setup is successfully finished.\")\n\tprint \"Success! You can now close the setup with ctr + c\"\n\treturn ConversationHandler.END\n\ndef main():\n\tupdater = Updater(telegram_bot_token)\n\tdp = updater.dispatcher\n\n\tprint \"[!] Send /start to the bot.\"\n\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\tupdater.start_polling()\n\tupdater.idle()\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treturn ConversationHandler.END\n\nif __name__ == '__main__':\n\tmain()\n", "source_code_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport telegram, sys, os, logging, datetime\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\nimport credentials\n\ntelegram_bot_token = credentials.telegram_bot_token\n\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\nlogger = logging.getLogger(__name__)\n\ndef start(bot, update):\n\tuser = update.message.from_user\n\tchat_id = str(update.message.chat_id)\n\n\twith open(os.path.dirname(os.path.abspath(__file__)) + \"/../credentials.py\") as f:\n\t\tvar_lines = f.readlines()\n\t\tvar_lines = [x.strip() for x in var_lines]\n\tf.close()\n\n\tnew_lines = []\n\n\tfor line in var_lines:\n\t\tif line.startswith(\"telegram_chat_id\"):\n\t\t\tnew_lines.append(\"telegram_chat_id = \\\"\" + str(chat_id) + \"\\\"\")\n\t\telse:\n\t\t\tnew_lines.append(line)\n\n\tcreds = open(os.path.dirname(os.path.abspath(__file__)) + \"/../credentials.py\", 'w')\n\tfor item in new_lines:\n\t\tif item:\n\t\t\tcreds.write(\"%s\\n\" % item)\n\tcreds.close()\n\tupdate.message.reply_text(\"Welcome \" + str(user['first_name']) + \"! The telegram setup is successfully finished.\")\n\tprint \"Success! You can now close the setup with ctr + c\"\n\treturn ConversationHandler.END\n\ndef main():\n\tupdater = Updater(telegram_bot_token)\n\tdp = updater.dispatcher\n\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\tupdater.start_polling()\n\tupdater.idle()\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treturn ConversationHandler.END\n\nif __name__ == '__main__':\n\tmain()\n", "methods": [{"name": "start", "start_line": 18, "end_line": 42}, {"name": "main", "start_line": 44, "end_line": 61}, {"name": "cancel", "start_line": 63, "end_line": 65}], "methods_before": [{"name": "start", "start_line": 18, "end_line": 42}, {"name": "main", "start_line": 44, "end_line": 59}, {"name": "cancel", "start_line": 61, "end_line": 63}], "changed_methods": [{"name": "main", "start_line": 44, "end_line": 61}], "nloc": 48, "complexity": 8, "token_count": 359}], "dmm_unit_size": 1.0, "dmm_unit_complexity": 1.0, "dmm_unit_interfacing": 1.0},
    {"hash": "9a4e3952aaccdf6fd93a3e22369d7fdc199d6ced", "msg": "added amass and subfinder && update web interface", "author": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "committer": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "author_date": "2018-06-04 23:15:30+02:00", "author_timezone": -7200, "committer_date": "2018-06-04 23:15:30+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["846f91c2ce56911d51ea21ecb5a640fdcb840eda"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 1, "insertions": 24, "lines": 25, "files": 2, "modified_files": [{"old_path": "database/additional_tools/domains_db.py", "new_path": "database/additional_tools/domains_db.py", "filename": "domains_db.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -18,6 +18,15 @@ try:\n \t#Add new subdomain scanners here. Make sure to let them save the output to /tmp/ICU/{domain}/doains-all.txt\n \tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n \ttime.sleep(2)\n+\n+\t#Subfinder\n+\tos.system(\"subfinder -d \" + domain + \" -v -o /tmp/ICU/\"+domain+\"/domains-subfinder.txt --timeout 6\")\n+\ttime.sleep(2)\n+\n+\t#Amass\n+\tos.system(\"amass -o /tmp/ICU/\"+domain+\"/domains-amass.txt -d \" + domain)\n+        time.sleep(2)\n+\n \t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on\n \tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n \tdatabase_data = cursor.fetchall()\n@@ -29,6 +38,16 @@ try:\n \n \t#All the domains from the subdomain scanners\n \tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n+\n+\t#Domains from subfinder\n+\tdomains_subfinder = open(\"/tmp/ICU/\"+domain+\"/domains-subfinder.txt\",'r').read().split('\\n')\n+\n+        #Domains from amass\n+        domains_subfinder = open(\"/tmp/ICU/\"+domain+\"/domains-amass.txt\",'r').read().split('\\n')\n+\n+        #Add all the subfinder subdomain to it\n+        domains_all.extend(x for x in domains_subfinder if x not in domains_all)\n+\n \t#Add all the database subdomain to it\n \tdomains_all.extend(x for x in database_domains if x not in domains_all)\n \t#Make it unique\n", "diff_parsed": {"added": [[21, ""], [22, "\t#Subfinder"], [23, "\tos.system(\"subfinder -d \" + domain + \" -v -o /tmp/ICU/\"+domain+\"/domains-subfinder.txt --timeout 6\")"], [24, "\ttime.sleep(2)"], [25, ""], [26, "\t#Amass"], [27, "\tos.system(\"amass -o /tmp/ICU/\"+domain+\"/domains-amass.txt -d \" + domain)"], [28, "        time.sleep(2)"], [29, ""], [41, ""], [42, "\t#Domains from subfinder"], [43, "\tdomains_subfinder = open(\"/tmp/ICU/\"+domain+\"/domains-subfinder.txt\",'r').read().split('\\n')"], [44, ""], [45, "        #Domains from amass"], [46, "        domains_subfinder = open(\"/tmp/ICU/\"+domain+\"/domains-amass.txt\",'r').read().split('\\n')"], [47, ""], [48, "        #Add all the subfinder subdomain to it"], [49, "        domains_all.extend(x for x in domains_subfinder if x not in domains_all)"], [50, ""]], "deleted": []}, "added_lines": 19, "deleted_lines": 0, "source_code": "#!/usr/bin/python\nimport os, sys, MySQLdb, time\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../../\")\nimport credentials\n\ntry:\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tdomain = sys.argv[1].strip()\n\tcursor = connection.cursor()\n\tscanId = sys.argv[2]\n\n\tif not os.path.exists(\"/tmp/ICU\"):\n\t\tos.makedirs(\"/tmp/ICU\")\n\n\tif not os.path.exists(\"/tmp/ICU/\"+domain+\"/\"):\n\t    os.makedirs(\"/tmp/ICU/\"+domain+\"/\")\n\n\t#Add new subdomain scanners here. Make sure to let them save the output to /tmp/ICU/{domain}/doains-all.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n\ttime.sleep(2)\n\n\t#Subfinder\n\tos.system(\"subfinder -d \" + domain + \" -v -o /tmp/ICU/\"+domain+\"/domains-subfinder.txt --timeout 6\")\n\ttime.sleep(2)\n\n\t#Amass\n\tos.system(\"amass -o /tmp/ICU/\"+domain+\"/domains-amass.txt -d \" + domain)\n        time.sleep(2)\n\n\t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on\n\tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n\tdatabase_data = cursor.fetchall()\n\tdatabase_domains = [d[0] for d in database_data]\n\n        non_active_subdomains = [x[0] for x in database_data if ord(x[2]) == False]\n        program = [x[3] for x in database_data if x[0] == domain][0]\n        topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n\n\t#All the domains from the subdomain scanners\n\tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n\n\t#Domains from subfinder\n\tdomains_subfinder = open(\"/tmp/ICU/\"+domain+\"/domains-subfinder.txt\",'r').read().split('\\n')\n\n        #Domains from amass\n        domains_subfinder = open(\"/tmp/ICU/\"+domain+\"/domains-amass.txt\",'r').read().split('\\n')\n\n        #Add all the subfinder subdomain to it\n        domains_all.extend(x for x in domains_subfinder if x not in domains_all)\n\n\t#Add all the database subdomain to it\n\tdomains_all.extend(x for x in database_domains if x not in domains_all)\n\t#Make it unique\n\tdomains_all = list(set(domains_all))\n\n\t#Put all the online domains in a domains-online.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")\n\n\t#Convert online domains to array\n\tdomains_online = open(\"/tmp/ICU/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n\n\t#Loop through every subdomain\n\tfor sub_domain in domains_all:\n\t\t#Get the scanID to insert. If the domains was already in the db and isnt changed, then keep the old scanID. otherwise use the scanID of the current scan\n\t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n\n\t\t#If the subdomain is online\n\t\tif sub_domain in domains_online:\n\t\t\tactive=True\n\t\t\t#If the subdomain used to be offline, give it the current scanID\n\t\t\tif sub_domain in non_active_subdomains:\n\t\t\t\tinsertScanId = scanId\n\t\telse:\n\t\t\tactive=False\n\n\n\t\tif sub_domain:\n\t\t\t#Insert the new values, or update them if they already existed\n\t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))\n\t\t\tconnection.commit()\n\n\tcursor.close ()\n\tconnection.close ()\nexcept Exception as e:\n\t#Handle the errors, and save them to the database\n\tprint \"error in domains_db.py with main domain; \" + domain\n\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in domains_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n\tconnection.commit()\n\tcursor.close()\n\tconnection.close()\n\tprint e\nsys.exit()\n", "source_code_before": "#!/usr/bin/python\nimport os, sys, MySQLdb, time\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../../\")\nimport credentials\n\ntry:\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tdomain = sys.argv[1].strip()\n\tcursor = connection.cursor()\n\tscanId = sys.argv[2]\n\n\tif not os.path.exists(\"/tmp/ICU\"):\n\t\tos.makedirs(\"/tmp/ICU\")\n\n\tif not os.path.exists(\"/tmp/ICU/\"+domain+\"/\"):\n\t    os.makedirs(\"/tmp/ICU/\"+domain+\"/\")\n\n\t#Add new subdomain scanners here. Make sure to let them save the output to /tmp/ICU/{domain}/doains-all.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n\ttime.sleep(2)\n\t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on\n\tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n\tdatabase_data = cursor.fetchall()\n\tdatabase_domains = [d[0] for d in database_data]\n\n        non_active_subdomains = [x[0] for x in database_data if ord(x[2]) == False]\n        program = [x[3] for x in database_data if x[0] == domain][0]\n        topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n\n\t#All the domains from the subdomain scanners\n\tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n\t#Add all the database subdomain to it\n\tdomains_all.extend(x for x in database_domains if x not in domains_all)\n\t#Make it unique\n\tdomains_all = list(set(domains_all))\n\n\t#Put all the online domains in a domains-online.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")\n\n\t#Convert online domains to array\n\tdomains_online = open(\"/tmp/ICU/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n\n\t#Loop through every subdomain\n\tfor sub_domain in domains_all:\n\t\t#Get the scanID to insert. If the domains was already in the db and isnt changed, then keep the old scanID. otherwise use the scanID of the current scan\n\t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n\n\t\t#If the subdomain is online\n\t\tif sub_domain in domains_online:\n\t\t\tactive=True\n\t\t\t#If the subdomain used to be offline, give it the current scanID\n\t\t\tif sub_domain in non_active_subdomains:\n\t\t\t\tinsertScanId = scanId\n\t\telse:\n\t\t\tactive=False\n\n\n\t\tif sub_domain:\n\t\t\t#Insert the new values, or update them if they already existed\n\t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))\n\t\t\tconnection.commit()\n\n\tcursor.close ()\n\tconnection.close ()\nexcept Exception as e:\n\t#Handle the errors, and save them to the database\n\tprint \"error in domains_db.py with main domain; \" + domain\n\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in domains_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n\tconnection.commit()\n\tcursor.close()\n\tconnection.close()\n\tprint e\nsys.exit()\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": 53, "complexity": 0, "token_count": 619}, {"old_path": "web/setup.sh", "new_path": "web/setup.sh", "filename": "setup.sh", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -64,7 +64,11 @@ if (\\$result->num_rows > 0) {\n                                 <ul class=\\\"submenu\\\">';\n                                         \\$domain[1] = array_reverse(\\$domain[1], true);\n                                         foreach (\\$domain[1] as \\$d) {\n-                                                echo '<li class=\\\"subdomain\\\" added=\\\"'.\\$d[\\\"LastModified\\\"].'\\\" active=\\\"'.\\$d[\\\"Active\\\"].'\\\" inscope=\\\"'.\\$d[\\\"InScope\\\"].'\\\" program=\\\"'.\\$d[\\\"Program\\\"].'\\\"><a href=\\\"#\\\">'.\\$d[\\\"Domain\\\"].'</a></li>';\n+                                                if((string)\\$d[\\\"Active\\\"] == \\\"0\\\"){\n+                                                        echo '<li  class=\\\"subdomain\\\" added=\\\"'.\\$d[\\\"LastModified\\\"].'\\\" active=\\\"'.\\$d[\\\"Active\\\"].'\\\" inscope=\\\"'.\\$d[\\\"InScope\\\"].'\\\" program=\\\"'.\\$d[\\\"Program\\\"].'\\\"><del><a href=\\\"#\\\">'.\\$d[\\\"Domain\\\"].'</a></del></li>';\n+                                                } else {\n+                                                        echo '<li class=\\\"subdomain\\\" added=\\\"'.\\$d[\\\"LastModified\\\"].'\\\" active=\\\"'.\\$d[\\\"Active\\\"].'\\\" inscope=\\\"'.\\$d[\\\"InScope\\\"].'\\\" program=\\\"'.\\$d[\\\"Program\\\"].'\\\"><a href=\\\"#\\\">'.\\$d[\\\"Domain\\\"].'</a></li>';\n+                                                }\n                                         }\n                         echo '</ul></li>';\n                         }\n", "diff_parsed": {"added": [[67, "                                                if((string)\\$d[\\\"Active\\\"] == \\\"0\\\"){"], [68, "                                                        echo '<li  class=\\\"subdomain\\\" added=\\\"'.\\$d[\\\"LastModified\\\"].'\\\" active=\\\"'.\\$d[\\\"Active\\\"].'\\\" inscope=\\\"'.\\$d[\\\"InScope\\\"].'\\\" program=\\\"'.\\$d[\\\"Program\\\"].'\\\"><del><a href=\\\"#\\\">'.\\$d[\\\"Domain\\\"].'</a></del></li>';"], [69, "                                                } else {"], [70, "                                                        echo '<li class=\\\"subdomain\\\" added=\\\"'.\\$d[\\\"LastModified\\\"].'\\\" active=\\\"'.\\$d[\\\"Active\\\"].'\\\" inscope=\\\"'.\\$d[\\\"InScope\\\"].'\\\" program=\\\"'.\\$d[\\\"Program\\\"].'\\\"><a href=\\\"#\\\">'.\\$d[\\\"Domain\\\"].'</a></li>';"], [71, "                                                }"]], "deleted": [[67, "                                                echo '<li class=\\\"subdomain\\\" added=\\\"'.\\$d[\\\"LastModified\\\"].'\\\" active=\\\"'.\\$d[\\\"Active\\\"].'\\\" inscope=\\\"'.\\$d[\\\"InScope\\\"].'\\\" program=\\\"'.\\$d[\\\"Program\\\"].'\\\"><a href=\\\"#\\\">'.\\$d[\\\"Domain\\\"].'</a></li>';"]]}, "added_lines": 5, "deleted_lines": 1, "source_code": "echo \"\n<html>\n<head>\n  <link rel=\\\"stylesheet\\\" href=\\\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\\\">\n   <link rel=\\\"stylesheet\\\" href=\\\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\\\">\n  <script src=\\\"https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js\\\"></script>\n  <script src=\\\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\\\"></script>\n</head>\n<body>\n<div id=\\\"top-image\\\" style=\\\"overflow-y: scroll;\\\">\n<?php\n\\$servername = \\\"$3\\\";\n\\$username = \\\"$1\\\";\n\\$password = \\\"$2\\\";\n\\$dbname = \\\"recon\\\";\n\n\\$conn = new mysqli(\\$servername, \\$username, \\$password, \\$dbname);\n\nif (\\$conn->connect_error) {\n    die(\\\"Connection failed: \\\" . \\$conn->connect_error);\n}\n\n\\$sql = \\\"SELECT * FROM domains ORDER BY Active\\\";\n\n\\$result = \\$conn->query(\\$sql);\n\nif (\\$result->num_rows > 0) {\n    while(\\$row = \\$result->fetch_assoc()) {\n        \\$rows[] = \\$row;\n   }\n} else {\n    echo \\\"0 results\\\";\n}\n\\$conn->close();\n\n\\$domains = array();\n\n        foreach (\\$rows as \\$r) {\n                if(empty(\\$r[\\\"TopDomainID\\\"])){\n                        \\$subdomains = array();\n                        foreach (\\$rows as \\$r2) {\n                                if(\\$r2[\\\"TopDomainID\\\"] == \\$r[\\\"DomainID\\\"]){\n                                        array_push(\\$subdomains, \\$r2);\n                                }\n                        }\n                        array_push(\\$domains, array(\\$r, \\$subdomains));\n                }\n\n        }\n?>\n\n<ul id=\\\"accordion\\\" class=\\\"accordion\\\">\n        <li>\n                <div class=\\\"link\\\" style=\\\"\\\">\n                        <i class=\\\"fa fa-search\\\" style=\\\"margin-top: 5px;\\\" ></i>\n                        <input type=\\\"text\\\" class=\\\"form-control\\\" id=\\\"search\\\">\n                </div>\n        </li>\n        <?php\n                foreach (\\$domains as &\\$domain) {\n                        if(\\$domain != ''){\n                        echo '\n                        <li><div class=\\\"link top-domain\\\"><i class=\\\"fa fa-globe\\\"></i>'.\\$domain[0][\\\"Domain\\\"].'<i class=\\\"fa fa-chevron-down\\\"></i></div>\n                                <ul class=\\\"submenu\\\">';\n                                        \\$domain[1] = array_reverse(\\$domain[1], true);\n                                        foreach (\\$domain[1] as \\$d) {\n                                                if((string)\\$d[\\\"Active\\\"] == \\\"0\\\"){\n                                                        echo '<li  class=\\\"subdomain\\\" added=\\\"'.\\$d[\\\"LastModified\\\"].'\\\" active=\\\"'.\\$d[\\\"Active\\\"].'\\\" inscope=\\\"'.\\$d[\\\"InScope\\\"].'\\\" program=\\\"'.\\$d[\\\"Program\\\"].'\\\"><del><a href=\\\"#\\\">'.\\$d[\\\"Domain\\\"].'</a></del></li>';\n                                                } else {\n                                                        echo '<li class=\\\"subdomain\\\" added=\\\"'.\\$d[\\\"LastModified\\\"].'\\\" active=\\\"'.\\$d[\\\"Active\\\"].'\\\" inscope=\\\"'.\\$d[\\\"InScope\\\"].'\\\" program=\\\"'.\\$d[\\\"Program\\\"].'\\\"><a href=\\\"#\\\">'.\\$d[\\\"Domain\\\"].'</a></li>';\n                                                }\n                                        }\n                        echo '</ul></li>';\n                        }\n                }\n        ?>\n</ul>\n\n<style>\n.modal-backdrop {\ntop: -5000px !important;\nposition: static;\n}\n\n#top-image {\nbackground:url('http://goldwallpapers.com/uploads/posts/google-data-center-wallpaper/google_data_center_wallpaper_013.jpg') -25px -50px;\nposition:fixed ;\ntop:0;\nwidth:100%;\nz-index:0;\n  height:100%;\n  background-size: calc(100% + 50px);\n}\n\n* {\n        margin: 0;\n        padding: 0;\n        -webkit-box-sizing: border-box;\n        -moz-box-sizing: border-box;\n        box-sizing: border-box;\n}\n\nbody {\n        background: #2d2c41;\n        font-family: 'Open Sans', Arial, Helvetica, Sans-serif, Verdana, Tahoma;\n}\n\nul {\n        list-style-type: none;\n}\n\na {\n        color: #b63b4d;\n        text-decoration: none;\n}\n\n/** =======================\n * Contenedor Principal\n ===========================*/\nh1 {\n        color: #FFF;\n        font-size: 24px;\n        font-weight: 400;\n        text-align: center;\n        margin-top: 80px;\n }\n\nh1 a {\n        color: #c12c42;\n        font-size: 16px;\n }\n\n .accordion {\n        width: 100%;\n        max-width: 360px;\n        margin: 30px auto 20px;\n        background: #FFF;\n        -webkit-border-radius: 4px;\n        -moz-border-radius: 4px;\n        border-radius: 4px;\n }\n\n.accordion .link {\n        cursor: pointer;\n        display: block;\n        padding: 15px 15px 15px 42px;\n        color: #4D4D4D;\n        font-size: 14px;\n        font-weight: 700;\n        border-bottom: 1px solid #CCC;\n        position: relative;\n        -webkit-transition: all 0.4s ease;\n        -o-transition: all 0.4s ease;\n        transition: all 0.4s ease;\n}\n\n.accordion li:last-child .link {\n        border-bottom: 0;\n}\n\n.accordion li i {\n        position: absolute;\n        top: 16px;\n        left: 12px;\n        font-size: 18px;\n        color: #595959;\n        -webkit-transition: all 0.4s ease;\n        -o-transition: all 0.4s ease;\n        transition: all 0.4s ease;\n}\n\n.accordion li i.fa-chevron-down {\n        right: 12px;\n        left: auto;\n        font-size: 16px;\n}\n\n.accordion li.open .link {\n        color: #b63b4d;\n}\n\n.accordion li.open i {\n        color: #b63b4d;\n}\n.accordion li.open i.fa-chevron-down {\n        -webkit-transform: rotate(180deg);\n        -ms-transform: rotate(180deg);\n        -o-transform: rotate(180deg);\n        transform: rotate(180deg);\n}\n\n.accordion li.default .submenu {display: block;}\n/**\n * Submenu\n -----------------------------*/\n .submenu {\n        display: none;\n        background: #FE8103;\n        font-size: 14px;\n }\n\n .submenu li {\n        border-bottom: 1px solid white;\n }\n\n .submenu a {\n        display: block;\n        text-decoration: none;\n        color: #d9d9d9;\n        padding: 12px;\n        padding-left: 42px;\n        -webkit-transition: all 0.25s ease;\n        -o-transition: all 0.25s ease;\n        transition: all 0.25s ease;\n }\n\n .submenu a:hover {\n        background: #801B0C;\n        color: #FFF;\n }\n\n\n</style>\n\n\n<!-- Modal -->\n<div id=\\\"myModal\\\" class=\\\"modal fade\\\" role=\\\"dialog\\\">\n  <div class=\\\"modal-dialog\\\">\n\n    <!-- Modal content-->\n    <div class=\\\"modal-content\\\">\n      <div class=\\\"modal-header\\\">\n        <button type=\\\"button\\\" class=\\\"close\\\" data-dismiss=\\\"modal\\\">&times;</button>\n        <h4 class=\\\"modal-title\\\">Info</h4>\n      </div>\n      <div class=\\\"modal-body\\\">\n        <p>body text</p>\n      </div>\n      <div class=\\\"modal-footer\\\">\n        <button type=\\\"button\\\" class=\\\"btn btn-default\\\" data-dismiss=\\\"modal\\\">Close</button>\n      </div>\n    </div>\n\n  </div>\n</div>\n\n\n<script>\n\\$(function() {\n\nvar movementStrength = 25;\nvar height = movementStrength / \\$(window).height();\nvar width = movementStrength / \\$(window).width();\n\\$(\\\"body\\\").mousemove(function(e){\n          var pageX = e.pageX - (\\$(window).width() / 2);\n          var pageY = e.pageY - (\\$(window).height() / 2);\n          var newvalueX = width * pageX * -1 - 25;\n          var newvalueY = height * pageY * -1 - 50;\n          \\$('#top-image').css(\\\"background-position\\\", newvalueX+\\\"px     \\\"+newvalueY+\\\"px\\\");\n});\n\\$(\\\"#search\\\").keyup(function(){\n        \\$('.top-domain').each(function(i, obj) {\n                if(\\$(this).text().indexOf(\\$(\\\"#search\\\").val()) == -1){\n                        \\$(this).hide();\n                }else{\n                        \\$(this).show();\n                }\n        });\n});\n\n\n\\$(\\\".subdomain\\\").on('click',function(){\n        \\$(\\\".modal-body\\\").text(\\\"\\\");\n        \\$(\\\".modal-body\\\").append(\\\"Domain: <b>\\\"+\\$(this).children().text()+\\\"</b>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"Last Modified: <b>\\\"+\\$(this).attr(\\\"added\\\")+\\\"</b>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"Active: <b>\\\"+\\$(this).attr(\\\"active\\\").replace(\\\"1\\\", \\\"Yes\\\").replace(\\\"0\\\", \\\"No\\\")+\\\"</b>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"Inscope: <b>\\\"+\\$(this).attr(\\\"inscope\\\").replace(\\\"1\\\", \\\"Yes\\\").replace(\\\"0\\\", \\\"No\\\")+\\\"</b>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"Program: <b>\\\"+\\$(this).attr(\\\"program\\\")+\\\"</b>\\\");\n\n\n        \\$('#myModal').modal('show');\n});\n\n        var Accordion = function(el, multiple) {\n                this.el = el || {};\n                this.multiple = multiple || false;\n\n                // Variables privadas\n                var links = this.el.find('.link');\n                // Evento\n                links.on('click', {el: this.el, multiple: this.multiple}, this.dropdown)\n        }\n\n        Accordion.prototype.dropdown = function(e) {\n                var \\$el = e.data.el;\n                        \\$this = \\$(this),\n                        \\$next = \\$this.next();\n\n                \\$next.slideToggle();\n                \\$this.parent().toggleClass('open');\n\n                if (!e.data.multiple) {\n                        \\$el.find('.submenu').not(\\$next).slideUp().parent().removeClass('open');\n                };\n        }\n\n        var accordion = new Accordion(\\$('#accordion'), false);\n});\n</script>\n</div>\n</body>\n\n\" > /var/www/html/ICU.php\n", "source_code_before": "echo \"\n<html>\n<head>\n  <link rel=\\\"stylesheet\\\" href=\\\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css\\\">\n   <link rel=\\\"stylesheet\\\" href=\\\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\\\">\n  <script src=\\\"https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js\\\"></script>\n  <script src=\\\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js\\\"></script>\n</head>\n<body>\n<div id=\\\"top-image\\\" style=\\\"overflow-y: scroll;\\\">\n<?php\n\\$servername = \\\"$3\\\";\n\\$username = \\\"$1\\\";\n\\$password = \\\"$2\\\";\n\\$dbname = \\\"recon\\\";\n\n\\$conn = new mysqli(\\$servername, \\$username, \\$password, \\$dbname);\n\nif (\\$conn->connect_error) {\n    die(\\\"Connection failed: \\\" . \\$conn->connect_error);\n}\n\n\\$sql = \\\"SELECT * FROM domains ORDER BY Active\\\";\n\n\\$result = \\$conn->query(\\$sql);\n\nif (\\$result->num_rows > 0) {\n    while(\\$row = \\$result->fetch_assoc()) {\n        \\$rows[] = \\$row;\n   }\n} else {\n    echo \\\"0 results\\\";\n}\n\\$conn->close();\n\n\\$domains = array();\n\n        foreach (\\$rows as \\$r) {\n                if(empty(\\$r[\\\"TopDomainID\\\"])){\n                        \\$subdomains = array();\n                        foreach (\\$rows as \\$r2) {\n                                if(\\$r2[\\\"TopDomainID\\\"] == \\$r[\\\"DomainID\\\"]){\n                                        array_push(\\$subdomains, \\$r2);\n                                }\n                        }\n                        array_push(\\$domains, array(\\$r, \\$subdomains));\n                }\n\n        }\n?>\n\n<ul id=\\\"accordion\\\" class=\\\"accordion\\\">\n        <li>\n                <div class=\\\"link\\\" style=\\\"\\\">\n                        <i class=\\\"fa fa-search\\\" style=\\\"margin-top: 5px;\\\" ></i>\n                        <input type=\\\"text\\\" class=\\\"form-control\\\" id=\\\"search\\\">\n                </div>\n        </li>\n        <?php\n                foreach (\\$domains as &\\$domain) {\n                        if(\\$domain != ''){\n                        echo '\n                        <li><div class=\\\"link top-domain\\\"><i class=\\\"fa fa-globe\\\"></i>'.\\$domain[0][\\\"Domain\\\"].'<i class=\\\"fa fa-chevron-down\\\"></i></div>\n                                <ul class=\\\"submenu\\\">';\n                                        \\$domain[1] = array_reverse(\\$domain[1], true);\n                                        foreach (\\$domain[1] as \\$d) {\n                                                echo '<li class=\\\"subdomain\\\" added=\\\"'.\\$d[\\\"LastModified\\\"].'\\\" active=\\\"'.\\$d[\\\"Active\\\"].'\\\" inscope=\\\"'.\\$d[\\\"InScope\\\"].'\\\" program=\\\"'.\\$d[\\\"Program\\\"].'\\\"><a href=\\\"#\\\">'.\\$d[\\\"Domain\\\"].'</a></li>';\n                                        }\n                        echo '</ul></li>';\n                        }\n                }\n        ?>\n</ul>\n\n<style>\n.modal-backdrop {\ntop: -5000px !important;\nposition: static;\n}\n\n#top-image {\nbackground:url('http://goldwallpapers.com/uploads/posts/google-data-center-wallpaper/google_data_center_wallpaper_013.jpg') -25px -50px;\nposition:fixed ;\ntop:0;\nwidth:100%;\nz-index:0;\n  height:100%;\n  background-size: calc(100% + 50px);\n}\n\n* {\n        margin: 0;\n        padding: 0;\n        -webkit-box-sizing: border-box;\n        -moz-box-sizing: border-box;\n        box-sizing: border-box;\n}\n\nbody {\n        background: #2d2c41;\n        font-family: 'Open Sans', Arial, Helvetica, Sans-serif, Verdana, Tahoma;\n}\n\nul {\n        list-style-type: none;\n}\n\na {\n        color: #b63b4d;\n        text-decoration: none;\n}\n\n/** =======================\n * Contenedor Principal\n ===========================*/\nh1 {\n        color: #FFF;\n        font-size: 24px;\n        font-weight: 400;\n        text-align: center;\n        margin-top: 80px;\n }\n\nh1 a {\n        color: #c12c42;\n        font-size: 16px;\n }\n\n .accordion {\n        width: 100%;\n        max-width: 360px;\n        margin: 30px auto 20px;\n        background: #FFF;\n        -webkit-border-radius: 4px;\n        -moz-border-radius: 4px;\n        border-radius: 4px;\n }\n\n.accordion .link {\n        cursor: pointer;\n        display: block;\n        padding: 15px 15px 15px 42px;\n        color: #4D4D4D;\n        font-size: 14px;\n        font-weight: 700;\n        border-bottom: 1px solid #CCC;\n        position: relative;\n        -webkit-transition: all 0.4s ease;\n        -o-transition: all 0.4s ease;\n        transition: all 0.4s ease;\n}\n\n.accordion li:last-child .link {\n        border-bottom: 0;\n}\n\n.accordion li i {\n        position: absolute;\n        top: 16px;\n        left: 12px;\n        font-size: 18px;\n        color: #595959;\n        -webkit-transition: all 0.4s ease;\n        -o-transition: all 0.4s ease;\n        transition: all 0.4s ease;\n}\n\n.accordion li i.fa-chevron-down {\n        right: 12px;\n        left: auto;\n        font-size: 16px;\n}\n\n.accordion li.open .link {\n        color: #b63b4d;\n}\n\n.accordion li.open i {\n        color: #b63b4d;\n}\n.accordion li.open i.fa-chevron-down {\n        -webkit-transform: rotate(180deg);\n        -ms-transform: rotate(180deg);\n        -o-transform: rotate(180deg);\n        transform: rotate(180deg);\n}\n\n.accordion li.default .submenu {display: block;}\n/**\n * Submenu\n -----------------------------*/\n .submenu {\n        display: none;\n        background: #FE8103;\n        font-size: 14px;\n }\n\n .submenu li {\n        border-bottom: 1px solid white;\n }\n\n .submenu a {\n        display: block;\n        text-decoration: none;\n        color: #d9d9d9;\n        padding: 12px;\n        padding-left: 42px;\n        -webkit-transition: all 0.25s ease;\n        -o-transition: all 0.25s ease;\n        transition: all 0.25s ease;\n }\n\n .submenu a:hover {\n        background: #801B0C;\n        color: #FFF;\n }\n\n\n</style>\n\n\n<!-- Modal -->\n<div id=\\\"myModal\\\" class=\\\"modal fade\\\" role=\\\"dialog\\\">\n  <div class=\\\"modal-dialog\\\">\n\n    <!-- Modal content-->\n    <div class=\\\"modal-content\\\">\n      <div class=\\\"modal-header\\\">\n        <button type=\\\"button\\\" class=\\\"close\\\" data-dismiss=\\\"modal\\\">&times;</button>\n        <h4 class=\\\"modal-title\\\">Info</h4>\n      </div>\n      <div class=\\\"modal-body\\\">\n        <p>body text</p>\n      </div>\n      <div class=\\\"modal-footer\\\">\n        <button type=\\\"button\\\" class=\\\"btn btn-default\\\" data-dismiss=\\\"modal\\\">Close</button>\n      </div>\n    </div>\n\n  </div>\n</div>\n\n\n<script>\n\\$(function() {\n\nvar movementStrength = 25;\nvar height = movementStrength / \\$(window).height();\nvar width = movementStrength / \\$(window).width();\n\\$(\\\"body\\\").mousemove(function(e){\n          var pageX = e.pageX - (\\$(window).width() / 2);\n          var pageY = e.pageY - (\\$(window).height() / 2);\n          var newvalueX = width * pageX * -1 - 25;\n          var newvalueY = height * pageY * -1 - 50;\n          \\$('#top-image').css(\\\"background-position\\\", newvalueX+\\\"px     \\\"+newvalueY+\\\"px\\\");\n});\n\\$(\\\"#search\\\").keyup(function(){\n        \\$('.top-domain').each(function(i, obj) {\n                if(\\$(this).text().indexOf(\\$(\\\"#search\\\").val()) == -1){\n                        \\$(this).hide();\n                }else{\n                        \\$(this).show();\n                }\n        });\n});\n\n\n\\$(\\\".subdomain\\\").on('click',function(){\n        \\$(\\\".modal-body\\\").text(\\\"\\\");\n        \\$(\\\".modal-body\\\").append(\\\"Domain: <b>\\\"+\\$(this).children().text()+\\\"</b>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"Last Modified: <b>\\\"+\\$(this).attr(\\\"added\\\")+\\\"</b>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"Active: <b>\\\"+\\$(this).attr(\\\"active\\\").replace(\\\"1\\\", \\\"Yes\\\").replace(\\\"0\\\", \\\"No\\\")+\\\"</b>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"Inscope: <b>\\\"+\\$(this).attr(\\\"inscope\\\").replace(\\\"1\\\", \\\"Yes\\\").replace(\\\"0\\\", \\\"No\\\")+\\\"</b>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"</br>\\\");\n        \\$(\\\".modal-body\\\").append(\\\"Program: <b>\\\"+\\$(this).attr(\\\"program\\\")+\\\"</b>\\\");\n\n\n        \\$('#myModal').modal('show');\n});\n\n        var Accordion = function(el, multiple) {\n                this.el = el || {};\n                this.multiple = multiple || false;\n\n                // Variables privadas\n                var links = this.el.find('.link');\n                // Evento\n                links.on('click', {el: this.el, multiple: this.multiple}, this.dropdown)\n        }\n\n        Accordion.prototype.dropdown = function(e) {\n                var \\$el = e.data.el;\n                        \\$this = \\$(this),\n                        \\$next = \\$this.next();\n\n                \\$next.slideToggle();\n                \\$this.parent().toggleClass('open');\n\n                if (!e.data.multiple) {\n                        \\$el.find('.submenu').not(\\$next).slideUp().parent().removeClass('open');\n                };\n        }\n\n        var accordion = new Accordion(\\$('#accordion'), false);\n});\n</script>\n</div>\n</body>\n\n\" > /var/www/html/ICU.php\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "a03d98c8adb5206f93bc52cb41cce316d0a6baa3", "msg": "Subfinder and Amass are optional now", "author": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "committer": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "author_date": "2018-06-05 14:42:32+02:00", "author_timezone": -7200, "committer_date": "2018-06-05 14:42:32+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["9a4e3952aaccdf6fd93a3e22369d7fdc199d6ced"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 14, "insertions": 32, "lines": 46, "files": 1, "modified_files": [{"old_path": "database/additional_tools/domains_db.py", "new_path": "database/additional_tools/domains_db.py", "filename": "domains_db.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -19,13 +19,17 @@ try:\n \tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n \ttime.sleep(2)\n \n-\t#Subfinder\n-\tos.system(\"subfinder -d \" + domain + \" -v -o /tmp/ICU/\"+domain+\"/domains-subfinder.txt --timeout 6\")\n-\ttime.sleep(2)\n-\n-\t#Amass\n-\tos.system(\"amass -o /tmp/ICU/\"+domain+\"/domains-amass.txt -d \" + domain)\n-        time.sleep(2)\n+\ttry:\n+\t\t#Subfinder\n+\t\tos.system(\"subfinder -d \" + domain + \" -v -o /tmp/ICU/\"+domain+\"/domains-subfinder.txt --timeout 6\")\n+\t\ttime.sleep(2)\n+\n+\t\t#Amass\n+\t\tos.system(\"amass -o /tmp/ICU/\"+domain+\"/domains-amass.txt -d \" + domain)\n+        \ttime.sleep(2)\n+\texcept Exception as e:\n+\t\tprint \"An error occured; You probably dont have either subfinder or amass installed. Check the README.md to see you how to install them. Error: \"\n+\t\tprint str(e)\n \n \t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on\n \tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n@@ -39,18 +43,32 @@ try:\n \t#All the domains from the subdomain scanners\n \tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n \n-\t#Domains from subfinder\n-\tdomains_subfinder = open(\"/tmp/ICU/\"+domain+\"/domains-subfinder.txt\",'r').read().split('\\n')\n+\ttry:\n+\t\t#Domains from subfinder\n+\t\tdomains_subfinder = open(\"/tmp/ICU/\"+domain+\"/domains-subfinder.txt\",'r').read().split('\\n')\n+\n+\t        #Domains from amass\n+        \tdomains_amass = open(\"/tmp/ICU/\"+domain+\"/domains-amass.txt\",'r').read().split('\\n')\n \n-        #Domains from amass\n-        domains_subfinder = open(\"/tmp/ICU/\"+domain+\"/domains-amass.txt\",'r').read().split('\\n')\n+\t        #Add the subfinder domains\n+        \tdomains_all.extend(x for x in domains_subfinder if x not in domains_all)\n \n-        #Add all the subfinder subdomain to it\n-        domains_all.extend(x for x in domains_subfinder if x not in domains_all)\n+\t\t#unique\n+\t\tdomains_all = list(set(domains_all))\n+\n+\t        #Add the amass domains\n+        \tdomains_all.extend(x for x in domains_amass if x not in domains_all)\n+\n+        \t#unique\n+        \tdomains_all = list(set(domains_all))\n+        except Exception as e:\n+                print \"An error occured; You probably dont have either subfinder or amass installed. Check the README.md to see you how to install them. Error: \"\n+                print str(e)\n \n \t#Add all the database subdomain to it\n \tdomains_all.extend(x for x in database_domains if x not in domains_all)\n-\t#Make it unique\n+\n+\t#unique -- Unique each time after adding a new list, to limit ram usage\n \tdomains_all = list(set(domains_all))\n \n \t#Put all the online domains in a domains-online.txt\n", "diff_parsed": {"added": [[22, "\ttry:"], [23, "\t\t#Subfinder"], [24, "\t\tos.system(\"subfinder -d \" + domain + \" -v -o /tmp/ICU/\"+domain+\"/domains-subfinder.txt --timeout 6\")"], [25, "\t\ttime.sleep(2)"], [26, ""], [27, "\t\t#Amass"], [28, "\t\tos.system(\"amass -o /tmp/ICU/\"+domain+\"/domains-amass.txt -d \" + domain)"], [29, "        \ttime.sleep(2)"], [30, "\texcept Exception as e:"], [31, "\t\tprint \"An error occured; You probably dont have either subfinder or amass installed. Check the README.md to see you how to install them. Error: \""], [32, "\t\tprint str(e)"], [46, "\ttry:"], [47, "\t\t#Domains from subfinder"], [48, "\t\tdomains_subfinder = open(\"/tmp/ICU/\"+domain+\"/domains-subfinder.txt\",'r').read().split('\\n')"], [49, ""], [50, "\t        #Domains from amass"], [51, "        \tdomains_amass = open(\"/tmp/ICU/\"+domain+\"/domains-amass.txt\",'r').read().split('\\n')"], [53, "\t        #Add the subfinder domains"], [54, "        \tdomains_all.extend(x for x in domains_subfinder if x not in domains_all)"], [56, "\t\t#unique"], [57, "\t\tdomains_all = list(set(domains_all))"], [58, ""], [59, "\t        #Add the amass domains"], [60, "        \tdomains_all.extend(x for x in domains_amass if x not in domains_all)"], [61, ""], [62, "        \t#unique"], [63, "        \tdomains_all = list(set(domains_all))"], [64, "        except Exception as e:"], [65, "                print \"An error occured; You probably dont have either subfinder or amass installed. Check the README.md to see you how to install them. Error: \""], [66, "                print str(e)"], [70, ""], [71, "\t#unique -- Unique each time after adding a new list, to limit ram usage"]], "deleted": [[22, "\t#Subfinder"], [23, "\tos.system(\"subfinder -d \" + domain + \" -v -o /tmp/ICU/\"+domain+\"/domains-subfinder.txt --timeout 6\")"], [24, "\ttime.sleep(2)"], [25, ""], [26, "\t#Amass"], [27, "\tos.system(\"amass -o /tmp/ICU/\"+domain+\"/domains-amass.txt -d \" + domain)"], [28, "        time.sleep(2)"], [42, "\t#Domains from subfinder"], [43, "\tdomains_subfinder = open(\"/tmp/ICU/\"+domain+\"/domains-subfinder.txt\",'r').read().split('\\n')"], [45, "        #Domains from amass"], [46, "        domains_subfinder = open(\"/tmp/ICU/\"+domain+\"/domains-amass.txt\",'r').read().split('\\n')"], [48, "        #Add all the subfinder subdomain to it"], [49, "        domains_all.extend(x for x in domains_subfinder if x not in domains_all)"], [53, "\t#Make it unique"]]}, "added_lines": 32, "deleted_lines": 14, "source_code": "#!/usr/bin/python\nimport os, sys, MySQLdb, time\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../../\")\nimport credentials\n\ntry:\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tdomain = sys.argv[1].strip()\n\tcursor = connection.cursor()\n\tscanId = sys.argv[2]\n\n\tif not os.path.exists(\"/tmp/ICU\"):\n\t\tos.makedirs(\"/tmp/ICU\")\n\n\tif not os.path.exists(\"/tmp/ICU/\"+domain+\"/\"):\n\t    os.makedirs(\"/tmp/ICU/\"+domain+\"/\")\n\n\t#Add new subdomain scanners here. Make sure to let them save the output to /tmp/ICU/{domain}/doains-all.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n\ttime.sleep(2)\n\n\ttry:\n\t\t#Subfinder\n\t\tos.system(\"subfinder -d \" + domain + \" -v -o /tmp/ICU/\"+domain+\"/domains-subfinder.txt --timeout 6\")\n\t\ttime.sleep(2)\n\n\t\t#Amass\n\t\tos.system(\"amass -o /tmp/ICU/\"+domain+\"/domains-amass.txt -d \" + domain)\n        \ttime.sleep(2)\n\texcept Exception as e:\n\t\tprint \"An error occured; You probably dont have either subfinder or amass installed. Check the README.md to see you how to install them. Error: \"\n\t\tprint str(e)\n\n\t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on\n\tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n\tdatabase_data = cursor.fetchall()\n\tdatabase_domains = [d[0] for d in database_data]\n\n        non_active_subdomains = [x[0] for x in database_data if ord(x[2]) == False]\n        program = [x[3] for x in database_data if x[0] == domain][0]\n        topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n\n\t#All the domains from the subdomain scanners\n\tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n\n\ttry:\n\t\t#Domains from subfinder\n\t\tdomains_subfinder = open(\"/tmp/ICU/\"+domain+\"/domains-subfinder.txt\",'r').read().split('\\n')\n\n\t        #Domains from amass\n        \tdomains_amass = open(\"/tmp/ICU/\"+domain+\"/domains-amass.txt\",'r').read().split('\\n')\n\n\t        #Add the subfinder domains\n        \tdomains_all.extend(x for x in domains_subfinder if x not in domains_all)\n\n\t\t#unique\n\t\tdomains_all = list(set(domains_all))\n\n\t        #Add the amass domains\n        \tdomains_all.extend(x for x in domains_amass if x not in domains_all)\n\n        \t#unique\n        \tdomains_all = list(set(domains_all))\n        except Exception as e:\n                print \"An error occured; You probably dont have either subfinder or amass installed. Check the README.md to see you how to install them. Error: \"\n                print str(e)\n\n\t#Add all the database subdomain to it\n\tdomains_all.extend(x for x in database_domains if x not in domains_all)\n\n\t#unique -- Unique each time after adding a new list, to limit ram usage\n\tdomains_all = list(set(domains_all))\n\n\t#Put all the online domains in a domains-online.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")\n\n\t#Convert online domains to array\n\tdomains_online = open(\"/tmp/ICU/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n\n\t#Loop through every subdomain\n\tfor sub_domain in domains_all:\n\t\t#Get the scanID to insert. If the domains was already in the db and isnt changed, then keep the old scanID. otherwise use the scanID of the current scan\n\t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n\n\t\t#If the subdomain is online\n\t\tif sub_domain in domains_online:\n\t\t\tactive=True\n\t\t\t#If the subdomain used to be offline, give it the current scanID\n\t\t\tif sub_domain in non_active_subdomains:\n\t\t\t\tinsertScanId = scanId\n\t\telse:\n\t\t\tactive=False\n\n\n\t\tif sub_domain:\n\t\t\t#Insert the new values, or update them if they already existed\n\t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))\n\t\t\tconnection.commit()\n\n\tcursor.close ()\n\tconnection.close ()\nexcept Exception as e:\n\t#Handle the errors, and save them to the database\n\tprint \"error in domains_db.py with main domain; \" + domain\n\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in domains_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n\tconnection.commit()\n\tcursor.close()\n\tconnection.close()\n\tprint e\nsys.exit()\n", "source_code_before": "#!/usr/bin/python\nimport os, sys, MySQLdb, time\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../../\")\nimport credentials\n\ntry:\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tdomain = sys.argv[1].strip()\n\tcursor = connection.cursor()\n\tscanId = sys.argv[2]\n\n\tif not os.path.exists(\"/tmp/ICU\"):\n\t\tos.makedirs(\"/tmp/ICU\")\n\n\tif not os.path.exists(\"/tmp/ICU/\"+domain+\"/\"):\n\t    os.makedirs(\"/tmp/ICU/\"+domain+\"/\")\n\n\t#Add new subdomain scanners here. Make sure to let them save the output to /tmp/ICU/{domain}/doains-all.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n\ttime.sleep(2)\n\n\t#Subfinder\n\tos.system(\"subfinder -d \" + domain + \" -v -o /tmp/ICU/\"+domain+\"/domains-subfinder.txt --timeout 6\")\n\ttime.sleep(2)\n\n\t#Amass\n\tos.system(\"amass -o /tmp/ICU/\"+domain+\"/domains-amass.txt -d \" + domain)\n        time.sleep(2)\n\n\t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on\n\tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n\tdatabase_data = cursor.fetchall()\n\tdatabase_domains = [d[0] for d in database_data]\n\n        non_active_subdomains = [x[0] for x in database_data if ord(x[2]) == False]\n        program = [x[3] for x in database_data if x[0] == domain][0]\n        topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n\n\t#All the domains from the subdomain scanners\n\tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n\n\t#Domains from subfinder\n\tdomains_subfinder = open(\"/tmp/ICU/\"+domain+\"/domains-subfinder.txt\",'r').read().split('\\n')\n\n        #Domains from amass\n        domains_subfinder = open(\"/tmp/ICU/\"+domain+\"/domains-amass.txt\",'r').read().split('\\n')\n\n        #Add all the subfinder subdomain to it\n        domains_all.extend(x for x in domains_subfinder if x not in domains_all)\n\n\t#Add all the database subdomain to it\n\tdomains_all.extend(x for x in database_domains if x not in domains_all)\n\t#Make it unique\n\tdomains_all = list(set(domains_all))\n\n\t#Put all the online domains in a domains-online.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")\n\n\t#Convert online domains to array\n\tdomains_online = open(\"/tmp/ICU/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n\n\t#Loop through every subdomain\n\tfor sub_domain in domains_all:\n\t\t#Get the scanID to insert. If the domains was already in the db and isnt changed, then keep the old scanID. otherwise use the scanID of the current scan\n\t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n\n\t\t#If the subdomain is online\n\t\tif sub_domain in domains_online:\n\t\t\tactive=True\n\t\t\t#If the subdomain used to be offline, give it the current scanID\n\t\t\tif sub_domain in non_active_subdomains:\n\t\t\t\tinsertScanId = scanId\n\t\telse:\n\t\t\tactive=False\n\n\n\t\tif sub_domain:\n\t\t\t#Insert the new values, or update them if they already existed\n\t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))\n\t\t\tconnection.commit()\n\n\tcursor.close ()\n\tconnection.close ()\nexcept Exception as e:\n\t#Handle the errors, and save them to the database\n\tprint \"error in domains_db.py with main domain; \" + domain\n\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in domains_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n\tconnection.commit()\n\tcursor.close()\n\tconnection.close()\n\tprint e\nsys.exit()\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": 64, "complexity": 0, "token_count": 680}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "66dba903e685bf8a6b80db43de55318ff03d9c16", "msg": "Update README.md", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-05 12:43:12+00:00", "author_timezone": 0, "committer_date": "2018-06-05 12:43:12+00:00", "committer_timezone": 0, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["a03d98c8adb5206f93bc52cb41cce316d0a6baa3"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 0, "insertions": 15, "lines": 15, "files": 1, "modified_files": [{"old_path": "README.md", "new_path": "README.md", "filename": "README.md", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -3,6 +3,16 @@\n # Install \n ```bash ./install.sh ``` The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n \n+## Optional (recommended)\n+ICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \n+You need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \n+After you've installed GO; Execute the following commands to install Amass and Subfinder: \n+```\n+go get github.com/caffix/amass\n+go get github.com/Ice3man543/subfinder\n+```\n+\n+\n # Telegram \n ICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n  \n@@ -14,6 +24,11 @@ The install script offers an option to install the modules from requirements.txt\n # Extra\n To get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n  \n+# Credits \n+Credits to:  \n+[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n  \n *Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n \n+\n+\n", "diff_parsed": {"added": [[6, "## Optional (recommended)"], [7, "ICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\")."], [8, "You need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO."], [9, "After you've installed GO; Execute the following commands to install Amass and Subfinder:"], [10, "```"], [11, "go get github.com/caffix/amass"], [12, "go get github.com/Ice3man543/subfinder"], [13, "```"], [14, ""], [15, ""], [27, "# Credits"], [28, "Credits to:"], [29, "[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!"], [33, ""], [34, ""]], "deleted": []}, "added_lines": 15, "deleted_lines": 0, "source_code": "## \ud83d\udccc Description \n\n# Install \n```bash ./install.sh ``` The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "source_code_before": "## \ud83d\udccc Description \n\n# Install \n```bash ./install.sh ``` The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "e9f6f0f8db116449c4d7c4363a441052a81bf442", "msg": "Update README.md", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-05 12:43:41+00:00", "author_timezone": 0, "committer_date": "2018-06-05 12:43:41+00:00", "committer_timezone": 0, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["66dba903e685bf8a6b80db43de55318ff03d9c16"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 0, "insertions": 1, "lines": 1, "files": 1, "modified_files": [{"old_path": "README.md", "new_path": "README.md", "filename": "README.md", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -1,4 +1,5 @@\n ## \ud83d\udccc Description \n+{{ Description }} \n \n # Install \n ```bash ./install.sh ``` The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n", "diff_parsed": {"added": [[2, "{{ Description }}"]], "deleted": []}, "added_lines": 1, "deleted_lines": 0, "source_code": "## \ud83d\udccc Description \n{{ Description }} \n\n# Install \n```bash ./install.sh ``` The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "source_code_before": "## \ud83d\udccc Description \n\n# Install \n```bash ./install.sh ``` The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "e059f5713a2603ea21a82a795ff578c4a8f1ce98", "msg": "Update README.md", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-05 12:48:28+00:00", "author_timezone": 0, "committer_date": "2018-06-05 12:48:28+00:00", "committer_timezone": 0, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["e9f6f0f8db116449c4d7c4363a441052a81bf442"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 1, "insertions": 2, "lines": 3, "files": 1, "modified_files": [{"old_path": "README.md", "new_path": "README.md", "filename": "README.md", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -2,7 +2,8 @@\n {{ Description }} \n \n # Install \n-```bash ./install.sh ``` The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n+```bash ./install.sh ```  \n+The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n \n ## Optional (recommended)\n ICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \n", "diff_parsed": {"added": [[5, "```bash ./install.sh ```"], [6, "The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on."]], "deleted": [[5, "```bash ./install.sh ``` The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on."]]}, "added_lines": 2, "deleted_lines": 1, "source_code": "## \ud83d\udccc Description \n{{ Description }} \n\n# Install \n```bash ./install.sh ```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "source_code_before": "## \ud83d\udccc Description \n{{ Description }} \n\n# Install \n```bash ./install.sh ``` The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "c9d15b22e99130c0e96677f32070bde17a920229", "msg": "Update README.md", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-05 12:50:11+00:00", "author_timezone": 0, "committer_date": "2018-06-05 12:50:11+00:00", "committer_timezone": 0, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["e059f5713a2603ea21a82a795ff578c4a8f1ce98"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 1, "insertions": 5, "lines": 6, "files": 1, "modified_files": [{"old_path": "README.md", "new_path": "README.md", "filename": "README.md", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -2,7 +2,11 @@\n {{ Description }} \n \n # Install \n-```bash ./install.sh ```  \n+```\n+git clone https://github.com/003random/ICU  \n+cd ICU\n+./install.sh \n+```  \n The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n \n ## Optional (recommended)\n", "diff_parsed": {"added": [[5, "```"], [6, "git clone https://github.com/003random/ICU"], [7, "cd ICU"], [8, "./install.sh"], [9, "```"]], "deleted": [[5, "```bash ./install.sh ```"]]}, "added_lines": 5, "deleted_lines": 1, "source_code": "## \ud83d\udccc Description \n{{ Description }} \n\n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "source_code_before": "## \ud83d\udccc Description \n{{ Description }} \n\n# Install \n```bash ./install.sh ```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "790ca59d81abbdbf0b0283b747d8ac03fcaa684e", "msg": "Update run.py", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-05 12:52:01+00:00", "author_timezone": 0, "committer_date": "2018-06-05 12:52:01+00:00", "committer_timezone": 0, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["c9d15b22e99130c0e96677f32070bde17a920229"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 1, "insertions": 1, "lines": 2, "files": 1, "modified_files": [{"old_path": "run.py", "new_path": "run.py", "filename": "run.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -13,7 +13,7 @@ try:\n \tconnection.close()\n \n \tfor row in data:\n-\t\tprint \"Running sublister on \" + row[0]\n+\t\tprint \"Starting subdomain scans on \" + row[0]\n \t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/database/additional_tools/domains_db.py \" + row[0] + \" \" + str(scanId))\n \n \tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n", "diff_parsed": {"added": [[16, "\t\tprint \"Starting subdomain scans on \" + row[0]"]], "deleted": [[16, "\t\tprint \"Running sublister on \" + row[0]"]]}, "added_lines": 1, "deleted_lines": 1, "source_code": "#!/usr/bin/python\ntry:\n\timport sys, os, MySQLdb, datetime, credentials\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tcursor.execute (\"insert into scans (StartDate) values (CURRENT_TIMESTAMP)\")\n\tconnection.commit()\n\tscanId = cursor.lastrowid\n\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\n\tdata = cursor.fetchall ()\n\tconnection.close()\n\n\tfor row in data:\n\t\tprint \"Starting subdomain scans on \" + row[0]\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/database/additional_tools/domains_db.py \" + row[0] + \" \" + str(scanId))\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\tcursor.execute (\"update scans set EndDate = CURRENT_TIMESTAMP where ScanID = %s\", (scanId))\n\tconnection.commit()\n\tconnection.close()\n\n\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/telegram/notify.py \" + str(scanId))\nexcept Exception, e:\n\tprint \"error: \" + str(e)\n\n\tif not os.path.exists(os.path.dirname(os.path.abspath(__file__))  + \"/logs\"):\n                os.makedirs(os.path.dirname(os.path.abspath(__file__))  + \"/logs\")\n\n\twith open(os.path.dirname(os.path.abspath(__file__))  + '/logs/run_logs.txt', 'w+') as the_file:\n\t\tthe_file.write(str(e) + \"\\n\")\n", "source_code_before": "#!/usr/bin/python\ntry:\n\timport sys, os, MySQLdb, datetime, credentials\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tcursor.execute (\"insert into scans (StartDate) values (CURRENT_TIMESTAMP)\")\n\tconnection.commit()\n\tscanId = cursor.lastrowid\n\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\n\tdata = cursor.fetchall ()\n\tconnection.close()\n\n\tfor row in data:\n\t\tprint \"Running sublister on \" + row[0]\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/database/additional_tools/domains_db.py \" + row[0] + \" \" + str(scanId))\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\tcursor.execute (\"update scans set EndDate = CURRENT_TIMESTAMP where ScanID = %s\", (scanId))\n\tconnection.commit()\n\tconnection.close()\n\n\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/telegram/notify.py \" + str(scanId))\nexcept Exception, e:\n\tprint \"error: \" + str(e)\n\n\tif not os.path.exists(os.path.dirname(os.path.abspath(__file__))  + \"/logs\"):\n                os.makedirs(os.path.dirname(os.path.abspath(__file__))  + \"/logs\")\n\n\twith open(os.path.dirname(os.path.abspath(__file__))  + '/logs/run_logs.txt', 'w+') as the_file:\n\t\tthe_file.write(str(e) + \"\\n\")\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": 25, "complexity": 0, "token_count": 315}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "9fa850064178d103bb605e9171fa0f008751962e", "msg": "Update online.py", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-05 19:05:00+00:00", "author_timezone": 0, "committer_date": "2018-06-05 19:05:00+00:00", "committer_timezone": 0, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["790ca59d81abbdbf0b0283b747d8ac03fcaa684e"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 27, "insertions": 20, "lines": 47, "files": 1, "modified_files": [{"old_path": "tools/online.py", "new_path": "tools/online.py", "filename": "online.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -1,26 +1,6 @@\n #!/usr/bin/python\n \n-import httplib\n-import socket\n-import re\n-import sys\n-\n-def online(host):\n-    try:\n-        socket.gethostbyname(host)\n-    except socket.gaierror:\n-        return False\n-    else:\n-        return True\n-\n-def available(host, path=\"/\"):\n-    try:\n-        conn = httplib.HTTPConnection(host, timeout=5)\n-        conn.request(\"HEAD\", path)\n-        if re.match(\"^[23]\\d\\d$\", str(conn.getresponse().status)):\n-            return True\n-    except StandardError:\n-        return False\n+import sys, requests\n \n input_file = sys.argv[1]\n output_file = sys.argv[2]\n@@ -32,13 +12,26 @@ domains = input_file_open.readlines()\n \n print(\"\\n-- Writing online hosts in \"+input_file+\" to \"+output_file+\" --\\n\")\n \n+\n+def available(domain):\n+        try:\n+                r = requests.get(domain, timeout=3)\n+                return True\n+        except:\n+                return False\n+\n for domain in domains:\n-    domain = domain.strip()\n-    if online(domain) == True and available(domain) == True:\n-        print(\"[+]\"+domain.strip())\n-        output_file_open.write(domain+\"\\n\")\n-    else:\n-        print(\"[-]\"+domain)\n+        domain = domain.strip()\n+\n+        http = available(\"http://\" + domain)\n+        https = available(\"https://\" + domain)\n+\n+        if http == True or https == True:\n+                print(\"[+]\" + domain.strip())\n+                output_file_open.write(domain+\"\\n\")\n+        else:\n+                print(\"[-]\" + domain.strip())\n+\n \n input_file_open.close()\n output_file_open.close()\n", "diff_parsed": {"added": [[3, "import sys, requests"], [15, ""], [16, "def available(domain):"], [17, "        try:"], [18, "                r = requests.get(domain, timeout=3)"], [19, "                return True"], [20, "        except:"], [21, "                return False"], [22, ""], [24, "        domain = domain.strip()"], [25, ""], [26, "        http = available(\"http://\" + domain)"], [27, "        https = available(\"https://\" + domain)"], [28, ""], [29, "        if http == True or https == True:"], [30, "                print(\"[+]\" + domain.strip())"], [31, "                output_file_open.write(domain+\"\\n\")"], [32, "        else:"], [33, "                print(\"[-]\" + domain.strip())"], [34, ""]], "deleted": [[3, "import httplib"], [4, "import socket"], [5, "import re"], [6, "import sys"], [7, ""], [8, "def online(host):"], [9, "    try:"], [10, "        socket.gethostbyname(host)"], [11, "    except socket.gaierror:"], [12, "        return False"], [13, "    else:"], [14, "        return True"], [15, ""], [16, "def available(host, path=\"/\"):"], [17, "    try:"], [18, "        conn = httplib.HTTPConnection(host, timeout=5)"], [19, "        conn.request(\"HEAD\", path)"], [20, "        if re.match(\"^[23]\\d\\d$\", str(conn.getresponse().status)):"], [21, "            return True"], [22, "    except StandardError:"], [23, "        return False"], [36, "    domain = domain.strip()"], [37, "    if online(domain) == True and available(domain) == True:"], [38, "        print(\"[+]\"+domain.strip())"], [39, "        output_file_open.write(domain+\"\\n\")"], [40, "    else:"], [41, "        print(\"[-]\"+domain)"]]}, "added_lines": 20, "deleted_lines": 27, "source_code": "#!/usr/bin/python\n\nimport sys, requests\n\ninput_file = sys.argv[1]\noutput_file = sys.argv[2]\n\ninput_file_open = open(input_file, 'r')\noutput_file_open = open(output_file, 'w+')\n\ndomains = input_file_open.readlines()\n\nprint(\"\\n-- Writing online hosts in \"+input_file+\" to \"+output_file+\" --\\n\")\n\n\ndef available(domain):\n        try:\n                r = requests.get(domain, timeout=3)\n                return True\n        except:\n                return False\n\nfor domain in domains:\n        domain = domain.strip()\n\n        http = available(\"http://\" + domain)\n        https = available(\"https://\" + domain)\n\n        if http == True or https == True:\n                print(\"[+]\" + domain.strip())\n                output_file_open.write(domain+\"\\n\")\n        else:\n                print(\"[-]\" + domain.strip())\n\n\ninput_file_open.close()\noutput_file_open.close()\nprint(\"\\n-- Done --\")\n", "source_code_before": "#!/usr/bin/python\n\nimport httplib\nimport socket\nimport re\nimport sys\n\ndef online(host):\n    try:\n        socket.gethostbyname(host)\n    except socket.gaierror:\n        return False\n    else:\n        return True\n\ndef available(host, path=\"/\"):\n    try:\n        conn = httplib.HTTPConnection(host, timeout=5)\n        conn.request(\"HEAD\", path)\n        if re.match(\"^[23]\\d\\d$\", str(conn.getresponse().status)):\n            return True\n    except StandardError:\n        return False\n\ninput_file = sys.argv[1]\noutput_file = sys.argv[2]\n\ninput_file_open = open(input_file, 'r')\noutput_file_open = open(output_file, 'w+')\n\ndomains = input_file_open.readlines()\n\nprint(\"\\n-- Writing online hosts in \"+input_file+\" to \"+output_file+\" --\\n\")\n\nfor domain in domains:\n    domain = domain.strip()\n    if online(domain) == True and available(domain) == True:\n        print(\"[+]\"+domain.strip())\n        output_file_open.write(domain+\"\\n\")\n    else:\n        print(\"[-]\"+domain)\n\ninput_file_open.close()\noutput_file_open.close()\nprint(\"\\n-- Done --\")\n", "methods": [{"name": "available", "start_line": 16, "end_line": 21}], "methods_before": [{"name": "online", "start_line": 8, "end_line": 14}, {"name": "available", "start_line": 16, "end_line": 23}], "changed_methods": [{"name": "online", "start_line": 8, "end_line": 14}, {"name": "available", "start_line": 16, "end_line": 21}, {"name": "available", "start_line": 16, "end_line": 23}], "nloc": 25, "complexity": 2, "token_count": 162}], "dmm_unit_size": 0.0, "dmm_unit_complexity": 0.0, "dmm_unit_interfacing": 0.0},
    {"hash": "7edffd3b1c77a80bd46c38297f270bf91771a0d0", "msg": "Update domains_db.py", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-06 11:20:34+02:00", "author_timezone": -7200, "committer_date": "2018-06-06 11:20:34+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["9fa850064178d103bb605e9171fa0f008751962e"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 2, "insertions": 4, "lines": 6, "files": 1, "modified_files": [{"old_path": "database/additional_tools/domains_db.py", "new_path": "database/additional_tools/domains_db.py", "filename": "domains_db.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -4,9 +4,7 @@ sys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../../\")\n import credentials\n \n try:\n-\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n \tdomain = sys.argv[1].strip()\n-\tcursor = connection.cursor()\n \tscanId = sys.argv[2]\n \n \tif not os.path.exists(\"/tmp/ICU\"):\n@@ -31,6 +29,10 @@ try:\n \t\tprint \"An error occured; You probably dont have either subfinder or amass installed. Check the README.md to see you how to install them. Error: \"\n \t\tprint str(e)\n \n+\n+\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n+\tcursor = connection.cursor()\n+\n \t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on\n \tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n \tdatabase_data = cursor.fetchall()\n", "diff_parsed": {"added": [[32, ""], [33, "\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)"], [34, "\tcursor = connection.cursor()"], [35, ""]], "deleted": [[7, "\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)"], [9, "\tcursor = connection.cursor()"]]}, "added_lines": 4, "deleted_lines": 2, "source_code": "#!/usr/bin/python\nimport os, sys, MySQLdb, time\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../../\")\nimport credentials\n\ntry:\n\tdomain = sys.argv[1].strip()\n\tscanId = sys.argv[2]\n\n\tif not os.path.exists(\"/tmp/ICU\"):\n\t\tos.makedirs(\"/tmp/ICU\")\n\n\tif not os.path.exists(\"/tmp/ICU/\"+domain+\"/\"):\n\t    os.makedirs(\"/tmp/ICU/\"+domain+\"/\")\n\n\t#Add new subdomain scanners here. Make sure to let them save the output to /tmp/ICU/{domain}/doains-all.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n\ttime.sleep(2)\n\n\ttry:\n\t\t#Subfinder\n\t\tos.system(\"subfinder -d \" + domain + \" -v -o /tmp/ICU/\"+domain+\"/domains-subfinder.txt --timeout 6\")\n\t\ttime.sleep(2)\n\n\t\t#Amass\n\t\tos.system(\"amass -o /tmp/ICU/\"+domain+\"/domains-amass.txt -d \" + domain)\n        \ttime.sleep(2)\n\texcept Exception as e:\n\t\tprint \"An error occured; You probably dont have either subfinder or amass installed. Check the README.md to see you how to install them. Error: \"\n\t\tprint str(e)\n\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor()\n\n\t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on\n\tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n\tdatabase_data = cursor.fetchall()\n\tdatabase_domains = [d[0] for d in database_data]\n\n        non_active_subdomains = [x[0] for x in database_data if ord(x[2]) == False]\n        program = [x[3] for x in database_data if x[0] == domain][0]\n        topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n\n\t#All the domains from the subdomain scanners\n\tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n\n\ttry:\n\t\t#Domains from subfinder\n\t\tdomains_subfinder = open(\"/tmp/ICU/\"+domain+\"/domains-subfinder.txt\",'r').read().split('\\n')\n\n\t        #Domains from amass\n        \tdomains_amass = open(\"/tmp/ICU/\"+domain+\"/domains-amass.txt\",'r').read().split('\\n')\n\n\t        #Add the subfinder domains\n        \tdomains_all.extend(x for x in domains_subfinder if x not in domains_all)\n\n\t\t#unique\n\t\tdomains_all = list(set(domains_all))\n\n\t        #Add the amass domains\n        \tdomains_all.extend(x for x in domains_amass if x not in domains_all)\n\n        \t#unique\n        \tdomains_all = list(set(domains_all))\n        except Exception as e:\n                print \"An error occured; You probably dont have either subfinder or amass installed. Check the README.md to see you how to install them. Error: \"\n                print str(e)\n\n\t#Add all the database subdomain to it\n\tdomains_all.extend(x for x in database_domains if x not in domains_all)\n\n\t#unique -- Unique each time after adding a new list, to limit ram usage\n\tdomains_all = list(set(domains_all))\n\n\t#Put all the online domains in a domains-online.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")\n\n\t#Convert online domains to array\n\tdomains_online = open(\"/tmp/ICU/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n\n\t#Loop through every subdomain\n\tfor sub_domain in domains_all:\n\t\t#Get the scanID to insert. If the domains was already in the db and isnt changed, then keep the old scanID. otherwise use the scanID of the current scan\n\t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n\n\t\t#If the subdomain is online\n\t\tif sub_domain in domains_online:\n\t\t\tactive=True\n\t\t\t#If the subdomain used to be offline, give it the current scanID\n\t\t\tif sub_domain in non_active_subdomains:\n\t\t\t\tinsertScanId = scanId\n\t\telse:\n\t\t\tactive=False\n\n\n\t\tif sub_domain:\n\t\t\t#Insert the new values, or update them if they already existed\n\t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))\n\t\t\tconnection.commit()\n\n\tcursor.close ()\n\tconnection.close ()\nexcept Exception as e:\n\t#Handle the errors, and save them to the database\n\tprint \"error in domains_db.py with main domain; \" + domain\n\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in domains_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n\tconnection.commit()\n\tcursor.close()\n\tconnection.close()\n\tprint e\nsys.exit()\n", "source_code_before": "#!/usr/bin/python\nimport os, sys, MySQLdb, time\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../../\")\nimport credentials\n\ntry:\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tdomain = sys.argv[1].strip()\n\tcursor = connection.cursor()\n\tscanId = sys.argv[2]\n\n\tif not os.path.exists(\"/tmp/ICU\"):\n\t\tos.makedirs(\"/tmp/ICU\")\n\n\tif not os.path.exists(\"/tmp/ICU/\"+domain+\"/\"):\n\t    os.makedirs(\"/tmp/ICU/\"+domain+\"/\")\n\n\t#Add new subdomain scanners here. Make sure to let them save the output to /tmp/ICU/{domain}/doains-all.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n\ttime.sleep(2)\n\n\ttry:\n\t\t#Subfinder\n\t\tos.system(\"subfinder -d \" + domain + \" -v -o /tmp/ICU/\"+domain+\"/domains-subfinder.txt --timeout 6\")\n\t\ttime.sleep(2)\n\n\t\t#Amass\n\t\tos.system(\"amass -o /tmp/ICU/\"+domain+\"/domains-amass.txt -d \" + domain)\n        \ttime.sleep(2)\n\texcept Exception as e:\n\t\tprint \"An error occured; You probably dont have either subfinder or amass installed. Check the README.md to see you how to install them. Error: \"\n\t\tprint str(e)\n\n\t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on\n\tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n\tdatabase_data = cursor.fetchall()\n\tdatabase_domains = [d[0] for d in database_data]\n\n        non_active_subdomains = [x[0] for x in database_data if ord(x[2]) == False]\n        program = [x[3] for x in database_data if x[0] == domain][0]\n        topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n\n\t#All the domains from the subdomain scanners\n\tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n\n\ttry:\n\t\t#Domains from subfinder\n\t\tdomains_subfinder = open(\"/tmp/ICU/\"+domain+\"/domains-subfinder.txt\",'r').read().split('\\n')\n\n\t        #Domains from amass\n        \tdomains_amass = open(\"/tmp/ICU/\"+domain+\"/domains-amass.txt\",'r').read().split('\\n')\n\n\t        #Add the subfinder domains\n        \tdomains_all.extend(x for x in domains_subfinder if x not in domains_all)\n\n\t\t#unique\n\t\tdomains_all = list(set(domains_all))\n\n\t        #Add the amass domains\n        \tdomains_all.extend(x for x in domains_amass if x not in domains_all)\n\n        \t#unique\n        \tdomains_all = list(set(domains_all))\n        except Exception as e:\n                print \"An error occured; You probably dont have either subfinder or amass installed. Check the README.md to see you how to install them. Error: \"\n                print str(e)\n\n\t#Add all the database subdomain to it\n\tdomains_all.extend(x for x in database_domains if x not in domains_all)\n\n\t#unique -- Unique each time after adding a new list, to limit ram usage\n\tdomains_all = list(set(domains_all))\n\n\t#Put all the online domains in a domains-online.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")\n\n\t#Convert online domains to array\n\tdomains_online = open(\"/tmp/ICU/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n\n\t#Loop through every subdomain\n\tfor sub_domain in domains_all:\n\t\t#Get the scanID to insert. If the domains was already in the db and isnt changed, then keep the old scanID. otherwise use the scanID of the current scan\n\t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n\n\t\t#If the subdomain is online\n\t\tif sub_domain in domains_online:\n\t\t\tactive=True\n\t\t\t#If the subdomain used to be offline, give it the current scanID\n\t\t\tif sub_domain in non_active_subdomains:\n\t\t\t\tinsertScanId = scanId\n\t\telse:\n\t\t\tactive=False\n\n\n\t\tif sub_domain:\n\t\t\t#Insert the new values, or update them if they already existed\n\t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))\n\t\t\tconnection.commit()\n\n\tcursor.close ()\n\tconnection.close ()\nexcept Exception as e:\n\t#Handle the errors, and save them to the database\n\tprint \"error in domains_db.py with main domain; \" + domain\n\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in domains_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n\tconnection.commit()\n\tcursor.close()\n\tconnection.close()\n\tprint e\nsys.exit()\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": 64, "complexity": 0, "token_count": 680}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "10726fce81a31678118338d8d296f5dc417d1410", "msg": "Update install.sh", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-13 20:13:11+00:00", "author_timezone": 0, "committer_date": "2018-06-13 20:13:11+00:00", "committer_timezone": 0, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["7edffd3b1c77a80bd46c38297f270bf91771a0d0"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 0, "insertions": 1, "lines": 1, "files": 1, "modified_files": [{"old_path": "install.sh", "new_path": "install.sh", "filename": "install.sh", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -11,6 +11,7 @@ read choice_pip_requirements\n \n if [ \"$choice_pip_requirements\" == \"Y\" ] || [ \"$choice_pip_requirements\" == \"y\" ] || [ -z \"$choice_pip_requirements\" ]; then\n         pip install -r requirements.txt\n+\tsudo apt-get install python-mysqldb\n else\n \techo\"[!] Make sure you have the right modules installed. You can check which modules are used in requirements.txt\"\n fi\n", "diff_parsed": {"added": [[14, "\tsudo apt-get install python-mysqldb"]], "deleted": []}, "added_lines": 1, "deleted_lines": 0, "source_code": "#!/usr/bin/env bash\n\necho \"[+] Installing sublist3r\"\ngit clone https://github.com/aboul3la/Sublist3r.git tools/dependencies/sublister\n\necho \"----------------------------------------------------------------\"\n\necho \"[?] Do you want to pip install the requirements.txt?\"\necho \"[Y/n]\"\nread choice_pip_requirements\n\nif [ \"$choice_pip_requirements\" == \"Y\" ] || [ \"$choice_pip_requirements\" == \"y\" ] || [ -z \"$choice_pip_requirements\" ]; then\n        pip install -r requirements.txt\n\tsudo apt-get install python-mysqldb\nelse\n\techo\"[!] Make sure you have the right modules installed. You can check which modules are used in requirements.txt\"\nfi\n\necho \"----------------------------------------------------------------\"\n\necho \"[?] What is the database username?\"\nread database_username\n\necho \"[?] What is the database password?\"\nread database_password\n\necho \"[?] What is the database server? e.g. localhost (most common), if it runs on the same server.\"\nread database_server\n\necho \"\ndatabase_username = \\\"$database_username\\\"\ndatabase_password = \\\"$database_password\\\"\ndatabase_server = \\\"$database_server\\\"\ndatabase_name = \\\"recon\\\"\n\ntelegram_bot_token = \\\"\\\"\ntelegram_chat_id = \\\"\\\"\n\" > \"credentials.py\"\n\necho \"[+] Creating database 'recon' with tables 'domains', scans and 'errors'\"\npython database/init_db.py\n\necho \"[+] Checking if the database was created successfully\"\npython database/db_test.py\n\necho \"----------------------------------------------------------------\"\n\necho \"[+] Adding a cron task to run 'run.py' every 12 hours. You can edit this with the command 'crontab -e'\"\necho \"[?] Adding the path to crontab. If this isn't the right path to the file, please edit this with the command 'crontab -e'\"\n#write out current crontab\ncrontab -l > mycron\n#echo new cron into cron file\necho \"0 */12 * * * python $(pwd)/run.py\" >> mycron\n#install new cron file\ncrontab mycron\nrm mycron\necho \"[+] Crontab task created!\"\n\necho \"----------------------------------------------------------------\"\n\necho \"[?] Do you want to create ICU.php? A simple web interface for the domains.\"\necho \"[Y/n]\"\nread choice_web\n\nif [ \"$choice_web\" == \"Y\" ] || [ \"$choice_web\" == \"y\" ] || [ -z \"$choice_web\" ]; then\n        ./web/setup.sh \"$database_username\" \"$database_password\" \"$database_server\"\n\techo \"[+] ICU.php was added.\"\nfi\n\necho \"----------------------------------------------------------------\"\n\necho \"[!] All set!\"\n\necho \"----------------------------------------------------------------\"\n\necho \"[+] If you want to use the telegram options, please add your telegram bot token in credentials.py.\"\necho \"[?] Do you want to run main.py? This script lets you manage your domains.\"\necho \"[Y/n]\"\nread choice_main\n\nif [ $choice_main = \"Y\" ] || [ $choice_main = \"y\" ] || [ -z $choice_main ]; then\n\tpython main.py\nfi\n", "source_code_before": "#!/usr/bin/env bash\n\necho \"[+] Installing sublist3r\"\ngit clone https://github.com/aboul3la/Sublist3r.git tools/dependencies/sublister\n\necho \"----------------------------------------------------------------\"\n\necho \"[?] Do you want to pip install the requirements.txt?\"\necho \"[Y/n]\"\nread choice_pip_requirements\n\nif [ \"$choice_pip_requirements\" == \"Y\" ] || [ \"$choice_pip_requirements\" == \"y\" ] || [ -z \"$choice_pip_requirements\" ]; then\n        pip install -r requirements.txt\nelse\n\techo\"[!] Make sure you have the right modules installed. You can check which modules are used in requirements.txt\"\nfi\n\necho \"----------------------------------------------------------------\"\n\necho \"[?] What is the database username?\"\nread database_username\n\necho \"[?] What is the database password?\"\nread database_password\n\necho \"[?] What is the database server? e.g. localhost (most common), if it runs on the same server.\"\nread database_server\n\necho \"\ndatabase_username = \\\"$database_username\\\"\ndatabase_password = \\\"$database_password\\\"\ndatabase_server = \\\"$database_server\\\"\ndatabase_name = \\\"recon\\\"\n\ntelegram_bot_token = \\\"\\\"\ntelegram_chat_id = \\\"\\\"\n\" > \"credentials.py\"\n\necho \"[+] Creating database 'recon' with tables 'domains', scans and 'errors'\"\npython database/init_db.py\n\necho \"[+] Checking if the database was created successfully\"\npython database/db_test.py\n\necho \"----------------------------------------------------------------\"\n\necho \"[+] Adding a cron task to run 'run.py' every 12 hours. You can edit this with the command 'crontab -e'\"\necho \"[?] Adding the path to crontab. If this isn't the right path to the file, please edit this with the command 'crontab -e'\"\n#write out current crontab\ncrontab -l > mycron\n#echo new cron into cron file\necho \"0 */12 * * * python $(pwd)/run.py\" >> mycron\n#install new cron file\ncrontab mycron\nrm mycron\necho \"[+] Crontab task created!\"\n\necho \"----------------------------------------------------------------\"\n\necho \"[?] Do you want to create ICU.php? A simple web interface for the domains.\"\necho \"[Y/n]\"\nread choice_web\n\nif [ \"$choice_web\" == \"Y\" ] || [ \"$choice_web\" == \"y\" ] || [ -z \"$choice_web\" ]; then\n        ./web/setup.sh \"$database_username\" \"$database_password\" \"$database_server\"\n\techo \"[+] ICU.php was added.\"\nfi\n\necho \"----------------------------------------------------------------\"\n\necho \"[!] All set!\"\n\necho \"----------------------------------------------------------------\"\n\necho \"[+] If you want to use the telegram options, please add your telegram bot token in credentials.py.\"\necho \"[?] Do you want to run main.py? This script lets you manage your domains.\"\necho \"[Y/n]\"\nread choice_main\n\nif [ $choice_main = \"Y\" ] || [ $choice_main = \"y\" ] || [ -z $choice_main ]; then\n\tpython main.py\nfi\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "824c5922049e8c1042b5948f156d59c7f509675f", "msg": "Update README.md", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-13 20:18:38+00:00", "author_timezone": 0, "committer_date": "2018-06-13 20:18:38+00:00", "committer_timezone": 0, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["10726fce81a31678118338d8d296f5dc417d1410"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 2, "insertions": 4, "lines": 6, "files": 1, "modified_files": [{"old_path": "README.md", "new_path": "README.md", "filename": "README.md", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -1,6 +1,8 @@\n ## \ud83d\udccc Description \n-{{ Description }} \n-\n+ICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n+  \n+ICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n+  \n # Install \n ```\n git clone https://github.com/003random/ICU  \n", "diff_parsed": {"added": [[2, "ICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners."], [3, ""], [4, "ICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains."], [5, ""]], "deleted": [[2, "{{ Description }}"], [3, ""]]}, "added_lines": 4, "deleted_lines": 2, "source_code": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n  \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "source_code_before": "## \ud83d\udccc Description \n{{ Description }} \n\n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "6178efa2cffcf6638d4955c297a61db4ee074a6f", "msg": "Updated main.py", "author": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "committer": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "author_date": "2018-06-13 23:33:18+02:00", "author_timezone": -7200, "committer_date": "2018-06-13 23:33:18+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["824c5922049e8c1042b5948f156d59c7f509675f"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 3, "insertions": 29, "lines": 32, "files": 3, "modified_files": [{"old_path": "credentials.pyc", "new_path": "credentials.pyc", "filename": "credentials.pyc", "change_type": "ModificationType.ADD", "change_type_name": "ADD", "diff": "Binary files /dev/null and b/credentials.pyc differ\n", "diff_parsed": {"added": [], "deleted": []}, "added_lines": 0, "deleted_lines": 0, "source_code": "\u0003\r\n![c\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000@\u0000\u0000\u0000s(\u0000\u0000\u0000d\u0000\u0000Z\u0000\u0000d\u0001\u0000Z\u0001\u0000d\u0002\u0000Z\u0002\u0000d\u0003\u0000Z\u0003\u0000d\u0004\u0000Z\u0004\u0000d\u0004\u0000Z\u0005\u0000d\u0005\u0000S(\u0006\u0000\u0000\u0000t\u0003\u0000\u0000\u0000rjpt\u0004\u0000\u0000\u00001484t\t\u0000\u0000\u0000localhostt\u0005\u0000\u0000\u0000recont\u0000\u0000\u0000\u0000N(\u0006\u0000\u0000\u0000t\u0011\u0000\u0000\u0000database_usernamet\u0011\u0000\u0000\u0000database_passwordt\u000f\u0000\u0000\u0000database_servert\r\u0000\u0000\u0000database_namet\u0012\u0000\u0000\u0000telegram_bot_tokent\u0010\u0000\u0000\u0000telegram_chat_id(\u0000\u0000\u0000\u0000(\u0000\u0000\u0000\u0000(\u0000\u0000\u0000\u0000s)\u0000\u0000\u0000/home/rjp/ICU_/database/../credentials.pyt\b\u0000\u0000\u0000<module>\u0002\u0000\u0000\u0000s\n\u0000\u0000\u0000\u0006\u0001\u0006\u0001\u0006\u0001\u0006\u0002\u0006\u0001", "source_code_before": null, "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}, {"old_path": "install.sh", "new_path": "install.sh", "filename": "install.sh", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -13,7 +13,7 @@ if [ \"$choice_pip_requirements\" == \"Y\" ] || [ \"$choice_pip_requirements\" == \"y\"\n         pip install -r requirements.txt\n \tsudo apt-get install python-mysqldb\n else\n-\techo\"[!] Make sure you have the right modules installed. You can check which modules are used in requirements.txt\"\n+\techo \"[!] Make sure you have the right modules installed. You can check which modules are used in requirements.txt\"\n fi\n \n echo \"----------------------------------------------------------------\"\n", "diff_parsed": {"added": [[16, "\techo \"[!] Make sure you have the right modules installed. You can check which modules are used in requirements.txt\""]], "deleted": [[16, "\techo\"[!] Make sure you have the right modules installed. You can check which modules are used in requirements.txt\""]]}, "added_lines": 1, "deleted_lines": 1, "source_code": "#!/usr/bin/env bash\n\necho \"[+] Installing sublist3r\"\ngit clone https://github.com/aboul3la/Sublist3r.git tools/dependencies/sublister\n\necho \"----------------------------------------------------------------\"\n\necho \"[?] Do you want to pip install the requirements.txt?\"\necho \"[Y/n]\"\nread choice_pip_requirements\n\nif [ \"$choice_pip_requirements\" == \"Y\" ] || [ \"$choice_pip_requirements\" == \"y\" ] || [ -z \"$choice_pip_requirements\" ]; then\n        pip install -r requirements.txt\n\tsudo apt-get install python-mysqldb\nelse\n\techo \"[!] Make sure you have the right modules installed. You can check which modules are used in requirements.txt\"\nfi\n\necho \"----------------------------------------------------------------\"\n\necho \"[?] What is the database username?\"\nread database_username\n\necho \"[?] What is the database password?\"\nread database_password\n\necho \"[?] What is the database server? e.g. localhost (most common), if it runs on the same server.\"\nread database_server\n\necho \"\ndatabase_username = \\\"$database_username\\\"\ndatabase_password = \\\"$database_password\\\"\ndatabase_server = \\\"$database_server\\\"\ndatabase_name = \\\"recon\\\"\n\ntelegram_bot_token = \\\"\\\"\ntelegram_chat_id = \\\"\\\"\n\" > \"credentials.py\"\n\necho \"[+] Creating database 'recon' with tables 'domains', scans and 'errors'\"\npython database/init_db.py\n\necho \"[+] Checking if the database was created successfully\"\npython database/db_test.py\n\necho \"----------------------------------------------------------------\"\n\necho \"[+] Adding a cron task to run 'run.py' every 12 hours. You can edit this with the command 'crontab -e'\"\necho \"[?] Adding the path to crontab. If this isn't the right path to the file, please edit this with the command 'crontab -e'\"\n#write out current crontab\ncrontab -l > mycron\n#echo new cron into cron file\necho \"0 */12 * * * python $(pwd)/run.py\" >> mycron\n#install new cron file\ncrontab mycron\nrm mycron\necho \"[+] Crontab task created!\"\n\necho \"----------------------------------------------------------------\"\n\necho \"[?] Do you want to create ICU.php? A simple web interface for the domains.\"\necho \"[Y/n]\"\nread choice_web\n\nif [ \"$choice_web\" == \"Y\" ] || [ \"$choice_web\" == \"y\" ] || [ -z \"$choice_web\" ]; then\n        ./web/setup.sh \"$database_username\" \"$database_password\" \"$database_server\"\n\techo \"[+] ICU.php was added.\"\nfi\n\necho \"----------------------------------------------------------------\"\n\necho \"[!] All set!\"\n\necho \"----------------------------------------------------------------\"\n\necho \"[+] If you want to use the telegram options, please add your telegram bot token in credentials.py.\"\necho \"[?] Do you want to run main.py? This script lets you manage your domains.\"\necho \"[Y/n]\"\nread choice_main\n\nif [ $choice_main = \"Y\" ] || [ $choice_main = \"y\" ] || [ -z $choice_main ]; then\n\tpython main.py\nfi\n", "source_code_before": "#!/usr/bin/env bash\n\necho \"[+] Installing sublist3r\"\ngit clone https://github.com/aboul3la/Sublist3r.git tools/dependencies/sublister\n\necho \"----------------------------------------------------------------\"\n\necho \"[?] Do you want to pip install the requirements.txt?\"\necho \"[Y/n]\"\nread choice_pip_requirements\n\nif [ \"$choice_pip_requirements\" == \"Y\" ] || [ \"$choice_pip_requirements\" == \"y\" ] || [ -z \"$choice_pip_requirements\" ]; then\n        pip install -r requirements.txt\n\tsudo apt-get install python-mysqldb\nelse\n\techo\"[!] Make sure you have the right modules installed. You can check which modules are used in requirements.txt\"\nfi\n\necho \"----------------------------------------------------------------\"\n\necho \"[?] What is the database username?\"\nread database_username\n\necho \"[?] What is the database password?\"\nread database_password\n\necho \"[?] What is the database server? e.g. localhost (most common), if it runs on the same server.\"\nread database_server\n\necho \"\ndatabase_username = \\\"$database_username\\\"\ndatabase_password = \\\"$database_password\\\"\ndatabase_server = \\\"$database_server\\\"\ndatabase_name = \\\"recon\\\"\n\ntelegram_bot_token = \\\"\\\"\ntelegram_chat_id = \\\"\\\"\n\" > \"credentials.py\"\n\necho \"[+] Creating database 'recon' with tables 'domains', scans and 'errors'\"\npython database/init_db.py\n\necho \"[+] Checking if the database was created successfully\"\npython database/db_test.py\n\necho \"----------------------------------------------------------------\"\n\necho \"[+] Adding a cron task to run 'run.py' every 12 hours. You can edit this with the command 'crontab -e'\"\necho \"[?] Adding the path to crontab. If this isn't the right path to the file, please edit this with the command 'crontab -e'\"\n#write out current crontab\ncrontab -l > mycron\n#echo new cron into cron file\necho \"0 */12 * * * python $(pwd)/run.py\" >> mycron\n#install new cron file\ncrontab mycron\nrm mycron\necho \"[+] Crontab task created!\"\n\necho \"----------------------------------------------------------------\"\n\necho \"[?] Do you want to create ICU.php? A simple web interface for the domains.\"\necho \"[Y/n]\"\nread choice_web\n\nif [ \"$choice_web\" == \"Y\" ] || [ \"$choice_web\" == \"y\" ] || [ -z \"$choice_web\" ]; then\n        ./web/setup.sh \"$database_username\" \"$database_password\" \"$database_server\"\n\techo \"[+] ICU.php was added.\"\nfi\n\necho \"----------------------------------------------------------------\"\n\necho \"[!] All set!\"\n\necho \"----------------------------------------------------------------\"\n\necho \"[+] If you want to use the telegram options, please add your telegram bot token in credentials.py.\"\necho \"[?] Do you want to run main.py? This script lets you manage your domains.\"\necho \"[Y/n]\"\nread choice_main\n\nif [ $choice_main = \"Y\" ] || [ $choice_main = \"y\" ] || [ -z $choice_main ]; then\n\tpython main.py\nfi\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}, {"old_path": "main.py", "new_path": "main.py", "filename": "main.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -19,6 +19,20 @@ cursor = connection.cursor()\n def exit_program():\n \tsys.exit()\n \n+\n+def list_scan_domains():\n+        scan_id = raw_input('[Scan ID] > ')\n+        cursor.execute (\"select Domain, Program from domains where scan_Id = %s\", (scan_id,))\n+        data = cursor.fetchall()\n+\n+        for row in data:\n+\t        print bcolors.BOLD + row[0] + bcolors.ENDC +  \" - \" +  bcolors.OKGREEN +  row[1] + bcolors.ENDC\n+\n+        raw_input(\"\\nPress any key to go back...\")\n+        start()\n+\n+\n+\n def list_subdomains():\n \tsub_domain = raw_input('[Domain] > ')\n \tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (sub_domain,))\n@@ -34,6 +48,12 @@ def list_subdomains():\n \tstart()\n \n \n+def run_scan():\n+\tprint \"[!] Running scan...\"\n+        os.system(\"python \" + os.path.dirname(os.path.abspath(__file__)) + \"/run.py\")\n+\n+\n+\n def run_subdomain_scan_on_target(top_domain_par = None):\n \tif top_domain_par is None:\n \t\tprint \"What is the domain?\"\n@@ -98,6 +118,8 @@ def insert_topdomain(top_domain_par = None):\n \tstart()\n \n \n+\n+\n def insert_subdomain(top_domain_par = None):\n \tif top_domain_par is None:\n \t\tprint \"What is the (top)domain? \"\n@@ -181,7 +203,9 @@ options = {1 : insert_topdomain,\n            4 : insert_subdomain,\n \t   5 : run_subdomain_scan_on_target,\n \t   6 : delete_top_domain,\n-           7 : exit_program\n+           7 : list_scan_domains,\n+           8 : run_scan,\n+           9 : exit_program\n }\n \n \n@@ -210,7 +234,9 @@ def start():\n 4. Add subdomain\n 5. Run subdomain scan on top domain\n 6. Delete a (top)domain\n-7. Exit\n+7. Get domains from scan ID \n+8. Run scan on all domains\n+9. Exit\n \"\"\"\n \n \tprint banner.format(bcolors.HEADER, domains, sub_domains, top_domains, bcolors.ENDC)\n", "diff_parsed": {"added": [[22, ""], [23, "def list_scan_domains():"], [24, "        scan_id = raw_input('[Scan ID] > ')"], [25, "        cursor.execute (\"select Domain, Program from domains where scan_Id = %s\", (scan_id,))"], [26, "        data = cursor.fetchall()"], [27, ""], [28, "        for row in data:"], [29, "\t        print bcolors.BOLD + row[0] + bcolors.ENDC +  \" - \" +  bcolors.OKGREEN +  row[1] + bcolors.ENDC"], [30, ""], [31, "        raw_input(\"\\nPress any key to go back...\")"], [32, "        start()"], [33, ""], [34, ""], [35, ""], [51, "def run_scan():"], [52, "\tprint \"[!] Running scan...\""], [53, "        os.system(\"python \" + os.path.dirname(os.path.abspath(__file__)) + \"/run.py\")"], [54, ""], [55, ""], [56, ""], [121, ""], [122, ""], [206, "           7 : list_scan_domains,"], [207, "           8 : run_scan,"], [208, "           9 : exit_program"], [237, "7. Get domains from scan ID"], [238, "8. Run scan on all domains"], [239, "9. Exit"]], "deleted": [[184, "           7 : exit_program"], [213, "7. Exit"]]}, "added_lines": 28, "deleted_lines": 2, "source_code": "#!/usr/bin/python\n\nimport os, sys, MySQLdb, time\nimport credentials\n\nclass bcolors:\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n\nconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\ncursor = connection.cursor()\n\ndef exit_program():\n\tsys.exit()\n\n\ndef list_scan_domains():\n        scan_id = raw_input('[Scan ID] > ')\n        cursor.execute (\"select Domain, Program from domains where scan_Id = %s\", (scan_id,))\n        data = cursor.fetchall()\n\n        for row in data:\n\t        print bcolors.BOLD + row[0] + bcolors.ENDC +  \" - \" +  bcolors.OKGREEN +  row[1] + bcolors.ENDC\n\n        raw_input(\"\\nPress any key to go back...\")\n        start()\n\n\n\ndef list_subdomains():\n\tsub_domain = raw_input('[Domain] > ')\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (sub_domain,))\n\tdata = cursor.fetchall()\n\n\tfor row in data:\n\t\tif ord(row[1]):\n\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n\t\telse:\n\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\ndef run_scan():\n\tprint \"[!] Running scan...\"\n        os.system(\"python \" + os.path.dirname(os.path.abspath(__file__)) + \"/run.py\")\n\n\n\ndef run_subdomain_scan_on_target(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the domain?\"\n\t\ttop_domain = raw_input('[Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__)) + \"/database/additional_tools/domains_db.py \" + top_domain + \" NULL\")\n\ndef delete_top_domain():\n\tprint \"What is the domain? \"\n\ttop_domain = raw_input('[Domain] > ')\n\n        cursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n        data = cursor.fetchone()\n\n\ttop_domain = int(data[0])\n\n        cursor.execute(\"delete from domains where topDomainID = %s\", (top_domain,))\n        connection.commit()\n\n        cursor.execute(\"delete from domains where DomainID = %s\", (top_domain,))\n        connection.commit()\n\n        print bcolors.OKGREEN + \"Domain with its subdomains deleted\" + bcolors.ENDC\n        raw_input(\"\\nPress any key to go back...\")\n        start()\n\n\ndef insert_topdomain(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the domain? \"\n\t\ttop_domain = raw_input('[Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n\tdata = cursor.fetchone()  \n\n\tif data:\n    \t\tprint bcolors.WARNING + \"Domains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n\t\traw_input(\"Press any key to go back...\")\n\t\tstart()\n\t\n\n\tprint \"What is the program? \"\n\tprogram = raw_input('[program] > ')\n\n\tprint \"Inscope? \"\n\tinscope = raw_input('[Y/n] > ')\n\tif \"n\" not in inscope.lower():\n\t\tinscope = 1\n\telse:\n\t\tinscope = 0\n\t\n\n\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active) VALUES (%s, %s, %s, %s)\", (program, inscope, top_domain, 1))\n\tconnection.commit()\n\t\n\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\n\n\ndef insert_subdomain(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the (top)domain? \"\n\t\ttop_domain = raw_input('[(Top)Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n\tdata = cursor.fetchone()  \n\n\tif not data:\n    \t\tprint bcolors.WARNING + \"Domain not found!\" + bcolors.ENDC\n\t\tprint \"Do you want to add it? \"\n\t\tanswer = raw_input('[Y/n] > ')\n\t\tif \"n\" not in answer.lower():\n\t\t\tinsert_topdomain(top_domain)\n\t\telse:\n\t\t\traw_input(\"Press any key to go back...\")\n\t\t\tstart()\n\n\tprogram = str(data[1])\n\ttopdomainid = int(data[0])\n\n\n\n\tprint \"What is the subdomain? \"\n\tsub_domain = raw_input('[(Subdomain] > ')\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (sub_domain,))\n\tdata = cursor.fetchone()  \n\n\tif data:\n    \t\tprint bcolors.WARNING + \"Subdomains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n\t\tdoes_not_exist = False\n\telse:\n\t\tdoes_not_exist = True\n\n\tif does_not_exist:\n\t\tprint \"Inscope? \"\n\t\tinscope = raw_input('[Y/n] > ')\n\t\tif \"n\" not in inscope.lower():\n\t\t\tinscope = 1\n\t\telse:\n\t\t\tinscope = 0\n\n\t\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active, TopDomainID) VALUES (%s, %s, %s, %s, %s)\", (program, inscope, sub_domain, 1, topdomainid))\n\t\tconnection.commit()\n\t\t\n\t\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n\n\tprint \"Do you want to add another one?? \"\n\tanother_one = raw_input('[Y/n] > ')\n\tif \"n\" not in another_one.lower():\n\n\t\tinsert_subdomain(top_domain)\n\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\n\ndef list_domains():\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID is NULL\")\n\tdata = cursor.fetchall()\n\n\tfor row in data:\n\t\tif ord(row[1]):\n\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n\t\telse:\n\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n\t\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\n\n\noptions = {1 : insert_topdomain,\n           2 : list_subdomains,\n           3 : list_domains,\n           4 : insert_subdomain,\n\t   5 : run_subdomain_scan_on_target,\n\t   6 : delete_top_domain,\n           7 : list_scan_domains,\n           8 : run_scan,\n           9 : exit_program\n}\n\n\ndef start():\n\tos.system('clear')\n\tcursor.execute (\"select count(*) from domains where TopDomainID is NULL;\")\n\tdata = cursor.fetchall()\n\tsub_domains = data[0][0]\n\n\tcursor.execute (\"select count(TopDomainID) from domains\")\n\tdata = cursor.fetchall()\n\ttop_domains = data[0][0]\n\n\tdomains = top_domains + sub_domains\n\n\tbanner = \"\"\" {0}---------------+-------\n Domains       | {1}   \n Top-domains   | {2}  \n Sudomains     | {3}   \n---------------+-------{4}\"\"\"\n\n\tchoices = \"\"\"\n1. Add domain\n2. List subdomains from domain\n3. List all (top)domains\n4. Add subdomain\n5. Run subdomain scan on top domain\n6. Delete a (top)domain\n7. Get domains from scan ID \n8. Run scan on all domains\n9. Exit\n\"\"\"\n\n\tprint banner.format(bcolors.HEADER, domains, sub_domains, top_domains, bcolors.ENDC)\n\n\tprint choices.format()\n\n\ttry:\n\t\tnum = raw_input('> ')\n\t\tnum = int(num)\n\texcept:\n\t\tprint \"Provide a number please,\"\n\t\traw_input(\"\\nPress any key to go back...\")\n\t\tstart()\n\t\tstart()\n\n\toptions[num]()\n\n\nstart()\ncursor.close ()\nconnection.close ()\nsys.exit()\n", "source_code_before": "#!/usr/bin/python\n\nimport os, sys, MySQLdb, time\nimport credentials\n\nclass bcolors:\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n\nconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\ncursor = connection.cursor()\n\ndef exit_program():\n\tsys.exit()\n\ndef list_subdomains():\n\tsub_domain = raw_input('[Domain] > ')\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (sub_domain,))\n\tdata = cursor.fetchall()\n\n\tfor row in data:\n\t\tif ord(row[1]):\n\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n\t\telse:\n\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\ndef run_subdomain_scan_on_target(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the domain?\"\n\t\ttop_domain = raw_input('[Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__)) + \"/database/additional_tools/domains_db.py \" + top_domain + \" NULL\")\n\ndef delete_top_domain():\n\tprint \"What is the domain? \"\n\ttop_domain = raw_input('[Domain] > ')\n\n        cursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n        data = cursor.fetchone()\n\n\ttop_domain = int(data[0])\n\n        cursor.execute(\"delete from domains where topDomainID = %s\", (top_domain,))\n        connection.commit()\n\n        cursor.execute(\"delete from domains where DomainID = %s\", (top_domain,))\n        connection.commit()\n\n        print bcolors.OKGREEN + \"Domain with its subdomains deleted\" + bcolors.ENDC\n        raw_input(\"\\nPress any key to go back...\")\n        start()\n\n\ndef insert_topdomain(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the domain? \"\n\t\ttop_domain = raw_input('[Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n\tdata = cursor.fetchone()  \n\n\tif data:\n    \t\tprint bcolors.WARNING + \"Domains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n\t\traw_input(\"Press any key to go back...\")\n\t\tstart()\n\t\n\n\tprint \"What is the program? \"\n\tprogram = raw_input('[program] > ')\n\n\tprint \"Inscope? \"\n\tinscope = raw_input('[Y/n] > ')\n\tif \"n\" not in inscope.lower():\n\t\tinscope = 1\n\telse:\n\t\tinscope = 0\n\t\n\n\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active) VALUES (%s, %s, %s, %s)\", (program, inscope, top_domain, 1))\n\tconnection.commit()\n\t\n\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\ndef insert_subdomain(top_domain_par = None):\n\tif top_domain_par is None:\n\t\tprint \"What is the (top)domain? \"\n\t\ttop_domain = raw_input('[(Top)Domain] > ')\n\telse:\n\t\ttop_domain = top_domain_par\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (top_domain,))\n\tdata = cursor.fetchone()  \n\n\tif not data:\n    \t\tprint bcolors.WARNING + \"Domain not found!\" + bcolors.ENDC\n\t\tprint \"Do you want to add it? \"\n\t\tanswer = raw_input('[Y/n] > ')\n\t\tif \"n\" not in answer.lower():\n\t\t\tinsert_topdomain(top_domain)\n\t\telse:\n\t\t\traw_input(\"Press any key to go back...\")\n\t\t\tstart()\n\n\tprogram = str(data[1])\n\ttopdomainid = int(data[0])\n\n\n\n\tprint \"What is the subdomain? \"\n\tsub_domain = raw_input('[(Subdomain] > ')\n\n\tcursor.execute (\"select * from domains where Domain = %s\", (sub_domain,))\n\tdata = cursor.fetchone()  \n\n\tif data:\n    \t\tprint bcolors.WARNING + \"Subdomains already exists; program: \" + str(data[1]) + \", last modified: \" + str(data[6]) + bcolors.ENDC\n\t\tdoes_not_exist = False\n\telse:\n\t\tdoes_not_exist = True\n\n\tif does_not_exist:\n\t\tprint \"Inscope? \"\n\t\tinscope = raw_input('[Y/n] > ')\n\t\tif \"n\" not in inscope.lower():\n\t\t\tinscope = 1\n\t\telse:\n\t\t\tinscope = 0\n\n\t\tcursor.execute(\"INSERT INTO domains (Program, InScope, Domain, Active, TopDomainID) VALUES (%s, %s, %s, %s, %s)\", (program, inscope, sub_domain, 1, topdomainid))\n\t\tconnection.commit()\n\t\t\n\t\tprint bcolors.OKGREEN + \"Domain added\" + bcolors.ENDC\n\n\tprint \"Do you want to add another one?? \"\n\tanother_one = raw_input('[Y/n] > ')\n\tif \"n\" not in another_one.lower():\n\n\t\tinsert_subdomain(top_domain)\n\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\n\ndef list_domains():\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID is NULL\")\n\tdata = cursor.fetchall()\n\n\tfor row in data:\n\t\tif ord(row[1]):\n\t\t\tprint bcolors.OKGREEN + row[0] + bcolors.ENDC\n\t\telse:\n\t\t\tprint bcolors.WARNING + row[0] + bcolors.ENDC\t\n\t\n\traw_input(\"\\nPress any key to go back...\")\n\tstart()\n\n\n\n\noptions = {1 : insert_topdomain,\n           2 : list_subdomains,\n           3 : list_domains,\n           4 : insert_subdomain,\n\t   5 : run_subdomain_scan_on_target,\n\t   6 : delete_top_domain,\n           7 : exit_program\n}\n\n\ndef start():\n\tos.system('clear')\n\tcursor.execute (\"select count(*) from domains where TopDomainID is NULL;\")\n\tdata = cursor.fetchall()\n\tsub_domains = data[0][0]\n\n\tcursor.execute (\"select count(TopDomainID) from domains\")\n\tdata = cursor.fetchall()\n\ttop_domains = data[0][0]\n\n\tdomains = top_domains + sub_domains\n\n\tbanner = \"\"\" {0}---------------+-------\n Domains       | {1}   \n Top-domains   | {2}  \n Sudomains     | {3}   \n---------------+-------{4}\"\"\"\n\n\tchoices = \"\"\"\n1. Add domain\n2. List subdomains from domain\n3. List all (top)domains\n4. Add subdomain\n5. Run subdomain scan on top domain\n6. Delete a (top)domain\n7. Exit\n\"\"\"\n\n\tprint banner.format(bcolors.HEADER, domains, sub_domains, top_domains, bcolors.ENDC)\n\n\tprint choices.format()\n\n\ttry:\n\t\tnum = raw_input('> ')\n\t\tnum = int(num)\n\texcept:\n\t\tprint \"Provide a number please,\"\n\t\traw_input(\"\\nPress any key to go back...\")\n\t\tstart()\n\t\tstart()\n\n\toptions[num]()\n\n\nstart()\ncursor.close ()\nconnection.close ()\nsys.exit()\n", "methods": [{"name": "exit_program", "start_line": 19, "end_line": 20}, {"name": "list_scan_domains", "start_line": 23, "end_line": 32}, {"name": "list_subdomains", "start_line": 36, "end_line": 48}, {"name": "run_scan", "start_line": 51, "end_line": 53}, {"name": "run_subdomain_scan_on_target", "start_line": 57, "end_line": 64}, {"name": "delete_top_domain", "start_line": 66, "end_line": 83}, {"name": "insert_topdomain", "start_line": 86, "end_line": 118}, {"name": "insert_subdomain", "start_line": 123, "end_line": 180}, {"name": "list_domains", "start_line": 184, "end_line": 195}, {"name": "start", "start_line": 212, "end_line": 255}], "methods_before": [{"name": "exit_program", "start_line": 19, "end_line": 20}, {"name": "list_subdomains", "start_line": 22, "end_line": 34}, {"name": "run_subdomain_scan_on_target", "start_line": 37, "end_line": 44}, {"name": "delete_top_domain", "start_line": 46, "end_line": 63}, {"name": "insert_topdomain", "start_line": 66, "end_line": 98}, {"name": "insert_subdomain", "start_line": 101, "end_line": 158}, {"name": "list_domains", "start_line": 162, "end_line": 173}, {"name": "start", "start_line": 188, "end_line": 229}], "changed_methods": [{"name": "run_scan", "start_line": 51, "end_line": 53}, {"name": "list_scan_domains", "start_line": 23, "end_line": 32}, {"name": "start", "start_line": 212, "end_line": 255}], "nloc": 186, "complexity": 27, "token_count": 1071}], "dmm_unit_size": 0.8461538461538461, "dmm_unit_complexity": 1.0, "dmm_unit_interfacing": 1.0},
    {"hash": "3ee66139188a56cd9ce96f0dfd43563342c9ef41", "msg": "Update README.md", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-13 21:36:56+00:00", "author_timezone": 0, "committer_date": "2018-06-13 21:36:56+00:00", "committer_timezone": 0, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["6178efa2cffcf6638d4955c297a61db4ee074a6f"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 0, "insertions": 2, "lines": 2, "files": 1, "modified_files": [{"old_path": "README.md", "new_path": "README.md", "filename": "README.md", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -32,6 +32,8 @@ The install script offers an option to install the modules from requirements.txt\n # Extra\n To get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n  \n+![online.py](https://poc-server.com/github/ICU/online.gif) \n+ \n # Credits \n Credits to:  \n [Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n", "diff_parsed": {"added": [[35, "![online.py](https://poc-server.com/github/ICU/online.gif)"], [36, ""]], "deleted": []}, "added_lines": 2, "deleted_lines": 0, "source_code": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n  \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n![online.py](https://poc-server.com/github/ICU/online.gif) \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "source_code_before": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n  \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "14d24c74ba4993551d86c218b2ea6f5fb2167ef1", "msg": "Update README.md", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-13 21:37:48+00:00", "author_timezone": 0, "committer_date": "2018-06-13 21:37:48+00:00", "committer_timezone": 0, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["3ee66139188a56cd9ce96f0dfd43563342c9ef41"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 1, "insertions": 1, "lines": 2, "files": 1, "modified_files": [{"old_path": "README.md", "new_path": "README.md", "filename": "README.md", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -32,7 +32,7 @@ The install script offers an option to install the modules from requirements.txt\n # Extra\n To get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n  \n-![online.py](https://poc-server.com/github/ICU/online.gif) \n+![main.py](https://poc-server.com/github/ICU/main.py.png) \n  \n # Credits \n Credits to:  \n", "diff_parsed": {"added": [[35, "![main.py](https://poc-server.com/github/ICU/main.py.png)"]], "deleted": [[35, "![online.py](https://poc-server.com/github/ICU/online.gif)"]]}, "added_lines": 1, "deleted_lines": 1, "source_code": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n  \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n![main.py](https://poc-server.com/github/ICU/main.py.png) \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "source_code_before": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n  \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n![online.py](https://poc-server.com/github/ICU/online.gif) \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "72b06e5b408dd235dc01cdf170b056382c5d698f", "msg": "Update README.md", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-13 21:38:43+00:00", "author_timezone": 0, "committer_date": "2018-06-13 21:38:43+00:00", "committer_timezone": 0, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["14d24c74ba4993551d86c218b2ea6f5fb2167ef1"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 0, "insertions": 2, "lines": 2, "files": 1, "modified_files": [{"old_path": "README.md", "new_path": "README.md", "filename": "README.md", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -23,6 +23,8 @@ go get github.com/Ice3man543/subfinder\n \n # Telegram \n ICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n+\n+![Telegram Bot](https://poc-server.com/github/ICU/telegram_ICU.png)\n  \n # Modules \n The following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n", "diff_parsed": {"added": [[26, ""], [27, "![Telegram Bot](https://poc-server.com/github/ICU/telegram_ICU.png)"]], "deleted": []}, "added_lines": 2, "deleted_lines": 0, "source_code": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n  \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n\n![Telegram Bot](https://poc-server.com/github/ICU/telegram_ICU.png)\n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n![main.py](https://poc-server.com/github/ICU/main.py.png) \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "source_code_before": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n  \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n![main.py](https://poc-server.com/github/ICU/main.py.png) \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "fc1a5555cc2f3b9ddf0b35ad1b0ad8f2d2bdb38e", "msg": "Update README.md", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-13 21:39:37+00:00", "author_timezone": 0, "committer_date": "2018-06-13 21:39:37+00:00", "committer_timezone": 0, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["72b06e5b408dd235dc01cdf170b056382c5d698f"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 2, "insertions": 3, "lines": 5, "files": 1, "modified_files": [{"old_path": "README.md", "new_path": "README.md", "filename": "README.md", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -2,6 +2,9 @@\n ICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n   \n ICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n+\n+  \n+  ![main.py](![main.py](https://poc-server.com/github/ICU/main.py.png) )\n   \n # Install \n ```\n@@ -34,8 +37,6 @@ The install script offers an option to install the modules from requirements.txt\n # Extra\n To get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n  \n-![main.py](https://poc-server.com/github/ICU/main.py.png) \n- \n # Credits \n Credits to:  \n [Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n", "diff_parsed": {"added": [[5, ""], [6, ""], [7, "  ![main.py](![main.py](https://poc-server.com/github/ICU/main.py.png) )"]], "deleted": [[37, "![main.py](https://poc-server.com/github/ICU/main.py.png)"], [38, ""]]}, "added_lines": 3, "deleted_lines": 2, "source_code": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n\n  \n  ![main.py](![main.py](https://poc-server.com/github/ICU/main.py.png) )\n  \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n\n![Telegram Bot](https://poc-server.com/github/ICU/telegram_ICU.png)\n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "source_code_before": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n  \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n\n![Telegram Bot](https://poc-server.com/github/ICU/telegram_ICU.png)\n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n![main.py](https://poc-server.com/github/ICU/main.py.png) \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "b9bd5f517720b0ca1a4724a53184cb365e5dafb2", "msg": "Update README.md", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-13 21:40:05+00:00", "author_timezone": 0, "committer_date": "2018-06-13 21:40:05+00:00", "committer_timezone": 0, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["fc1a5555cc2f3b9ddf0b35ad1b0ad8f2d2bdb38e"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 1, "insertions": 1, "lines": 2, "files": 1, "modified_files": [{"old_path": "README.md", "new_path": "README.md", "filename": "README.md", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -4,7 +4,7 @@ ICU is a tool to constantly keep an updated database of domains and subdomains,\n ICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n \n   \n-  ![main.py](![main.py](https://poc-server.com/github/ICU/main.py.png) )\n+![main.py](https://poc-server.com/github/ICU/main.py.png)\n   \n # Install \n ```\n", "diff_parsed": {"added": [[7, "![main.py](https://poc-server.com/github/ICU/main.py.png)"]], "deleted": [[7, "  ![main.py](![main.py](https://poc-server.com/github/ICU/main.py.png) )"]]}, "added_lines": 1, "deleted_lines": 1, "source_code": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n\n  \n![main.py](https://poc-server.com/github/ICU/main.py.png)\n  \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n\n![Telegram Bot](https://poc-server.com/github/ICU/telegram_ICU.png)\n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "source_code_before": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n\n  \n  ![main.py](![main.py](https://poc-server.com/github/ICU/main.py.png) )\n  \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n\n![Telegram Bot](https://poc-server.com/github/ICU/telegram_ICU.png)\n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "a8596e11765a5c3cbfb61d61af60a734a65b2c16", "msg": "Update README.md", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-14 11:40:44+02:00", "author_timezone": -7200, "committer_date": "2018-06-14 11:40:44+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["b9bd5f517720b0ca1a4724a53184cb365e5dafb2"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 6, "insertions": 8, "lines": 14, "files": 1, "modified_files": [{"old_path": "README.md", "new_path": "README.md", "filename": "README.md", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -3,9 +3,7 @@ ICU is a tool to constantly keep an updated database of domains and subdomains,\n   \n ICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n \n-  \n-![main.py](https://poc-server.com/github/ICU/main.py.png)\n-  \n+    \n # Install \n ```\n git clone https://github.com/003random/ICU  \n@@ -26,9 +24,7 @@ go get github.com/Ice3man543/subfinder\n \n # Telegram \n ICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n-\n-![Telegram Bot](https://poc-server.com/github/ICU/telegram_ICU.png)\n- \n+   \n # Modules \n The following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n  \n@@ -40,6 +36,12 @@ To get ICU up and running, requires some simple skills. If you need serious help\n # Credits \n Credits to:  \n [Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n+\n+# Images  \n+![main.py](https://poc-server.com/github/ICU/main.py.png)\n+  ___  \n+![Telegram Bot](https://poc-server.com/github/ICU/telegram_ICU.png)\n+\n  \n *Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n \n", "diff_parsed": {"added": [[6, ""], [27, ""], [39, ""], [40, "# Images"], [41, "![main.py](https://poc-server.com/github/ICU/main.py.png)"], [42, "  ___"], [43, "![Telegram Bot](https://poc-server.com/github/ICU/telegram_ICU.png)"], [44, ""]], "deleted": [[6, ""], [7, "![main.py](https://poc-server.com/github/ICU/main.py.png)"], [8, ""], [29, ""], [30, "![Telegram Bot](https://poc-server.com/github/ICU/telegram_ICU.png)"], [31, ""]]}, "added_lines": 8, "deleted_lines": 6, "source_code": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n\n    \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n   \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n\n# Images  \n![main.py](https://poc-server.com/github/ICU/main.py.png)\n  ___  \n![Telegram Bot](https://poc-server.com/github/ICU/telegram_ICU.png)\n\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "source_code_before": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n\n  \n![main.py](https://poc-server.com/github/ICU/main.py.png)\n  \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n\n![Telegram Bot](https://poc-server.com/github/ICU/telegram_ICU.png)\n \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "300c2727ee17d8bd05f99af891dfe6c7d0f956c0", "msg": "Update README.md", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-14 11:44:13+02:00", "author_timezone": -7200, "committer_date": "2018-06-14 11:44:13+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["a8596e11765a5c3cbfb61d61af60a734a65b2c16"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 1, "insertions": 1, "lines": 2, "files": 1, "modified_files": [{"old_path": "README.md", "new_path": "README.md", "filename": "README.md", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -40,7 +40,7 @@ Credits to:\n # Images  \n ![main.py](https://poc-server.com/github/ICU/main.py.png)\n   ___  \n-![Telegram Bot](https://poc-server.com/github/ICU/telegram_ICU.png)\n+![Telegram Bot](https://poc-server.com/github/ICU/telegrambot.png)\n \n  \n *Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n", "diff_parsed": {"added": [[43, "![Telegram Bot](https://poc-server.com/github/ICU/telegrambot.png)"]], "deleted": [[43, "![Telegram Bot](https://poc-server.com/github/ICU/telegram_ICU.png)"]]}, "added_lines": 1, "deleted_lines": 1, "source_code": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n\n    \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n   \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n\n# Images  \n![main.py](https://poc-server.com/github/ICU/main.py.png)\n  ___  \n![Telegram Bot](https://poc-server.com/github/ICU/telegrambot.png)\n\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "source_code_before": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n\n    \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n   \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n\n# Images  \n![main.py](https://poc-server.com/github/ICU/main.py.png)\n  ___  \n![Telegram Bot](https://poc-server.com/github/ICU/telegram_ICU.png)\n\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "b3c2fb358208e96e4f8991f8d136806835b58cd8", "msg": "remove test creds", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-14 18:31:00+00:00", "author_timezone": 0, "committer_date": "2018-06-14 18:31:00+00:00", "committer_timezone": 0, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["300c2727ee17d8bd05f99af891dfe6c7d0f956c0"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 0, "insertions": 0, "lines": 0, "files": 1, "modified_files": [{"old_path": "credentials.pyc", "new_path": "credentials.pyc", "filename": "credentials.pyc", "change_type": "ModificationType.DELETE", "change_type_name": "DELETE", "diff": "Binary files a/credentials.pyc and /dev/null differ\n", "diff_parsed": {"added": [], "deleted": []}, "added_lines": 0, "deleted_lines": 0, "source_code": null, "source_code_before": "\u0003\r\n![c\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000@\u0000\u0000\u0000s(\u0000\u0000\u0000d\u0000\u0000Z\u0000\u0000d\u0001\u0000Z\u0001\u0000d\u0002\u0000Z\u0002\u0000d\u0003\u0000Z\u0003\u0000d\u0004\u0000Z\u0004\u0000d\u0004\u0000Z\u0005\u0000d\u0005\u0000S(\u0006\u0000\u0000\u0000t\u0003\u0000\u0000\u0000rjpt\u0004\u0000\u0000\u00001484t\t\u0000\u0000\u0000localhostt\u0005\u0000\u0000\u0000recont\u0000\u0000\u0000\u0000N(\u0006\u0000\u0000\u0000t\u0011\u0000\u0000\u0000database_usernamet\u0011\u0000\u0000\u0000database_passwordt\u000f\u0000\u0000\u0000database_servert\r\u0000\u0000\u0000database_namet\u0012\u0000\u0000\u0000telegram_bot_tokent\u0010\u0000\u0000\u0000telegram_chat_id(\u0000\u0000\u0000\u0000(\u0000\u0000\u0000\u0000(\u0000\u0000\u0000\u0000s)\u0000\u0000\u0000/home/rjp/ICU_/database/../credentials.pyt\b\u0000\u0000\u0000<module>\u0002\u0000\u0000\u0000s\n\u0000\u0000\u0000\u0006\u0001\u0006\u0001\u0006\u0001\u0006\u0002\u0006\u0001", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "53ff349f67588a5e54bdfc359c7ae4538bd9a50c", "msg": "Update bot.py", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-15 13:00:44+02:00", "author_timezone": -7200, "committer_date": "2018-06-15 13:00:44+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["b3c2fb358208e96e4f8991f8d136806835b58cd8"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 21, "insertions": 106, "lines": 127, "files": 1, "modified_files": [{"old_path": "telegram/bot.py", "new_path": "telegram/bot.py", "filename": "bot.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -31,7 +31,7 @@ def start(bot, update):\n \n \tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n \t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n-\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]\n+\t\t\t[InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]\n \n \treply_markup = InlineKeyboardMarkup(keyboard)\n \tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n@@ -48,40 +48,40 @@ def button(bot, update):\n \theader_1 = \"Catagory:\"\n \tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n \t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n-\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + r)]]\n+\t\t\t[InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + r)]]\n \n \theader_2 = \"Action:\"\n \tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n \t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n \t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n-\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n+\t\t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to catagories\", callback_data='back-' + r)]]\n \n \theader_3 = \"Action:\"\n \tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n \t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n \t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n-\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n+\t\t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to catagories\", callback_data='back-' + r)]]\n \n         header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n         keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                          InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n-                        [InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n+                        [InlineKeyboardButton(\"\u00c2\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n \n         header_5 = \"Action:\"\n         keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n                          InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n \t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n-                        [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]\n+                        [InlineKeyboardButton(\"\u00c2\u00ab Back to data\", callback_data='back_data-' + r)]]\n \n         header_6 = \"Which type of domains?\"\n         keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active-' + r),\n                          InlineKeyboardButton(\"All\", callback_data='all-' + r)],\n-                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n+                        [InlineKeyboardButton(\"\u00c2\u00ab Back to actions\", callback_data='back_get-' + r)]]\n \n         header_7 = \"How many domains?\"\n         keyboard_7 = [[InlineKeyboardButton(\"Top 20\", callback_data='limit-' + r),\n                          InlineKeyboardButton(\"All\", callback_data='nolimit-' + r)],\n-                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_data-' + r)]]\n+                        [InlineKeyboardButton(\"\u00c2\u00ab Back to actions\", callback_data='back_data-' + r)]]\n \n \n \t#ToDO: Transform into a swtich\n@@ -118,23 +118,26 @@ def button(bot, update):\n         if choice == \"add\":\n                 cursor.close()\n                 connection.close()\n-\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n-\t\treturn ADD_DOMAIN\n+\t\tbot.send_message(text=\"Coming soon, pr's are welcome...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n+\t\treturn BUTTON\n+\t\t#return ADD_DOMAIN\n         elif choice == \"edit\":\n                 cursor.close()\n                 connection.close()\n-\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n-                return EDIT_DOMAIN\n+\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n+                return BUTTON\n+\t\t#return EDIT_DOMAIN\n         elif choice == \"get\":\n                 cursor.close()\n                 connection.close()\n                 bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                 return BUTTON\n \n-        if choice == \"topdomais\":\n-                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n+        if choice == \"topdomains\":\n+                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                 global subdomains\n \t\tsubdomains = False\n+\t\tprint \"choice = topdomains\"\n \t\treturn BUTTON\n         elif choice == \"subdomains\":\n                 bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n@@ -142,8 +145,9 @@ def button(bot, update):\n \t\tsubdomains = True\n \t\treturn BUTTON\n         elif choice == \"contains\":\n-\t\tbot.send_message(text=\"What is the search string?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n-                return CONTAINS\n+\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n+                return BUTTON\n+\t\t#return CONTAINS\n         elif choice == \"back_data\":\n                 bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                 return BUTTON\n@@ -163,6 +167,7 @@ def button(bot, update):\n                 return BUTTON\n \n         if choice == \"nolimit\":\n+\t\tprint \"Nolimit\"\n \t\tglobal subdomains\n \t\tif subdomains:\n                         global limit\n@@ -170,20 +175,24 @@ def button(bot, update):\n \t\t\tbot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n \t\t\treturn GET_DOMAINS\n \t\telse:\n+\t\t\tprint \"topdomain\"\n \t\t\tglobal limit\n \t\t\tlimit = False\n-\t\t\tget_topdomains()\n+\t\t\tget_topdomains(bot, update)\n+\n         elif choice == \"limit\":\n                 global subdomains\n+\t\tprint \"Limit\"\n                 if subdomains:\n                         global limit\n                         limit = True\n                         bot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                         return GET_DOMAINS\n                 else:\n+\t\t\tprint \"Topdomain\"\n                         global limit\n                         limit = True\n-\t\t\tget_topdomains()\n+\t\t\tget_topdomains(bot, update)\n \n \tif choice == \"yes_scan\":\n \t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n@@ -236,7 +245,7 @@ def run_scan(bot, update, cursor):\n \t        \theader_4 = \"It looks like a scan is already running. Want to start a new one?\"\n         \t\tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                 \t\t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n-                        \t\t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n+                        \t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n \t\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n \t\t\treturn BUTTON\n \texcept Exception, e:\n@@ -288,11 +297,87 @@ def edit_domain(bot, update):\n \treturn BUTTON\n \n \n-def get_domains():\n-\tprint update.message.text\n+def get_topdomains(bot, update):\n+\tglobal limit\n+\tprint \"Inside get_topdomains\"\n+\n+\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n+\tcursor = connection.cursor ()\n+\n+\tif limit == True:\n+\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain limit 20\")\t\n+\telse:\n+\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\n+\n+\n+        data = cursor.fetchall()\n+        cursor.close()\n+        connection.close()\n+\n+        domains_message = \"\"\n+\n+        if not data:\n+                domains_message = \"No domains found\"\n+\n+        for row in data:\n+                domains_message += \"\\n\" + row[0]\n+\n+\tbot.send_message(chat_id=credentials.telegram_chat_id, text=domains_message, parse_mode=telegram.ParseMode.MARKDOWN)\n+        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n+                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n+                        [InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]\n+\n+        reply_markup = InlineKeyboardMarkup(keyboard)\n+\tbot.send_message(chat_id=credentials.telegram_chat_id, text=\"Hi again!\", reply_markup=reply_markup)\n+        return BUTTON\n+\n+\n+\n+def get_domains(bot, update):\n+\tglobal active\n+\tglobal limit\n+\tprint \"active: \" + str(active)\n+\tprint \"limit: \" + str(limit)\n+\tprint \"domain: \" + update.message.text\n+\n+\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n+\tcursor = connection.cursor ()\n+\n+\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (update.message.text,))\n+\n+\tdata = cursor.fetchall()\n+\tcursor.close()\n+\tconnection.close()\n+\n+\tsubdomains_message = \"\"\n+\n+\tif not data:\n+\t\tsubdomains_message = \"No subdomains found for \" + str(update.message.text)\n+\n+\tif active == True:\n+\t\tdata = [x for x in data if ord(x[1]) == True]\n+\n+\tif limit == True:\n+\t\tprint \"Limit is True if\"\n+\t\tdata = data[:20]\n+\n+\tfor row in data:\n+\t\tsubdomains_message += \"\\n\" + row[0]\n+\n+\tupdate.message.reply_text(subdomains_message)\n+\n+        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n+                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n+                        [InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]\n+\n+        reply_markup = InlineKeyboardMarkup(keyboard)\n+        update.message.reply_text(\"Hi again :wave:\", reply_markup=reply_markup)\n \treturn BUTTON\n \n \n+\n+\n+\n def domains_contain(bot, update):\n \tprint update.message.text\n \treturn BUTTON\n", "diff_parsed": {"added": [[34, "\t\t\t[InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]"], [51, "\t\t\t[InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + r)]]"], [57, "\t\t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to catagories\", callback_data='back-' + r)]]"], [63, "\t\t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to catagories\", callback_data='back-' + r)]]"], [68, "                        [InlineKeyboardButton(\"\u00c2\u00ab Back to scans\", callback_data='back_scan-' + r)]]"], [74, "                        [InlineKeyboardButton(\"\u00c2\u00ab Back to data\", callback_data='back_data-' + r)]]"], [79, "                        [InlineKeyboardButton(\"\u00c2\u00ab Back to actions\", callback_data='back_get-' + r)]]"], [84, "                        [InlineKeyboardButton(\"\u00c2\u00ab Back to actions\", callback_data='back_data-' + r)]]"], [121, "\t\tbot.send_message(text=\"Coming soon, pr's are welcome...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)"], [122, "\t\treturn BUTTON"], [123, "\t\t#return ADD_DOMAIN"], [127, "\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)"], [128, "                return BUTTON"], [129, "\t\t#return EDIT_DOMAIN"], [136, "        if choice == \"topdomains\":"], [137, "                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)"], [140, "\t\tprint \"choice = topdomains\""], [148, "\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)"], [149, "                return BUTTON"], [150, "\t\t#return CONTAINS"], [170, "\t\tprint \"Nolimit\""], [178, "\t\t\tprint \"topdomain\""], [181, "\t\t\tget_topdomains(bot, update)"], [182, ""], [185, "\t\tprint \"Limit\""], [192, "\t\t\tprint \"Topdomain\""], [195, "\t\t\tget_topdomains(bot, update)"], [248, "                        \t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to scans\", callback_data='back_scan-' + r)]]"], [300, "def get_topdomains(bot, update):"], [301, "\tglobal limit"], [302, "\tprint \"Inside get_topdomains\""], [303, ""], [304, "\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)"], [305, "\tcursor = connection.cursor ()"], [306, ""], [307, "\tif limit == True:"], [308, "\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain limit 20\")"], [309, "\telse:"], [310, "\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")"], [311, ""], [312, ""], [313, "        data = cursor.fetchall()"], [314, "        cursor.close()"], [315, "        connection.close()"], [316, ""], [317, "        domains_message = \"\""], [318, ""], [319, "        if not data:"], [320, "                domains_message = \"No domains found\""], [321, ""], [322, "        for row in data:"], [323, "                domains_message += \"\\n\" + row[0]"], [324, ""], [325, "\tbot.send_message(chat_id=credentials.telegram_chat_id, text=domains_message, parse_mode=telegram.ParseMode.MARKDOWN)"], [326, "        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),"], [327, "                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],"], [328, "                        [InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]"], [329, ""], [330, "        reply_markup = InlineKeyboardMarkup(keyboard)"], [331, "\tbot.send_message(chat_id=credentials.telegram_chat_id, text=\"Hi again!\", reply_markup=reply_markup)"], [332, "        return BUTTON"], [333, ""], [334, ""], [335, ""], [336, "def get_domains(bot, update):"], [337, "\tglobal active"], [338, "\tglobal limit"], [339, "\tprint \"active: \" + str(active)"], [340, "\tprint \"limit: \" + str(limit)"], [341, "\tprint \"domain: \" + update.message.text"], [342, ""], [343, "\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)"], [344, "\tcursor = connection.cursor ()"], [345, ""], [346, "\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (update.message.text,))"], [347, ""], [348, "\tdata = cursor.fetchall()"], [349, "\tcursor.close()"], [350, "\tconnection.close()"], [351, ""], [352, "\tsubdomains_message = \"\""], [353, ""], [354, "\tif not data:"], [355, "\t\tsubdomains_message = \"No subdomains found for \" + str(update.message.text)"], [356, ""], [357, "\tif active == True:"], [358, "\t\tdata = [x for x in data if ord(x[1]) == True]"], [359, ""], [360, "\tif limit == True:"], [361, "\t\tprint \"Limit is True if\""], [362, "\t\tdata = data[:20]"], [363, ""], [364, "\tfor row in data:"], [365, "\t\tsubdomains_message += \"\\n\" + row[0]"], [366, ""], [367, "\tupdate.message.reply_text(subdomains_message)"], [368, ""], [369, "        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),"], [370, "                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],"], [371, "                        [InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]"], [372, ""], [373, "        reply_markup = InlineKeyboardMarkup(keyboard)"], [374, "        update.message.reply_text(\"Hi again :wave:\", reply_markup=reply_markup)"], [378, ""], [379, ""], [380, ""]], "deleted": [[34, "\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]"], [51, "\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + r)]]"], [57, "\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]"], [63, "\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]"], [68, "                        [InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]"], [74, "                        [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]"], [79, "                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]"], [84, "                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_data-' + r)]]"], [121, "\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)"], [122, "\t\treturn ADD_DOMAIN"], [126, "\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)"], [127, "                return EDIT_DOMAIN"], [134, "        if choice == \"topdomais\":"], [135, "                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)"], [145, "\t\tbot.send_message(text=\"What is the search string?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)"], [146, "                return CONTAINS"], [175, "\t\t\tget_topdomains()"], [186, "\t\t\tget_topdomains()"], [239, "                        \t\t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]"], [291, "def get_domains():"], [292, "\tprint update.message.text"]]}, "added_lines": 106, "deleted_lines": 21, "source_code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport logging, datetime, MySQLdb, os, telegram, sys\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nfrom random import randint\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\nimport credentials\n\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\ntelegram_bot_token = credentials.telegram_bot_token\n\nlogger = logging.getLogger(__name__)\n\nBUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n\ndef start(bot, update):\n\tprint \"---------- Start -----------\"\n\tif str(update.message.chat_id) != str(credentials.telegram_chat_id):\n\t\tupdate.message.reply_text(\"Not authorized! If you think this is a mistake, please check if your chat_id is in credentials.py. You can also run setup.py in /telegram to setup the right credentials for your telegram.\")\n\t\treturn\n\n\tuser = update.message.from_user\n\thour = datetime.datetime.now().hour\n\tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])\n\n\tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n\t\t\t[InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n\treply_markup = InlineKeyboardMarkup(keyboard)\n\tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n\tprint \"button before\"\n\treturn BUTTON\n\n\ndef button(bot, update):\n\tquery = update.callback_query\n\t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button\n\tchoice = query.data.split('-')[0]\n\tr = str(randint(0, 99))\n\n\theader_1 = \"Catagory:\"\n\tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + r)]]\n\n\theader_2 = \"Action:\"\n\tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n\t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n\t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n\theader_3 = \"Action:\"\n\tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n\t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n\t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        [InlineKeyboardButton(\"\u00c2\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n        header_5 = \"Action:\"\n        keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n                         InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n\t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n                        [InlineKeyboardButton(\"\u00c2\u00ab Back to data\", callback_data='back_data-' + r)]]\n\n        header_6 = \"Which type of domains?\"\n        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='all-' + r)],\n                        [InlineKeyboardButton(\"\u00c2\u00ab Back to actions\", callback_data='back_get-' + r)]]\n\n        header_7 = \"How many domains?\"\n        keyboard_7 = [[InlineKeyboardButton(\"Top 20\", callback_data='limit-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='nolimit-' + r)],\n                        [InlineKeyboardButton(\"\u00c2\u00ab Back to actions\", callback_data='back_data-' + r)]]\n\n\n\t#ToDO: Transform into a swtich\n\tif choice == \"back\":\n\t\tbot.edit_message_text(header_1, reply_markup=InlineKeyboardMarkup(keyboard_1), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"close\":\n\t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn ConversationHandler.END\n\telif choice == \"scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"data\":\n\t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif choice == \"latest\":\n\t\tget_latest_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\telif choice == \"custom\":\n\t\tget_custom_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\t\treturn CUSTOM_SCAN_ID_INPUT\n\telif choice == \"run\":\n\t\trun_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\n        if choice == \"add\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"Coming soon, pr's are welcome...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\treturn BUTTON\n\t\t#return ADD_DOMAIN\n        elif choice == \"edit\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return BUTTON\n\t\t#return EDIT_DOMAIN\n        elif choice == \"get\":\n                cursor.close()\n                connection.close()\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"topdomains\":\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = False\n\t\tprint \"choice = topdomains\"\n\t\treturn BUTTON\n        elif choice == \"subdomains\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = True\n\t\treturn BUTTON\n        elif choice == \"contains\":\n\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return BUTTON\n\t\t#return CONTAINS\n        elif choice == \"back_data\":\n                bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"back_get\":\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"active\":\n\t\tglobal active\n\t\tactive = True\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n        elif choice == \"all\":\n                global active\n                active = False\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"nolimit\":\n\t\tprint \"Nolimit\"\n\t\tglobal subdomains\n\t\tif subdomains:\n                        global limit\n                        limit = False\n\t\t\tbot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\treturn GET_DOMAINS\n\t\telse:\n\t\t\tprint \"topdomain\"\n\t\t\tglobal limit\n\t\t\tlimit = False\n\t\t\tget_topdomains(bot, update)\n\n        elif choice == \"limit\":\n                global subdomains\n\t\tprint \"Limit\"\n                if subdomains:\n                        global limit\n                        limit = True\n                        bot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                        return GET_DOMAINS\n                else:\n\t\t\tprint \"Topdomain\"\n                        global limit\n                        limit = True\n\t\t\tget_topdomains(bot, update)\n\n\tif choice == \"yes_scan\":\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telif choice == \"back_scan\" or choice == \"no_scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\ndef get_latest_scan(bot, update, cursor):\n\tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))\n\telse:\n\t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\n\ndef get_custom_scan(bot, update, cursor):\n\tquery = update.callback_query\n\n\tcursor.execute (\"SELECT ScanID FROM scans where EndDate is not null ORDER BY ScanID DESC LIMIT 10\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tlatestScanIds = sorted([str(x[0]) for x in data])\n\t\tfirstRow = latestScanIds[:len(latestScanIds)/2]\n\t\tsecondRow = latestScanIds[len(latestScanIds)/2:]\n\t\tcustom_keyboard = [firstRow, secondRow]\n\t\treply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\n\n\t\tif data:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\ttext=\"Which scan ID? \\n/cancel to cancel\",\n\t\t\t\treply_markup=reply_markup, ForceReply = True)\n\t\telse:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\t text=\"Which scan ID? \\n/cancel to cancel\")\n\n\ndef run_scan(bot, update, cursor):\n\tquery = update.callback_query\n\tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")\n\tdata = cursor.fetchall()\n\ttry:\n\t\tif data[0][2] != None:\n\t\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\t\telse:\n\t\t\tr = str(randint(0, 99))\n\t        \theader_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        \t\tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                \t\t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        \t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\t\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\t\treturn BUTTON\n\texcept Exception, e:\n\t\tprint \"error: \" + str(e)\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\n\ndef custom_scan_id_input(bot, update):\n\tprint \"inside input method with data: \" + update.message.text\n\tcustomId = update.message.text\n\ttry:\n\t\tint(customId)\n\texcept ValueError:\n\t\tprint \"invalid number\"\n\t\tupdate.message.reply_text(\"Not a valid number\")\n\telse:\n\t\tprint \"valid number\"\n\t\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n        \tcursor = connection.cursor ()\n\t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))\n\t        data = cursor.fetchall()\n\t\tcursor.close()\n\t\tconnection.close()\n\t\tif data:\n\t\t\tprint \"scan ID was found in the db\"\n\t\t\tprint \"data[0][0] is: \" + str(data[0][0])\n\t\t\tif data[0][0] == None:\n\t\t\t\tprint \"EndDate of scan is empty\"\n\t\t\t\tupdate.message.reply_text(\"This scan hasn't finished yet\")\n\t\t\telse:\n\t\t\t\tprint \"Valid scan found\"\n\t\t\t\treply_markup = telegram.ReplyKeyboardRemove()\n\t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)\n\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))\n\t\t\t\treturn ConversationHandler.END\n\t\telse:\n\t\t\tprint \"Scan ID not found in db\"\n\t\t\tupdate.message.reply_text(\"This scan ID doesn't exist\")\n\n\ndef add_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef edit_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef get_topdomains(bot, update):\n\tglobal limit\n\tprint \"Inside get_topdomains\"\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif limit == True:\n\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain limit 20\")\t\n\telse:\n\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\n\n\n        data = cursor.fetchall()\n        cursor.close()\n        connection.close()\n\n        domains_message = \"\"\n\n        if not data:\n                domains_message = \"No domains found\"\n\n        for row in data:\n                domains_message += \"\\n\" + row[0]\n\n\tbot.send_message(chat_id=credentials.telegram_chat_id, text=domains_message, parse_mode=telegram.ParseMode.MARKDOWN)\n        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n                        [InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n        reply_markup = InlineKeyboardMarkup(keyboard)\n\tbot.send_message(chat_id=credentials.telegram_chat_id, text=\"Hi again!\", reply_markup=reply_markup)\n        return BUTTON\n\n\n\ndef get_domains(bot, update):\n\tglobal active\n\tglobal limit\n\tprint \"active: \" + str(active)\n\tprint \"limit: \" + str(limit)\n\tprint \"domain: \" + update.message.text\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (update.message.text,))\n\n\tdata = cursor.fetchall()\n\tcursor.close()\n\tconnection.close()\n\n\tsubdomains_message = \"\"\n\n\tif not data:\n\t\tsubdomains_message = \"No subdomains found for \" + str(update.message.text)\n\n\tif active == True:\n\t\tdata = [x for x in data if ord(x[1]) == True]\n\n\tif limit == True:\n\t\tprint \"Limit is True if\"\n\t\tdata = data[:20]\n\n\tfor row in data:\n\t\tsubdomains_message += \"\\n\" + row[0]\n\n\tupdate.message.reply_text(subdomains_message)\n\n        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n                        [InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        update.message.reply_text(\"Hi again :wave:\", reply_markup=reply_markup)\n\treturn BUTTON\n\n\n\n\n\ndef domains_contain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef help(bot, update):\n\tupdate.message.reply_text(\"click /start to start :)\")\n\n\ndef error(bot, update, error):\n\tlogger.warning('Update \"%s\" caused error \"%s\"', update, error)\n\t\t\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treply_markup = telegram.ReplyKeyboardRemove()\n\tupdate.message.reply_text(\"canceled! Click or type /start to start again\", reply_markup=reply_markup)\n\treturn ConversationHandler.END\n\n\ndef main():\n\t# Create the EventHandler and pass it your bot's token.\n\tupdater = Updater(telegram_bot_token)\n\n\t# Get the dispatcher to register handlers\n\tdp = updater.dispatcher\n\n\t# Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t\tBUTTON: [CallbackQueryHandler(button),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n\t\t\tCUSTOM_SCAN_ID_INPUT: [MessageHandler(Filters.text, custom_scan_id_input),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n                        ADD_DOMAIN: [MessageHandler(Filters.text, add_domain),\n                                           CommandHandler('cancel', cancel)],\n                        EDIT_DOMAIN: [MessageHandler(Filters.text, edit_domain),\n                                           CommandHandler('cancel', cancel)],\n                        GET_DOMAINS: [MessageHandler(Filters.text, get_domains),\n                                           CommandHandler('cancel', cancel)],\n                        CONTAINS: [MessageHandler(Filters.text, domains_contain),\n                                           CommandHandler('cancel', cancel)]\n\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\n\t# log all errors\n\tdp.add_error_handler(error)\n\n\t# Start the Bot\n\tupdater.start_polling()\n\n\t# Run the bot until you press Ctrl-C or the process receives SIGINT,\n\t# SIGTERM or SIGABRT. This should be used most of the time, since\n\t# start_polling() is non-blocking and will stop the bot gracefully.\n\tupdater.idle()\n\n\nif __name__ == '__main__':\n\tmain()\n", "source_code_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport logging, datetime, MySQLdb, os, telegram, sys\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nfrom random import randint\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\nimport credentials\n\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\ntelegram_bot_token = credentials.telegram_bot_token\n\nlogger = logging.getLogger(__name__)\n\nBUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n\ndef start(bot, update):\n\tprint \"---------- Start -----------\"\n\tif str(update.message.chat_id) != str(credentials.telegram_chat_id):\n\t\tupdate.message.reply_text(\"Not authorized! If you think this is a mistake, please check if your chat_id is in credentials.py. You can also run setup.py in /telegram to setup the right credentials for your telegram.\")\n\t\treturn\n\n\tuser = update.message.from_user\n\thour = datetime.datetime.now().hour\n\tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])\n\n\tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n\treply_markup = InlineKeyboardMarkup(keyboard)\n\tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n\tprint \"button before\"\n\treturn BUTTON\n\n\ndef button(bot, update):\n\tquery = update.callback_query\n\t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button\n\tchoice = query.data.split('-')[0]\n\tr = str(randint(0, 99))\n\n\theader_1 = \"Catagory:\"\n\tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + r)]]\n\n\theader_2 = \"Action:\"\n\tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n\t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n\t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n\theader_3 = \"Action:\"\n\tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n\t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n\t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n        header_5 = \"Action:\"\n        keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n                         InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n\t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]\n\n        header_6 = \"Which type of domains?\"\n        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='all-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n\n        header_7 = \"How many domains?\"\n        keyboard_7 = [[InlineKeyboardButton(\"Top 20\", callback_data='limit-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='nolimit-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_data-' + r)]]\n\n\n\t#ToDO: Transform into a swtich\n\tif choice == \"back\":\n\t\tbot.edit_message_text(header_1, reply_markup=InlineKeyboardMarkup(keyboard_1), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"close\":\n\t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn ConversationHandler.END\n\telif choice == \"scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"data\":\n\t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif choice == \"latest\":\n\t\tget_latest_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\telif choice == \"custom\":\n\t\tget_custom_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\t\treturn CUSTOM_SCAN_ID_INPUT\n\telif choice == \"run\":\n\t\trun_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\n        if choice == \"add\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\treturn ADD_DOMAIN\n        elif choice == \"edit\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"What is the domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return EDIT_DOMAIN\n        elif choice == \"get\":\n                cursor.close()\n                connection.close()\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"topdomais\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = False\n\t\treturn BUTTON\n        elif choice == \"subdomains\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = True\n\t\treturn BUTTON\n        elif choice == \"contains\":\n\t\tbot.send_message(text=\"What is the search string?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return CONTAINS\n        elif choice == \"back_data\":\n                bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"back_get\":\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"active\":\n\t\tglobal active\n\t\tactive = True\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n        elif choice == \"all\":\n                global active\n                active = False\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"nolimit\":\n\t\tglobal subdomains\n\t\tif subdomains:\n                        global limit\n                        limit = False\n\t\t\tbot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\treturn GET_DOMAINS\n\t\telse:\n\t\t\tglobal limit\n\t\t\tlimit = False\n\t\t\tget_topdomains()\n        elif choice == \"limit\":\n                global subdomains\n                if subdomains:\n                        global limit\n                        limit = True\n                        bot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                        return GET_DOMAINS\n                else:\n                        global limit\n                        limit = True\n\t\t\tget_topdomains()\n\n\tif choice == \"yes_scan\":\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telif choice == \"back_scan\" or choice == \"no_scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\ndef get_latest_scan(bot, update, cursor):\n\tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))\n\telse:\n\t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\n\ndef get_custom_scan(bot, update, cursor):\n\tquery = update.callback_query\n\n\tcursor.execute (\"SELECT ScanID FROM scans where EndDate is not null ORDER BY ScanID DESC LIMIT 10\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tlatestScanIds = sorted([str(x[0]) for x in data])\n\t\tfirstRow = latestScanIds[:len(latestScanIds)/2]\n\t\tsecondRow = latestScanIds[len(latestScanIds)/2:]\n\t\tcustom_keyboard = [firstRow, secondRow]\n\t\treply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\n\n\t\tif data:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\ttext=\"Which scan ID? \\n/cancel to cancel\",\n\t\t\t\treply_markup=reply_markup, ForceReply = True)\n\t\telse:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\t text=\"Which scan ID? \\n/cancel to cancel\")\n\n\ndef run_scan(bot, update, cursor):\n\tquery = update.callback_query\n\tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")\n\tdata = cursor.fetchall()\n\ttry:\n\t\tif data[0][2] != None:\n\t\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\t\telse:\n\t\t\tr = str(randint(0, 99))\n\t        \theader_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        \t\tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                \t\t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        \t\t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\t\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\t\treturn BUTTON\n\texcept Exception, e:\n\t\tprint \"error: \" + str(e)\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\n\ndef custom_scan_id_input(bot, update):\n\tprint \"inside input method with data: \" + update.message.text\n\tcustomId = update.message.text\n\ttry:\n\t\tint(customId)\n\texcept ValueError:\n\t\tprint \"invalid number\"\n\t\tupdate.message.reply_text(\"Not a valid number\")\n\telse:\n\t\tprint \"valid number\"\n\t\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n        \tcursor = connection.cursor ()\n\t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))\n\t        data = cursor.fetchall()\n\t\tcursor.close()\n\t\tconnection.close()\n\t\tif data:\n\t\t\tprint \"scan ID was found in the db\"\n\t\t\tprint \"data[0][0] is: \" + str(data[0][0])\n\t\t\tif data[0][0] == None:\n\t\t\t\tprint \"EndDate of scan is empty\"\n\t\t\t\tupdate.message.reply_text(\"This scan hasn't finished yet\")\n\t\t\telse:\n\t\t\t\tprint \"Valid scan found\"\n\t\t\t\treply_markup = telegram.ReplyKeyboardRemove()\n\t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)\n\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))\n\t\t\t\treturn ConversationHandler.END\n\t\telse:\n\t\t\tprint \"Scan ID not found in db\"\n\t\t\tupdate.message.reply_text(\"This scan ID doesn't exist\")\n\n\ndef add_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef edit_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef get_domains():\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef domains_contain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef help(bot, update):\n\tupdate.message.reply_text(\"click /start to start :)\")\n\n\ndef error(bot, update, error):\n\tlogger.warning('Update \"%s\" caused error \"%s\"', update, error)\n\t\t\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treply_markup = telegram.ReplyKeyboardRemove()\n\tupdate.message.reply_text(\"canceled! Click or type /start to start again\", reply_markup=reply_markup)\n\treturn ConversationHandler.END\n\n\ndef main():\n\t# Create the EventHandler and pass it your bot's token.\n\tupdater = Updater(telegram_bot_token)\n\n\t# Get the dispatcher to register handlers\n\tdp = updater.dispatcher\n\n\t# Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t\tBUTTON: [CallbackQueryHandler(button),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n\t\t\tCUSTOM_SCAN_ID_INPUT: [MessageHandler(Filters.text, custom_scan_id_input),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n                        ADD_DOMAIN: [MessageHandler(Filters.text, add_domain),\n                                           CommandHandler('cancel', cancel)],\n                        EDIT_DOMAIN: [MessageHandler(Filters.text, edit_domain),\n                                           CommandHandler('cancel', cancel)],\n                        GET_DOMAINS: [MessageHandler(Filters.text, get_domains),\n                                           CommandHandler('cancel', cancel)],\n                        CONTAINS: [MessageHandler(Filters.text, domains_contain),\n                                           CommandHandler('cancel', cancel)]\n\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\n\t# log all errors\n\tdp.add_error_handler(error)\n\n\t# Start the Bot\n\tupdater.start_polling()\n\n\t# Run the bot until you press Ctrl-C or the process receives SIGINT,\n\t# SIGTERM or SIGABRT. This should be used most of the time, since\n\t# start_polling() is non-blocking and will stop the bot gracefully.\n\tupdater.idle()\n\n\nif __name__ == '__main__':\n\tmain()\n", "methods": [{"name": "start", "start_line": 22, "end_line": 39}, {"name": "button", "start_line": 42, "end_line": 202}, {"name": "get_latest_scan", "start_line": 205, "end_line": 211}, {"name": "get_custom_scan", "start_line": 214, "end_line": 232}, {"name": "run_scan", "start_line": 235, "end_line": 254}, {"name": "custom_scan_id_input", "start_line": 257, "end_line": 287}, {"name": "add_domain", "start_line": 290, "end_line": 292}, {"name": "edit_domain", "start_line": 295, "end_line": 297}, {"name": "get_topdomains", "start_line": 300, "end_line": 332}, {"name": "get_domains", "start_line": 336, "end_line": 375}, {"name": "domains_contain", "start_line": 381, "end_line": 383}, {"name": "help", "start_line": 386, "end_line": 387}, {"name": "error", "start_line": 390, "end_line": 391}, {"name": "cancel", "start_line": 394, "end_line": 398}, {"name": "main", "start_line": 401, "end_line": 442}], "methods_before": [{"name": "start", "start_line": 22, "end_line": 39}, {"name": "button", "start_line": 42, "end_line": 193}, {"name": "get_latest_scan", "start_line": 196, "end_line": 202}, {"name": "get_custom_scan", "start_line": 205, "end_line": 223}, {"name": "run_scan", "start_line": 226, "end_line": 245}, {"name": "custom_scan_id_input", "start_line": 248, "end_line": 278}, {"name": "add_domain", "start_line": 281, "end_line": 283}, {"name": "edit_domain", "start_line": 286, "end_line": 288}, {"name": "get_domains", "start_line": 291, "end_line": 293}, {"name": "domains_contain", "start_line": 296, "end_line": 298}, {"name": "help", "start_line": 301, "end_line": 302}, {"name": "error", "start_line": 305, "end_line": 306}, {"name": "cancel", "start_line": 309, "end_line": 313}, {"name": "main", "start_line": 316, "end_line": 357}], "changed_methods": [{"name": "get_domains", "start_line": 336, "end_line": 375}, {"name": "button", "start_line": 42, "end_line": 202}, {"name": "run_scan", "start_line": 235, "end_line": 254}, {"name": "start", "start_line": 22, "end_line": 39}, {"name": "get_domains", "start_line": 291, "end_line": 293}, {"name": "get_topdomains", "start_line": 300, "end_line": 332}], "nloc": 337, "complexity": 60, "token_count": 2966}], "dmm_unit_size": 0.0, "dmm_unit_complexity": 0.38181818181818183, "dmm_unit_interfacing": 1.0},
    {"hash": "871107fca5800ce8ff84433302b1c0389db91865", "msg": "Update bot.py", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-15 13:07:45+02:00", "author_timezone": -7200, "committer_date": "2018-06-15 13:07:45+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["53ff349f67588a5e54bdfc359c7ae4538bd9a50c"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 3, "insertions": 3, "lines": 6, "files": 1, "modified_files": [{"old_path": "telegram/bot.py", "new_path": "telegram/bot.py", "filename": "bot.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -48,7 +48,7 @@ def button(bot, update):\n \theader_1 = \"Catagory:\"\n \tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n \t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n-\t\t\t[InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + r)]]\n+\t\t\t[InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + r)]]\n \n \theader_2 = \"Action:\"\n \tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n@@ -325,7 +325,7 @@ def get_topdomains(bot, update):\n \tbot.send_message(chat_id=credentials.telegram_chat_id, text=domains_message, parse_mode=telegram.ParseMode.MARKDOWN)\n         keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                          InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n-                        [InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]\n+                        [InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]\n \n         reply_markup = InlineKeyboardMarkup(keyboard)\n \tbot.send_message(chat_id=credentials.telegram_chat_id, text=\"Hi again!\", reply_markup=reply_markup)\n@@ -368,7 +368,7 @@ def get_domains(bot, update):\n \n         keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                          InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n-                        [InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]\n+                        [InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + str(randint(0, 999)))]]\n \n         reply_markup = InlineKeyboardMarkup(keyboard)\n         update.message.reply_text(\"Hi again :wave:\", reply_markup=reply_markup)\n", "diff_parsed": {"added": [[51, "\t\t\t[InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + r)]]"], [328, "                        [InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]"], [371, "                        [InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + str(randint(0, 999)))]]"]], "deleted": [[51, "\t\t\t[InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + r)]]"], [328, "                        [InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]"], [371, "                        [InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]"]]}, "added_lines": 3, "deleted_lines": 3, "source_code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport logging, datetime, MySQLdb, os, telegram, sys\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nfrom random import randint\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\nimport credentials\n\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\ntelegram_bot_token = credentials.telegram_bot_token\n\nlogger = logging.getLogger(__name__)\n\nBUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n\ndef start(bot, update):\n\tprint \"---------- Start -----------\"\n\tif str(update.message.chat_id) != str(credentials.telegram_chat_id):\n\t\tupdate.message.reply_text(\"Not authorized! If you think this is a mistake, please check if your chat_id is in credentials.py. You can also run setup.py in /telegram to setup the right credentials for your telegram.\")\n\t\treturn\n\n\tuser = update.message.from_user\n\thour = datetime.datetime.now().hour\n\tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])\n\n\tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n\t\t\t[InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n\treply_markup = InlineKeyboardMarkup(keyboard)\n\tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n\tprint \"button before\"\n\treturn BUTTON\n\n\ndef button(bot, update):\n\tquery = update.callback_query\n\t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button\n\tchoice = query.data.split('-')[0]\n\tr = str(randint(0, 99))\n\n\theader_1 = \"Catagory:\"\n\tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + r)]]\n\n\theader_2 = \"Action:\"\n\tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n\t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n\t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n\theader_3 = \"Action:\"\n\tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n\t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n\t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        [InlineKeyboardButton(\"\u00c2\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n        header_5 = \"Action:\"\n        keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n                         InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n\t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n                        [InlineKeyboardButton(\"\u00c2\u00ab Back to data\", callback_data='back_data-' + r)]]\n\n        header_6 = \"Which type of domains?\"\n        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='all-' + r)],\n                        [InlineKeyboardButton(\"\u00c2\u00ab Back to actions\", callback_data='back_get-' + r)]]\n\n        header_7 = \"How many domains?\"\n        keyboard_7 = [[InlineKeyboardButton(\"Top 20\", callback_data='limit-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='nolimit-' + r)],\n                        [InlineKeyboardButton(\"\u00c2\u00ab Back to actions\", callback_data='back_data-' + r)]]\n\n\n\t#ToDO: Transform into a swtich\n\tif choice == \"back\":\n\t\tbot.edit_message_text(header_1, reply_markup=InlineKeyboardMarkup(keyboard_1), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"close\":\n\t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn ConversationHandler.END\n\telif choice == \"scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"data\":\n\t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif choice == \"latest\":\n\t\tget_latest_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\telif choice == \"custom\":\n\t\tget_custom_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\t\treturn CUSTOM_SCAN_ID_INPUT\n\telif choice == \"run\":\n\t\trun_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\n        if choice == \"add\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"Coming soon, pr's are welcome...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\treturn BUTTON\n\t\t#return ADD_DOMAIN\n        elif choice == \"edit\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return BUTTON\n\t\t#return EDIT_DOMAIN\n        elif choice == \"get\":\n                cursor.close()\n                connection.close()\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"topdomains\":\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = False\n\t\tprint \"choice = topdomains\"\n\t\treturn BUTTON\n        elif choice == \"subdomains\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = True\n\t\treturn BUTTON\n        elif choice == \"contains\":\n\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return BUTTON\n\t\t#return CONTAINS\n        elif choice == \"back_data\":\n                bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"back_get\":\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"active\":\n\t\tglobal active\n\t\tactive = True\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n        elif choice == \"all\":\n                global active\n                active = False\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"nolimit\":\n\t\tprint \"Nolimit\"\n\t\tglobal subdomains\n\t\tif subdomains:\n                        global limit\n                        limit = False\n\t\t\tbot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\treturn GET_DOMAINS\n\t\telse:\n\t\t\tprint \"topdomain\"\n\t\t\tglobal limit\n\t\t\tlimit = False\n\t\t\tget_topdomains(bot, update)\n\n        elif choice == \"limit\":\n                global subdomains\n\t\tprint \"Limit\"\n                if subdomains:\n                        global limit\n                        limit = True\n                        bot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                        return GET_DOMAINS\n                else:\n\t\t\tprint \"Topdomain\"\n                        global limit\n                        limit = True\n\t\t\tget_topdomains(bot, update)\n\n\tif choice == \"yes_scan\":\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telif choice == \"back_scan\" or choice == \"no_scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\ndef get_latest_scan(bot, update, cursor):\n\tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))\n\telse:\n\t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\n\ndef get_custom_scan(bot, update, cursor):\n\tquery = update.callback_query\n\n\tcursor.execute (\"SELECT ScanID FROM scans where EndDate is not null ORDER BY ScanID DESC LIMIT 10\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tlatestScanIds = sorted([str(x[0]) for x in data])\n\t\tfirstRow = latestScanIds[:len(latestScanIds)/2]\n\t\tsecondRow = latestScanIds[len(latestScanIds)/2:]\n\t\tcustom_keyboard = [firstRow, secondRow]\n\t\treply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\n\n\t\tif data:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\ttext=\"Which scan ID? \\n/cancel to cancel\",\n\t\t\t\treply_markup=reply_markup, ForceReply = True)\n\t\telse:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\t text=\"Which scan ID? \\n/cancel to cancel\")\n\n\ndef run_scan(bot, update, cursor):\n\tquery = update.callback_query\n\tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")\n\tdata = cursor.fetchall()\n\ttry:\n\t\tif data[0][2] != None:\n\t\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\t\telse:\n\t\t\tr = str(randint(0, 99))\n\t        \theader_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        \t\tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                \t\t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        \t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\t\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\t\treturn BUTTON\n\texcept Exception, e:\n\t\tprint \"error: \" + str(e)\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\n\ndef custom_scan_id_input(bot, update):\n\tprint \"inside input method with data: \" + update.message.text\n\tcustomId = update.message.text\n\ttry:\n\t\tint(customId)\n\texcept ValueError:\n\t\tprint \"invalid number\"\n\t\tupdate.message.reply_text(\"Not a valid number\")\n\telse:\n\t\tprint \"valid number\"\n\t\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n        \tcursor = connection.cursor ()\n\t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))\n\t        data = cursor.fetchall()\n\t\tcursor.close()\n\t\tconnection.close()\n\t\tif data:\n\t\t\tprint \"scan ID was found in the db\"\n\t\t\tprint \"data[0][0] is: \" + str(data[0][0])\n\t\t\tif data[0][0] == None:\n\t\t\t\tprint \"EndDate of scan is empty\"\n\t\t\t\tupdate.message.reply_text(\"This scan hasn't finished yet\")\n\t\t\telse:\n\t\t\t\tprint \"Valid scan found\"\n\t\t\t\treply_markup = telegram.ReplyKeyboardRemove()\n\t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)\n\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))\n\t\t\t\treturn ConversationHandler.END\n\t\telse:\n\t\t\tprint \"Scan ID not found in db\"\n\t\t\tupdate.message.reply_text(\"This scan ID doesn't exist\")\n\n\ndef add_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef edit_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef get_topdomains(bot, update):\n\tglobal limit\n\tprint \"Inside get_topdomains\"\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif limit == True:\n\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain limit 20\")\t\n\telse:\n\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\n\n\n        data = cursor.fetchall()\n        cursor.close()\n        connection.close()\n\n        domains_message = \"\"\n\n        if not data:\n                domains_message = \"No domains found\"\n\n        for row in data:\n                domains_message += \"\\n\" + row[0]\n\n\tbot.send_message(chat_id=credentials.telegram_chat_id, text=domains_message, parse_mode=telegram.ParseMode.MARKDOWN)\n        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n                        [InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n        reply_markup = InlineKeyboardMarkup(keyboard)\n\tbot.send_message(chat_id=credentials.telegram_chat_id, text=\"Hi again!\", reply_markup=reply_markup)\n        return BUTTON\n\n\n\ndef get_domains(bot, update):\n\tglobal active\n\tglobal limit\n\tprint \"active: \" + str(active)\n\tprint \"limit: \" + str(limit)\n\tprint \"domain: \" + update.message.text\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (update.message.text,))\n\n\tdata = cursor.fetchall()\n\tcursor.close()\n\tconnection.close()\n\n\tsubdomains_message = \"\"\n\n\tif not data:\n\t\tsubdomains_message = \"No subdomains found for \" + str(update.message.text)\n\n\tif active == True:\n\t\tdata = [x for x in data if ord(x[1]) == True]\n\n\tif limit == True:\n\t\tprint \"Limit is True if\"\n\t\tdata = data[:20]\n\n\tfor row in data:\n\t\tsubdomains_message += \"\\n\" + row[0]\n\n\tupdate.message.reply_text(subdomains_message)\n\n        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n                        [InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        update.message.reply_text(\"Hi again :wave:\", reply_markup=reply_markup)\n\treturn BUTTON\n\n\n\n\n\ndef domains_contain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef help(bot, update):\n\tupdate.message.reply_text(\"click /start to start :)\")\n\n\ndef error(bot, update, error):\n\tlogger.warning('Update \"%s\" caused error \"%s\"', update, error)\n\t\t\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treply_markup = telegram.ReplyKeyboardRemove()\n\tupdate.message.reply_text(\"canceled! Click or type /start to start again\", reply_markup=reply_markup)\n\treturn ConversationHandler.END\n\n\ndef main():\n\t# Create the EventHandler and pass it your bot's token.\n\tupdater = Updater(telegram_bot_token)\n\n\t# Get the dispatcher to register handlers\n\tdp = updater.dispatcher\n\n\t# Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t\tBUTTON: [CallbackQueryHandler(button),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n\t\t\tCUSTOM_SCAN_ID_INPUT: [MessageHandler(Filters.text, custom_scan_id_input),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n                        ADD_DOMAIN: [MessageHandler(Filters.text, add_domain),\n                                           CommandHandler('cancel', cancel)],\n                        EDIT_DOMAIN: [MessageHandler(Filters.text, edit_domain),\n                                           CommandHandler('cancel', cancel)],\n                        GET_DOMAINS: [MessageHandler(Filters.text, get_domains),\n                                           CommandHandler('cancel', cancel)],\n                        CONTAINS: [MessageHandler(Filters.text, domains_contain),\n                                           CommandHandler('cancel', cancel)]\n\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\n\t# log all errors\n\tdp.add_error_handler(error)\n\n\t# Start the Bot\n\tupdater.start_polling()\n\n\t# Run the bot until you press Ctrl-C or the process receives SIGINT,\n\t# SIGTERM or SIGABRT. This should be used most of the time, since\n\t# start_polling() is non-blocking and will stop the bot gracefully.\n\tupdater.idle()\n\n\nif __name__ == '__main__':\n\tmain()\n", "source_code_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport logging, datetime, MySQLdb, os, telegram, sys\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nfrom random import randint\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\nimport credentials\n\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\ntelegram_bot_token = credentials.telegram_bot_token\n\nlogger = logging.getLogger(__name__)\n\nBUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n\ndef start(bot, update):\n\tprint \"---------- Start -----------\"\n\tif str(update.message.chat_id) != str(credentials.telegram_chat_id):\n\t\tupdate.message.reply_text(\"Not authorized! If you think this is a mistake, please check if your chat_id is in credentials.py. You can also run setup.py in /telegram to setup the right credentials for your telegram.\")\n\t\treturn\n\n\tuser = update.message.from_user\n\thour = datetime.datetime.now().hour\n\tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])\n\n\tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n\t\t\t[InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n\treply_markup = InlineKeyboardMarkup(keyboard)\n\tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n\tprint \"button before\"\n\treturn BUTTON\n\n\ndef button(bot, update):\n\tquery = update.callback_query\n\t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button\n\tchoice = query.data.split('-')[0]\n\tr = str(randint(0, 99))\n\n\theader_1 = \"Catagory:\"\n\tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + r)]]\n\n\theader_2 = \"Action:\"\n\tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n\t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n\t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n\theader_3 = \"Action:\"\n\tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n\t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n\t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        [InlineKeyboardButton(\"\u00c2\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n        header_5 = \"Action:\"\n        keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n                         InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n\t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n                        [InlineKeyboardButton(\"\u00c2\u00ab Back to data\", callback_data='back_data-' + r)]]\n\n        header_6 = \"Which type of domains?\"\n        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='all-' + r)],\n                        [InlineKeyboardButton(\"\u00c2\u00ab Back to actions\", callback_data='back_get-' + r)]]\n\n        header_7 = \"How many domains?\"\n        keyboard_7 = [[InlineKeyboardButton(\"Top 20\", callback_data='limit-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='nolimit-' + r)],\n                        [InlineKeyboardButton(\"\u00c2\u00ab Back to actions\", callback_data='back_data-' + r)]]\n\n\n\t#ToDO: Transform into a swtich\n\tif choice == \"back\":\n\t\tbot.edit_message_text(header_1, reply_markup=InlineKeyboardMarkup(keyboard_1), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"close\":\n\t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn ConversationHandler.END\n\telif choice == \"scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"data\":\n\t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif choice == \"latest\":\n\t\tget_latest_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\telif choice == \"custom\":\n\t\tget_custom_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\t\treturn CUSTOM_SCAN_ID_INPUT\n\telif choice == \"run\":\n\t\trun_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\n        if choice == \"add\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"Coming soon, pr's are welcome...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\treturn BUTTON\n\t\t#return ADD_DOMAIN\n        elif choice == \"edit\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return BUTTON\n\t\t#return EDIT_DOMAIN\n        elif choice == \"get\":\n                cursor.close()\n                connection.close()\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"topdomains\":\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = False\n\t\tprint \"choice = topdomains\"\n\t\treturn BUTTON\n        elif choice == \"subdomains\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = True\n\t\treturn BUTTON\n        elif choice == \"contains\":\n\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return BUTTON\n\t\t#return CONTAINS\n        elif choice == \"back_data\":\n                bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"back_get\":\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"active\":\n\t\tglobal active\n\t\tactive = True\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n        elif choice == \"all\":\n                global active\n                active = False\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"nolimit\":\n\t\tprint \"Nolimit\"\n\t\tglobal subdomains\n\t\tif subdomains:\n                        global limit\n                        limit = False\n\t\t\tbot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\treturn GET_DOMAINS\n\t\telse:\n\t\t\tprint \"topdomain\"\n\t\t\tglobal limit\n\t\t\tlimit = False\n\t\t\tget_topdomains(bot, update)\n\n        elif choice == \"limit\":\n                global subdomains\n\t\tprint \"Limit\"\n                if subdomains:\n                        global limit\n                        limit = True\n                        bot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                        return GET_DOMAINS\n                else:\n\t\t\tprint \"Topdomain\"\n                        global limit\n                        limit = True\n\t\t\tget_topdomains(bot, update)\n\n\tif choice == \"yes_scan\":\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telif choice == \"back_scan\" or choice == \"no_scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\ndef get_latest_scan(bot, update, cursor):\n\tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))\n\telse:\n\t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\n\ndef get_custom_scan(bot, update, cursor):\n\tquery = update.callback_query\n\n\tcursor.execute (\"SELECT ScanID FROM scans where EndDate is not null ORDER BY ScanID DESC LIMIT 10\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tlatestScanIds = sorted([str(x[0]) for x in data])\n\t\tfirstRow = latestScanIds[:len(latestScanIds)/2]\n\t\tsecondRow = latestScanIds[len(latestScanIds)/2:]\n\t\tcustom_keyboard = [firstRow, secondRow]\n\t\treply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\n\n\t\tif data:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\ttext=\"Which scan ID? \\n/cancel to cancel\",\n\t\t\t\treply_markup=reply_markup, ForceReply = True)\n\t\telse:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\t text=\"Which scan ID? \\n/cancel to cancel\")\n\n\ndef run_scan(bot, update, cursor):\n\tquery = update.callback_query\n\tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")\n\tdata = cursor.fetchall()\n\ttry:\n\t\tif data[0][2] != None:\n\t\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\t\telse:\n\t\t\tr = str(randint(0, 99))\n\t        \theader_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        \t\tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                \t\t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        \t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\t\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\t\treturn BUTTON\n\texcept Exception, e:\n\t\tprint \"error: \" + str(e)\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\n\ndef custom_scan_id_input(bot, update):\n\tprint \"inside input method with data: \" + update.message.text\n\tcustomId = update.message.text\n\ttry:\n\t\tint(customId)\n\texcept ValueError:\n\t\tprint \"invalid number\"\n\t\tupdate.message.reply_text(\"Not a valid number\")\n\telse:\n\t\tprint \"valid number\"\n\t\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n        \tcursor = connection.cursor ()\n\t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))\n\t        data = cursor.fetchall()\n\t\tcursor.close()\n\t\tconnection.close()\n\t\tif data:\n\t\t\tprint \"scan ID was found in the db\"\n\t\t\tprint \"data[0][0] is: \" + str(data[0][0])\n\t\t\tif data[0][0] == None:\n\t\t\t\tprint \"EndDate of scan is empty\"\n\t\t\t\tupdate.message.reply_text(\"This scan hasn't finished yet\")\n\t\t\telse:\n\t\t\t\tprint \"Valid scan found\"\n\t\t\t\treply_markup = telegram.ReplyKeyboardRemove()\n\t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)\n\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))\n\t\t\t\treturn ConversationHandler.END\n\t\telse:\n\t\t\tprint \"Scan ID not found in db\"\n\t\t\tupdate.message.reply_text(\"This scan ID doesn't exist\")\n\n\ndef add_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef edit_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef get_topdomains(bot, update):\n\tglobal limit\n\tprint \"Inside get_topdomains\"\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif limit == True:\n\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain limit 20\")\t\n\telse:\n\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\n\n\n        data = cursor.fetchall()\n        cursor.close()\n        connection.close()\n\n        domains_message = \"\"\n\n        if not data:\n                domains_message = \"No domains found\"\n\n        for row in data:\n                domains_message += \"\\n\" + row[0]\n\n\tbot.send_message(chat_id=credentials.telegram_chat_id, text=domains_message, parse_mode=telegram.ParseMode.MARKDOWN)\n        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n                        [InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n        reply_markup = InlineKeyboardMarkup(keyboard)\n\tbot.send_message(chat_id=credentials.telegram_chat_id, text=\"Hi again!\", reply_markup=reply_markup)\n        return BUTTON\n\n\n\ndef get_domains(bot, update):\n\tglobal active\n\tglobal limit\n\tprint \"active: \" + str(active)\n\tprint \"limit: \" + str(limit)\n\tprint \"domain: \" + update.message.text\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (update.message.text,))\n\n\tdata = cursor.fetchall()\n\tcursor.close()\n\tconnection.close()\n\n\tsubdomains_message = \"\"\n\n\tif not data:\n\t\tsubdomains_message = \"No subdomains found for \" + str(update.message.text)\n\n\tif active == True:\n\t\tdata = [x for x in data if ord(x[1]) == True]\n\n\tif limit == True:\n\t\tprint \"Limit is True if\"\n\t\tdata = data[:20]\n\n\tfor row in data:\n\t\tsubdomains_message += \"\\n\" + row[0]\n\n\tupdate.message.reply_text(subdomains_message)\n\n        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n                        [InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        update.message.reply_text(\"Hi again :wave:\", reply_markup=reply_markup)\n\treturn BUTTON\n\n\n\n\n\ndef domains_contain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef help(bot, update):\n\tupdate.message.reply_text(\"click /start to start :)\")\n\n\ndef error(bot, update, error):\n\tlogger.warning('Update \"%s\" caused error \"%s\"', update, error)\n\t\t\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treply_markup = telegram.ReplyKeyboardRemove()\n\tupdate.message.reply_text(\"canceled! Click or type /start to start again\", reply_markup=reply_markup)\n\treturn ConversationHandler.END\n\n\ndef main():\n\t# Create the EventHandler and pass it your bot's token.\n\tupdater = Updater(telegram_bot_token)\n\n\t# Get the dispatcher to register handlers\n\tdp = updater.dispatcher\n\n\t# Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t\tBUTTON: [CallbackQueryHandler(button),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n\t\t\tCUSTOM_SCAN_ID_INPUT: [MessageHandler(Filters.text, custom_scan_id_input),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n                        ADD_DOMAIN: [MessageHandler(Filters.text, add_domain),\n                                           CommandHandler('cancel', cancel)],\n                        EDIT_DOMAIN: [MessageHandler(Filters.text, edit_domain),\n                                           CommandHandler('cancel', cancel)],\n                        GET_DOMAINS: [MessageHandler(Filters.text, get_domains),\n                                           CommandHandler('cancel', cancel)],\n                        CONTAINS: [MessageHandler(Filters.text, domains_contain),\n                                           CommandHandler('cancel', cancel)]\n\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\n\t# log all errors\n\tdp.add_error_handler(error)\n\n\t# Start the Bot\n\tupdater.start_polling()\n\n\t# Run the bot until you press Ctrl-C or the process receives SIGINT,\n\t# SIGTERM or SIGABRT. This should be used most of the time, since\n\t# start_polling() is non-blocking and will stop the bot gracefully.\n\tupdater.idle()\n\n\nif __name__ == '__main__':\n\tmain()\n", "methods": [{"name": "start", "start_line": 22, "end_line": 39}, {"name": "button", "start_line": 42, "end_line": 202}, {"name": "get_latest_scan", "start_line": 205, "end_line": 211}, {"name": "get_custom_scan", "start_line": 214, "end_line": 232}, {"name": "run_scan", "start_line": 235, "end_line": 254}, {"name": "custom_scan_id_input", "start_line": 257, "end_line": 287}, {"name": "add_domain", "start_line": 290, "end_line": 292}, {"name": "edit_domain", "start_line": 295, "end_line": 297}, {"name": "get_topdomains", "start_line": 300, "end_line": 332}, {"name": "get_domains", "start_line": 336, "end_line": 375}, {"name": "domains_contain", "start_line": 381, "end_line": 383}, {"name": "help", "start_line": 386, "end_line": 387}, {"name": "error", "start_line": 390, "end_line": 391}, {"name": "cancel", "start_line": 394, "end_line": 398}, {"name": "main", "start_line": 401, "end_line": 442}], "methods_before": [{"name": "start", "start_line": 22, "end_line": 39}, {"name": "button", "start_line": 42, "end_line": 202}, {"name": "get_latest_scan", "start_line": 205, "end_line": 211}, {"name": "get_custom_scan", "start_line": 214, "end_line": 232}, {"name": "run_scan", "start_line": 235, "end_line": 254}, {"name": "custom_scan_id_input", "start_line": 257, "end_line": 287}, {"name": "add_domain", "start_line": 290, "end_line": 292}, {"name": "edit_domain", "start_line": 295, "end_line": 297}, {"name": "get_topdomains", "start_line": 300, "end_line": 332}, {"name": "get_domains", "start_line": 336, "end_line": 375}, {"name": "domains_contain", "start_line": 381, "end_line": 383}, {"name": "help", "start_line": 386, "end_line": 387}, {"name": "error", "start_line": 390, "end_line": 391}, {"name": "cancel", "start_line": 394, "end_line": 398}, {"name": "main", "start_line": 401, "end_line": 442}], "changed_methods": [{"name": "get_domains", "start_line": 336, "end_line": 375}, {"name": "button", "start_line": 42, "end_line": 202}, {"name": "get_topdomains", "start_line": 300, "end_line": 332}], "nloc": 337, "complexity": 60, "token_count": 2966}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "89d815f48ecb494b30d5b94073d880c8ff8388fb", "msg": "Update bot.py", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-15 13:09:26+02:00", "author_timezone": -7200, "committer_date": "2018-06-15 13:09:26+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["871107fca5800ce8ff84433302b1c0389db91865"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 7, "insertions": 7, "lines": 14, "files": 1, "modified_files": [{"old_path": "telegram/bot.py", "new_path": "telegram/bot.py", "filename": "bot.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -54,34 +54,34 @@ def button(bot, update):\n \tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n \t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n \t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n-\t\t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to catagories\", callback_data='back-' + r)]]\n+\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n \n \theader_3 = \"Action:\"\n \tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n \t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n \t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n-\t\t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to catagories\", callback_data='back-' + r)]]\n+\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n \n         header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n         keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                          InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n-                        [InlineKeyboardButton(\"\u00c2\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n+                        [InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n \n         header_5 = \"Action:\"\n         keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n                          InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n \t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n-                        [InlineKeyboardButton(\"\u00c2\u00ab Back to data\", callback_data='back_data-' + r)]]\n+                        [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]\n \n         header_6 = \"Which type of domains?\"\n         keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active-' + r),\n                          InlineKeyboardButton(\"All\", callback_data='all-' + r)],\n-                        [InlineKeyboardButton(\"\u00c2\u00ab Back to actions\", callback_data='back_get-' + r)]]\n+                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n \n         header_7 = \"How many domains?\"\n         keyboard_7 = [[InlineKeyboardButton(\"Top 20\", callback_data='limit-' + r),\n                          InlineKeyboardButton(\"All\", callback_data='nolimit-' + r)],\n-                        [InlineKeyboardButton(\"\u00c2\u00ab Back to actions\", callback_data='back_data-' + r)]]\n+                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_data-' + r)]]\n \n \n \t#ToDO: Transform into a swtich\n@@ -245,7 +245,7 @@ def run_scan(bot, update, cursor):\n \t        \theader_4 = \"It looks like a scan is already running. Want to start a new one?\"\n         \t\tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                 \t\t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n-                        \t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n+                        \t\t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n \t\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n \t\t\treturn BUTTON\n \texcept Exception, e:\n", "diff_parsed": {"added": [[57, "\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]"], [63, "\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]"], [68, "                        [InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]"], [74, "                        [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]"], [79, "                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]"], [84, "                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_data-' + r)]]"], [248, "                        \t\t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]"]], "deleted": [[57, "\t\t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to catagories\", callback_data='back-' + r)]]"], [63, "\t\t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to catagories\", callback_data='back-' + r)]]"], [68, "                        [InlineKeyboardButton(\"\u00c2\u00ab Back to scans\", callback_data='back_scan-' + r)]]"], [74, "                        [InlineKeyboardButton(\"\u00c2\u00ab Back to data\", callback_data='back_data-' + r)]]"], [79, "                        [InlineKeyboardButton(\"\u00c2\u00ab Back to actions\", callback_data='back_get-' + r)]]"], [84, "                        [InlineKeyboardButton(\"\u00c2\u00ab Back to actions\", callback_data='back_data-' + r)]]"], [248, "                        \t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to scans\", callback_data='back_scan-' + r)]]"]]}, "added_lines": 7, "deleted_lines": 7, "source_code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport logging, datetime, MySQLdb, os, telegram, sys\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nfrom random import randint\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\nimport credentials\n\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\ntelegram_bot_token = credentials.telegram_bot_token\n\nlogger = logging.getLogger(__name__)\n\nBUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n\ndef start(bot, update):\n\tprint \"---------- Start -----------\"\n\tif str(update.message.chat_id) != str(credentials.telegram_chat_id):\n\t\tupdate.message.reply_text(\"Not authorized! If you think this is a mistake, please check if your chat_id is in credentials.py. You can also run setup.py in /telegram to setup the right credentials for your telegram.\")\n\t\treturn\n\n\tuser = update.message.from_user\n\thour = datetime.datetime.now().hour\n\tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])\n\n\tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n\t\t\t[InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n\treply_markup = InlineKeyboardMarkup(keyboard)\n\tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n\tprint \"button before\"\n\treturn BUTTON\n\n\ndef button(bot, update):\n\tquery = update.callback_query\n\t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button\n\tchoice = query.data.split('-')[0]\n\tr = str(randint(0, 99))\n\n\theader_1 = \"Catagory:\"\n\tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + r)]]\n\n\theader_2 = \"Action:\"\n\tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n\t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n\t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n\theader_3 = \"Action:\"\n\tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n\t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n\t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n        header_5 = \"Action:\"\n        keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n                         InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n\t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]\n\n        header_6 = \"Which type of domains?\"\n        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='all-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n\n        header_7 = \"How many domains?\"\n        keyboard_7 = [[InlineKeyboardButton(\"Top 20\", callback_data='limit-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='nolimit-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_data-' + r)]]\n\n\n\t#ToDO: Transform into a swtich\n\tif choice == \"back\":\n\t\tbot.edit_message_text(header_1, reply_markup=InlineKeyboardMarkup(keyboard_1), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"close\":\n\t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn ConversationHandler.END\n\telif choice == \"scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"data\":\n\t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif choice == \"latest\":\n\t\tget_latest_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\telif choice == \"custom\":\n\t\tget_custom_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\t\treturn CUSTOM_SCAN_ID_INPUT\n\telif choice == \"run\":\n\t\trun_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\n        if choice == \"add\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"Coming soon, pr's are welcome...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\treturn BUTTON\n\t\t#return ADD_DOMAIN\n        elif choice == \"edit\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return BUTTON\n\t\t#return EDIT_DOMAIN\n        elif choice == \"get\":\n                cursor.close()\n                connection.close()\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"topdomains\":\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = False\n\t\tprint \"choice = topdomains\"\n\t\treturn BUTTON\n        elif choice == \"subdomains\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = True\n\t\treturn BUTTON\n        elif choice == \"contains\":\n\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return BUTTON\n\t\t#return CONTAINS\n        elif choice == \"back_data\":\n                bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"back_get\":\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"active\":\n\t\tglobal active\n\t\tactive = True\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n        elif choice == \"all\":\n                global active\n                active = False\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"nolimit\":\n\t\tprint \"Nolimit\"\n\t\tglobal subdomains\n\t\tif subdomains:\n                        global limit\n                        limit = False\n\t\t\tbot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\treturn GET_DOMAINS\n\t\telse:\n\t\t\tprint \"topdomain\"\n\t\t\tglobal limit\n\t\t\tlimit = False\n\t\t\tget_topdomains(bot, update)\n\n        elif choice == \"limit\":\n                global subdomains\n\t\tprint \"Limit\"\n                if subdomains:\n                        global limit\n                        limit = True\n                        bot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                        return GET_DOMAINS\n                else:\n\t\t\tprint \"Topdomain\"\n                        global limit\n                        limit = True\n\t\t\tget_topdomains(bot, update)\n\n\tif choice == \"yes_scan\":\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telif choice == \"back_scan\" or choice == \"no_scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\ndef get_latest_scan(bot, update, cursor):\n\tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))\n\telse:\n\t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\n\ndef get_custom_scan(bot, update, cursor):\n\tquery = update.callback_query\n\n\tcursor.execute (\"SELECT ScanID FROM scans where EndDate is not null ORDER BY ScanID DESC LIMIT 10\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tlatestScanIds = sorted([str(x[0]) for x in data])\n\t\tfirstRow = latestScanIds[:len(latestScanIds)/2]\n\t\tsecondRow = latestScanIds[len(latestScanIds)/2:]\n\t\tcustom_keyboard = [firstRow, secondRow]\n\t\treply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\n\n\t\tif data:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\ttext=\"Which scan ID? \\n/cancel to cancel\",\n\t\t\t\treply_markup=reply_markup, ForceReply = True)\n\t\telse:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\t text=\"Which scan ID? \\n/cancel to cancel\")\n\n\ndef run_scan(bot, update, cursor):\n\tquery = update.callback_query\n\tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")\n\tdata = cursor.fetchall()\n\ttry:\n\t\tif data[0][2] != None:\n\t\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\t\telse:\n\t\t\tr = str(randint(0, 99))\n\t        \theader_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        \t\tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                \t\t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        \t\t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\t\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\t\treturn BUTTON\n\texcept Exception, e:\n\t\tprint \"error: \" + str(e)\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\n\ndef custom_scan_id_input(bot, update):\n\tprint \"inside input method with data: \" + update.message.text\n\tcustomId = update.message.text\n\ttry:\n\t\tint(customId)\n\texcept ValueError:\n\t\tprint \"invalid number\"\n\t\tupdate.message.reply_text(\"Not a valid number\")\n\telse:\n\t\tprint \"valid number\"\n\t\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n        \tcursor = connection.cursor ()\n\t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))\n\t        data = cursor.fetchall()\n\t\tcursor.close()\n\t\tconnection.close()\n\t\tif data:\n\t\t\tprint \"scan ID was found in the db\"\n\t\t\tprint \"data[0][0] is: \" + str(data[0][0])\n\t\t\tif data[0][0] == None:\n\t\t\t\tprint \"EndDate of scan is empty\"\n\t\t\t\tupdate.message.reply_text(\"This scan hasn't finished yet\")\n\t\t\telse:\n\t\t\t\tprint \"Valid scan found\"\n\t\t\t\treply_markup = telegram.ReplyKeyboardRemove()\n\t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)\n\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))\n\t\t\t\treturn ConversationHandler.END\n\t\telse:\n\t\t\tprint \"Scan ID not found in db\"\n\t\t\tupdate.message.reply_text(\"This scan ID doesn't exist\")\n\n\ndef add_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef edit_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef get_topdomains(bot, update):\n\tglobal limit\n\tprint \"Inside get_topdomains\"\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif limit == True:\n\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain limit 20\")\t\n\telse:\n\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\n\n\n        data = cursor.fetchall()\n        cursor.close()\n        connection.close()\n\n        domains_message = \"\"\n\n        if not data:\n                domains_message = \"No domains found\"\n\n        for row in data:\n                domains_message += \"\\n\" + row[0]\n\n\tbot.send_message(chat_id=credentials.telegram_chat_id, text=domains_message, parse_mode=telegram.ParseMode.MARKDOWN)\n        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n                        [InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n        reply_markup = InlineKeyboardMarkup(keyboard)\n\tbot.send_message(chat_id=credentials.telegram_chat_id, text=\"Hi again!\", reply_markup=reply_markup)\n        return BUTTON\n\n\n\ndef get_domains(bot, update):\n\tglobal active\n\tglobal limit\n\tprint \"active: \" + str(active)\n\tprint \"limit: \" + str(limit)\n\tprint \"domain: \" + update.message.text\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (update.message.text,))\n\n\tdata = cursor.fetchall()\n\tcursor.close()\n\tconnection.close()\n\n\tsubdomains_message = \"\"\n\n\tif not data:\n\t\tsubdomains_message = \"No subdomains found for \" + str(update.message.text)\n\n\tif active == True:\n\t\tdata = [x for x in data if ord(x[1]) == True]\n\n\tif limit == True:\n\t\tprint \"Limit is True if\"\n\t\tdata = data[:20]\n\n\tfor row in data:\n\t\tsubdomains_message += \"\\n\" + row[0]\n\n\tupdate.message.reply_text(subdomains_message)\n\n        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n                        [InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        update.message.reply_text(\"Hi again :wave:\", reply_markup=reply_markup)\n\treturn BUTTON\n\n\n\n\n\ndef domains_contain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef help(bot, update):\n\tupdate.message.reply_text(\"click /start to start :)\")\n\n\ndef error(bot, update, error):\n\tlogger.warning('Update \"%s\" caused error \"%s\"', update, error)\n\t\t\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treply_markup = telegram.ReplyKeyboardRemove()\n\tupdate.message.reply_text(\"canceled! Click or type /start to start again\", reply_markup=reply_markup)\n\treturn ConversationHandler.END\n\n\ndef main():\n\t# Create the EventHandler and pass it your bot's token.\n\tupdater = Updater(telegram_bot_token)\n\n\t# Get the dispatcher to register handlers\n\tdp = updater.dispatcher\n\n\t# Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t\tBUTTON: [CallbackQueryHandler(button),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n\t\t\tCUSTOM_SCAN_ID_INPUT: [MessageHandler(Filters.text, custom_scan_id_input),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n                        ADD_DOMAIN: [MessageHandler(Filters.text, add_domain),\n                                           CommandHandler('cancel', cancel)],\n                        EDIT_DOMAIN: [MessageHandler(Filters.text, edit_domain),\n                                           CommandHandler('cancel', cancel)],\n                        GET_DOMAINS: [MessageHandler(Filters.text, get_domains),\n                                           CommandHandler('cancel', cancel)],\n                        CONTAINS: [MessageHandler(Filters.text, domains_contain),\n                                           CommandHandler('cancel', cancel)]\n\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\n\t# log all errors\n\tdp.add_error_handler(error)\n\n\t# Start the Bot\n\tupdater.start_polling()\n\n\t# Run the bot until you press Ctrl-C or the process receives SIGINT,\n\t# SIGTERM or SIGABRT. This should be used most of the time, since\n\t# start_polling() is non-blocking and will stop the bot gracefully.\n\tupdater.idle()\n\n\nif __name__ == '__main__':\n\tmain()\n", "source_code_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport logging, datetime, MySQLdb, os, telegram, sys\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nfrom random import randint\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\nimport credentials\n\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\ntelegram_bot_token = credentials.telegram_bot_token\n\nlogger = logging.getLogger(__name__)\n\nBUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n\ndef start(bot, update):\n\tprint \"---------- Start -----------\"\n\tif str(update.message.chat_id) != str(credentials.telegram_chat_id):\n\t\tupdate.message.reply_text(\"Not authorized! If you think this is a mistake, please check if your chat_id is in credentials.py. You can also run setup.py in /telegram to setup the right credentials for your telegram.\")\n\t\treturn\n\n\tuser = update.message.from_user\n\thour = datetime.datetime.now().hour\n\tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])\n\n\tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n\t\t\t[InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n\treply_markup = InlineKeyboardMarkup(keyboard)\n\tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n\tprint \"button before\"\n\treturn BUTTON\n\n\ndef button(bot, update):\n\tquery = update.callback_query\n\t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button\n\tchoice = query.data.split('-')[0]\n\tr = str(randint(0, 99))\n\n\theader_1 = \"Catagory:\"\n\tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + r)]]\n\n\theader_2 = \"Action:\"\n\tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n\t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n\t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n\theader_3 = \"Action:\"\n\tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n\t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n\t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        [InlineKeyboardButton(\"\u00c2\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n        header_5 = \"Action:\"\n        keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n                         InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n\t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n                        [InlineKeyboardButton(\"\u00c2\u00ab Back to data\", callback_data='back_data-' + r)]]\n\n        header_6 = \"Which type of domains?\"\n        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='all-' + r)],\n                        [InlineKeyboardButton(\"\u00c2\u00ab Back to actions\", callback_data='back_get-' + r)]]\n\n        header_7 = \"How many domains?\"\n        keyboard_7 = [[InlineKeyboardButton(\"Top 20\", callback_data='limit-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='nolimit-' + r)],\n                        [InlineKeyboardButton(\"\u00c2\u00ab Back to actions\", callback_data='back_data-' + r)]]\n\n\n\t#ToDO: Transform into a swtich\n\tif choice == \"back\":\n\t\tbot.edit_message_text(header_1, reply_markup=InlineKeyboardMarkup(keyboard_1), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"close\":\n\t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn ConversationHandler.END\n\telif choice == \"scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"data\":\n\t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif choice == \"latest\":\n\t\tget_latest_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\telif choice == \"custom\":\n\t\tget_custom_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\t\treturn CUSTOM_SCAN_ID_INPUT\n\telif choice == \"run\":\n\t\trun_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\n        if choice == \"add\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"Coming soon, pr's are welcome...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\treturn BUTTON\n\t\t#return ADD_DOMAIN\n        elif choice == \"edit\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return BUTTON\n\t\t#return EDIT_DOMAIN\n        elif choice == \"get\":\n                cursor.close()\n                connection.close()\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"topdomains\":\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = False\n\t\tprint \"choice = topdomains\"\n\t\treturn BUTTON\n        elif choice == \"subdomains\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = True\n\t\treturn BUTTON\n        elif choice == \"contains\":\n\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return BUTTON\n\t\t#return CONTAINS\n        elif choice == \"back_data\":\n                bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"back_get\":\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"active\":\n\t\tglobal active\n\t\tactive = True\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n        elif choice == \"all\":\n                global active\n                active = False\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"nolimit\":\n\t\tprint \"Nolimit\"\n\t\tglobal subdomains\n\t\tif subdomains:\n                        global limit\n                        limit = False\n\t\t\tbot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\treturn GET_DOMAINS\n\t\telse:\n\t\t\tprint \"topdomain\"\n\t\t\tglobal limit\n\t\t\tlimit = False\n\t\t\tget_topdomains(bot, update)\n\n        elif choice == \"limit\":\n                global subdomains\n\t\tprint \"Limit\"\n                if subdomains:\n                        global limit\n                        limit = True\n                        bot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                        return GET_DOMAINS\n                else:\n\t\t\tprint \"Topdomain\"\n                        global limit\n                        limit = True\n\t\t\tget_topdomains(bot, update)\n\n\tif choice == \"yes_scan\":\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telif choice == \"back_scan\" or choice == \"no_scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\ndef get_latest_scan(bot, update, cursor):\n\tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))\n\telse:\n\t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\n\ndef get_custom_scan(bot, update, cursor):\n\tquery = update.callback_query\n\n\tcursor.execute (\"SELECT ScanID FROM scans where EndDate is not null ORDER BY ScanID DESC LIMIT 10\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tlatestScanIds = sorted([str(x[0]) for x in data])\n\t\tfirstRow = latestScanIds[:len(latestScanIds)/2]\n\t\tsecondRow = latestScanIds[len(latestScanIds)/2:]\n\t\tcustom_keyboard = [firstRow, secondRow]\n\t\treply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\n\n\t\tif data:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\ttext=\"Which scan ID? \\n/cancel to cancel\",\n\t\t\t\treply_markup=reply_markup, ForceReply = True)\n\t\telse:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\t text=\"Which scan ID? \\n/cancel to cancel\")\n\n\ndef run_scan(bot, update, cursor):\n\tquery = update.callback_query\n\tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")\n\tdata = cursor.fetchall()\n\ttry:\n\t\tif data[0][2] != None:\n\t\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\t\telse:\n\t\t\tr = str(randint(0, 99))\n\t        \theader_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        \t\tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                \t\t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        \t\t[InlineKeyboardButton(\"\u00c2\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\t\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\t\treturn BUTTON\n\texcept Exception, e:\n\t\tprint \"error: \" + str(e)\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\n\ndef custom_scan_id_input(bot, update):\n\tprint \"inside input method with data: \" + update.message.text\n\tcustomId = update.message.text\n\ttry:\n\t\tint(customId)\n\texcept ValueError:\n\t\tprint \"invalid number\"\n\t\tupdate.message.reply_text(\"Not a valid number\")\n\telse:\n\t\tprint \"valid number\"\n\t\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n        \tcursor = connection.cursor ()\n\t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))\n\t        data = cursor.fetchall()\n\t\tcursor.close()\n\t\tconnection.close()\n\t\tif data:\n\t\t\tprint \"scan ID was found in the db\"\n\t\t\tprint \"data[0][0] is: \" + str(data[0][0])\n\t\t\tif data[0][0] == None:\n\t\t\t\tprint \"EndDate of scan is empty\"\n\t\t\t\tupdate.message.reply_text(\"This scan hasn't finished yet\")\n\t\t\telse:\n\t\t\t\tprint \"Valid scan found\"\n\t\t\t\treply_markup = telegram.ReplyKeyboardRemove()\n\t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)\n\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))\n\t\t\t\treturn ConversationHandler.END\n\t\telse:\n\t\t\tprint \"Scan ID not found in db\"\n\t\t\tupdate.message.reply_text(\"This scan ID doesn't exist\")\n\n\ndef add_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef edit_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef get_topdomains(bot, update):\n\tglobal limit\n\tprint \"Inside get_topdomains\"\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif limit == True:\n\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain limit 20\")\t\n\telse:\n\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\n\n\n        data = cursor.fetchall()\n        cursor.close()\n        connection.close()\n\n        domains_message = \"\"\n\n        if not data:\n                domains_message = \"No domains found\"\n\n        for row in data:\n                domains_message += \"\\n\" + row[0]\n\n\tbot.send_message(chat_id=credentials.telegram_chat_id, text=domains_message, parse_mode=telegram.ParseMode.MARKDOWN)\n        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n                        [InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n        reply_markup = InlineKeyboardMarkup(keyboard)\n\tbot.send_message(chat_id=credentials.telegram_chat_id, text=\"Hi again!\", reply_markup=reply_markup)\n        return BUTTON\n\n\n\ndef get_domains(bot, update):\n\tglobal active\n\tglobal limit\n\tprint \"active: \" + str(active)\n\tprint \"limit: \" + str(limit)\n\tprint \"domain: \" + update.message.text\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (update.message.text,))\n\n\tdata = cursor.fetchall()\n\tcursor.close()\n\tconnection.close()\n\n\tsubdomains_message = \"\"\n\n\tif not data:\n\t\tsubdomains_message = \"No subdomains found for \" + str(update.message.text)\n\n\tif active == True:\n\t\tdata = [x for x in data if ord(x[1]) == True]\n\n\tif limit == True:\n\t\tprint \"Limit is True if\"\n\t\tdata = data[:20]\n\n\tfor row in data:\n\t\tsubdomains_message += \"\\n\" + row[0]\n\n\tupdate.message.reply_text(subdomains_message)\n\n        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n                        [InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        update.message.reply_text(\"Hi again :wave:\", reply_markup=reply_markup)\n\treturn BUTTON\n\n\n\n\n\ndef domains_contain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef help(bot, update):\n\tupdate.message.reply_text(\"click /start to start :)\")\n\n\ndef error(bot, update, error):\n\tlogger.warning('Update \"%s\" caused error \"%s\"', update, error)\n\t\t\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treply_markup = telegram.ReplyKeyboardRemove()\n\tupdate.message.reply_text(\"canceled! Click or type /start to start again\", reply_markup=reply_markup)\n\treturn ConversationHandler.END\n\n\ndef main():\n\t# Create the EventHandler and pass it your bot's token.\n\tupdater = Updater(telegram_bot_token)\n\n\t# Get the dispatcher to register handlers\n\tdp = updater.dispatcher\n\n\t# Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t\tBUTTON: [CallbackQueryHandler(button),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n\t\t\tCUSTOM_SCAN_ID_INPUT: [MessageHandler(Filters.text, custom_scan_id_input),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n                        ADD_DOMAIN: [MessageHandler(Filters.text, add_domain),\n                                           CommandHandler('cancel', cancel)],\n                        EDIT_DOMAIN: [MessageHandler(Filters.text, edit_domain),\n                                           CommandHandler('cancel', cancel)],\n                        GET_DOMAINS: [MessageHandler(Filters.text, get_domains),\n                                           CommandHandler('cancel', cancel)],\n                        CONTAINS: [MessageHandler(Filters.text, domains_contain),\n                                           CommandHandler('cancel', cancel)]\n\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\n\t# log all errors\n\tdp.add_error_handler(error)\n\n\t# Start the Bot\n\tupdater.start_polling()\n\n\t# Run the bot until you press Ctrl-C or the process receives SIGINT,\n\t# SIGTERM or SIGABRT. This should be used most of the time, since\n\t# start_polling() is non-blocking and will stop the bot gracefully.\n\tupdater.idle()\n\n\nif __name__ == '__main__':\n\tmain()\n", "methods": [{"name": "start", "start_line": 22, "end_line": 39}, {"name": "button", "start_line": 42, "end_line": 202}, {"name": "get_latest_scan", "start_line": 205, "end_line": 211}, {"name": "get_custom_scan", "start_line": 214, "end_line": 232}, {"name": "run_scan", "start_line": 235, "end_line": 254}, {"name": "custom_scan_id_input", "start_line": 257, "end_line": 287}, {"name": "add_domain", "start_line": 290, "end_line": 292}, {"name": "edit_domain", "start_line": 295, "end_line": 297}, {"name": "get_topdomains", "start_line": 300, "end_line": 332}, {"name": "get_domains", "start_line": 336, "end_line": 375}, {"name": "domains_contain", "start_line": 381, "end_line": 383}, {"name": "help", "start_line": 386, "end_line": 387}, {"name": "error", "start_line": 390, "end_line": 391}, {"name": "cancel", "start_line": 394, "end_line": 398}, {"name": "main", "start_line": 401, "end_line": 442}], "methods_before": [{"name": "start", "start_line": 22, "end_line": 39}, {"name": "button", "start_line": 42, "end_line": 202}, {"name": "get_latest_scan", "start_line": 205, "end_line": 211}, {"name": "get_custom_scan", "start_line": 214, "end_line": 232}, {"name": "run_scan", "start_line": 235, "end_line": 254}, {"name": "custom_scan_id_input", "start_line": 257, "end_line": 287}, {"name": "add_domain", "start_line": 290, "end_line": 292}, {"name": "edit_domain", "start_line": 295, "end_line": 297}, {"name": "get_topdomains", "start_line": 300, "end_line": 332}, {"name": "get_domains", "start_line": 336, "end_line": 375}, {"name": "domains_contain", "start_line": 381, "end_line": 383}, {"name": "help", "start_line": 386, "end_line": 387}, {"name": "error", "start_line": 390, "end_line": 391}, {"name": "cancel", "start_line": 394, "end_line": 398}, {"name": "main", "start_line": 401, "end_line": 442}], "changed_methods": [{"name": "run_scan", "start_line": 235, "end_line": 254}, {"name": "button", "start_line": 42, "end_line": 202}], "nloc": 337, "complexity": 60, "token_count": 2966}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "07cfa29db2663180161c8566bea7747ddb93972b", "msg": "Update bot.py", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-15 13:11:04+02:00", "author_timezone": -7200, "committer_date": "2018-06-15 13:11:04+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["89d815f48ecb494b30d5b94073d880c8ff8388fb"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 1, "insertions": 1, "lines": 2, "files": 1, "modified_files": [{"old_path": "telegram/bot.py", "new_path": "telegram/bot.py", "filename": "bot.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -31,7 +31,7 @@ def start(bot, update):\n \n \tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n \t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n-\t\t\t[InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]\n+\t\t\t[InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + str(randint(0, 999)))]]\n \n \treply_markup = InlineKeyboardMarkup(keyboard)\n \tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n", "diff_parsed": {"added": [[34, "\t\t\t[InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + str(randint(0, 999)))]]"]], "deleted": [[34, "\t\t\t[InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]"]]}, "added_lines": 1, "deleted_lines": 1, "source_code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport logging, datetime, MySQLdb, os, telegram, sys\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nfrom random import randint\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\nimport credentials\n\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\ntelegram_bot_token = credentials.telegram_bot_token\n\nlogger = logging.getLogger(__name__)\n\nBUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n\ndef start(bot, update):\n\tprint \"---------- Start -----------\"\n\tif str(update.message.chat_id) != str(credentials.telegram_chat_id):\n\t\tupdate.message.reply_text(\"Not authorized! If you think this is a mistake, please check if your chat_id is in credentials.py. You can also run setup.py in /telegram to setup the right credentials for your telegram.\")\n\t\treturn\n\n\tuser = update.message.from_user\n\thour = datetime.datetime.now().hour\n\tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])\n\n\tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n\t\t\t[InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n\treply_markup = InlineKeyboardMarkup(keyboard)\n\tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n\tprint \"button before\"\n\treturn BUTTON\n\n\ndef button(bot, update):\n\tquery = update.callback_query\n\t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button\n\tchoice = query.data.split('-')[0]\n\tr = str(randint(0, 99))\n\n\theader_1 = \"Catagory:\"\n\tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + r)]]\n\n\theader_2 = \"Action:\"\n\tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n\t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n\t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n\theader_3 = \"Action:\"\n\tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n\t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n\t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n        header_5 = \"Action:\"\n        keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n                         InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n\t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]\n\n        header_6 = \"Which type of domains?\"\n        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='all-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n\n        header_7 = \"How many domains?\"\n        keyboard_7 = [[InlineKeyboardButton(\"Top 20\", callback_data='limit-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='nolimit-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_data-' + r)]]\n\n\n\t#ToDO: Transform into a swtich\n\tif choice == \"back\":\n\t\tbot.edit_message_text(header_1, reply_markup=InlineKeyboardMarkup(keyboard_1), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"close\":\n\t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn ConversationHandler.END\n\telif choice == \"scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"data\":\n\t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif choice == \"latest\":\n\t\tget_latest_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\telif choice == \"custom\":\n\t\tget_custom_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\t\treturn CUSTOM_SCAN_ID_INPUT\n\telif choice == \"run\":\n\t\trun_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\n        if choice == \"add\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"Coming soon, pr's are welcome...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\treturn BUTTON\n\t\t#return ADD_DOMAIN\n        elif choice == \"edit\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return BUTTON\n\t\t#return EDIT_DOMAIN\n        elif choice == \"get\":\n                cursor.close()\n                connection.close()\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"topdomains\":\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = False\n\t\tprint \"choice = topdomains\"\n\t\treturn BUTTON\n        elif choice == \"subdomains\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = True\n\t\treturn BUTTON\n        elif choice == \"contains\":\n\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return BUTTON\n\t\t#return CONTAINS\n        elif choice == \"back_data\":\n                bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"back_get\":\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"active\":\n\t\tglobal active\n\t\tactive = True\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n        elif choice == \"all\":\n                global active\n                active = False\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"nolimit\":\n\t\tprint \"Nolimit\"\n\t\tglobal subdomains\n\t\tif subdomains:\n                        global limit\n                        limit = False\n\t\t\tbot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\treturn GET_DOMAINS\n\t\telse:\n\t\t\tprint \"topdomain\"\n\t\t\tglobal limit\n\t\t\tlimit = False\n\t\t\tget_topdomains(bot, update)\n\n        elif choice == \"limit\":\n                global subdomains\n\t\tprint \"Limit\"\n                if subdomains:\n                        global limit\n                        limit = True\n                        bot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                        return GET_DOMAINS\n                else:\n\t\t\tprint \"Topdomain\"\n                        global limit\n                        limit = True\n\t\t\tget_topdomains(bot, update)\n\n\tif choice == \"yes_scan\":\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telif choice == \"back_scan\" or choice == \"no_scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\ndef get_latest_scan(bot, update, cursor):\n\tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))\n\telse:\n\t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\n\ndef get_custom_scan(bot, update, cursor):\n\tquery = update.callback_query\n\n\tcursor.execute (\"SELECT ScanID FROM scans where EndDate is not null ORDER BY ScanID DESC LIMIT 10\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tlatestScanIds = sorted([str(x[0]) for x in data])\n\t\tfirstRow = latestScanIds[:len(latestScanIds)/2]\n\t\tsecondRow = latestScanIds[len(latestScanIds)/2:]\n\t\tcustom_keyboard = [firstRow, secondRow]\n\t\treply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\n\n\t\tif data:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\ttext=\"Which scan ID? \\n/cancel to cancel\",\n\t\t\t\treply_markup=reply_markup, ForceReply = True)\n\t\telse:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\t text=\"Which scan ID? \\n/cancel to cancel\")\n\n\ndef run_scan(bot, update, cursor):\n\tquery = update.callback_query\n\tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")\n\tdata = cursor.fetchall()\n\ttry:\n\t\tif data[0][2] != None:\n\t\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\t\telse:\n\t\t\tr = str(randint(0, 99))\n\t        \theader_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        \t\tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                \t\t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        \t\t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\t\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\t\treturn BUTTON\n\texcept Exception, e:\n\t\tprint \"error: \" + str(e)\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\n\ndef custom_scan_id_input(bot, update):\n\tprint \"inside input method with data: \" + update.message.text\n\tcustomId = update.message.text\n\ttry:\n\t\tint(customId)\n\texcept ValueError:\n\t\tprint \"invalid number\"\n\t\tupdate.message.reply_text(\"Not a valid number\")\n\telse:\n\t\tprint \"valid number\"\n\t\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n        \tcursor = connection.cursor ()\n\t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))\n\t        data = cursor.fetchall()\n\t\tcursor.close()\n\t\tconnection.close()\n\t\tif data:\n\t\t\tprint \"scan ID was found in the db\"\n\t\t\tprint \"data[0][0] is: \" + str(data[0][0])\n\t\t\tif data[0][0] == None:\n\t\t\t\tprint \"EndDate of scan is empty\"\n\t\t\t\tupdate.message.reply_text(\"This scan hasn't finished yet\")\n\t\t\telse:\n\t\t\t\tprint \"Valid scan found\"\n\t\t\t\treply_markup = telegram.ReplyKeyboardRemove()\n\t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)\n\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))\n\t\t\t\treturn ConversationHandler.END\n\t\telse:\n\t\t\tprint \"Scan ID not found in db\"\n\t\t\tupdate.message.reply_text(\"This scan ID doesn't exist\")\n\n\ndef add_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef edit_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef get_topdomains(bot, update):\n\tglobal limit\n\tprint \"Inside get_topdomains\"\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif limit == True:\n\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain limit 20\")\t\n\telse:\n\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\n\n\n        data = cursor.fetchall()\n        cursor.close()\n        connection.close()\n\n        domains_message = \"\"\n\n        if not data:\n                domains_message = \"No domains found\"\n\n        for row in data:\n                domains_message += \"\\n\" + row[0]\n\n\tbot.send_message(chat_id=credentials.telegram_chat_id, text=domains_message, parse_mode=telegram.ParseMode.MARKDOWN)\n        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n                        [InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n        reply_markup = InlineKeyboardMarkup(keyboard)\n\tbot.send_message(chat_id=credentials.telegram_chat_id, text=\"Hi again!\", reply_markup=reply_markup)\n        return BUTTON\n\n\n\ndef get_domains(bot, update):\n\tglobal active\n\tglobal limit\n\tprint \"active: \" + str(active)\n\tprint \"limit: \" + str(limit)\n\tprint \"domain: \" + update.message.text\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (update.message.text,))\n\n\tdata = cursor.fetchall()\n\tcursor.close()\n\tconnection.close()\n\n\tsubdomains_message = \"\"\n\n\tif not data:\n\t\tsubdomains_message = \"No subdomains found for \" + str(update.message.text)\n\n\tif active == True:\n\t\tdata = [x for x in data if ord(x[1]) == True]\n\n\tif limit == True:\n\t\tprint \"Limit is True if\"\n\t\tdata = data[:20]\n\n\tfor row in data:\n\t\tsubdomains_message += \"\\n\" + row[0]\n\n\tupdate.message.reply_text(subdomains_message)\n\n        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n                        [InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        update.message.reply_text(\"Hi again :wave:\", reply_markup=reply_markup)\n\treturn BUTTON\n\n\n\n\n\ndef domains_contain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef help(bot, update):\n\tupdate.message.reply_text(\"click /start to start :)\")\n\n\ndef error(bot, update, error):\n\tlogger.warning('Update \"%s\" caused error \"%s\"', update, error)\n\t\t\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treply_markup = telegram.ReplyKeyboardRemove()\n\tupdate.message.reply_text(\"canceled! Click or type /start to start again\", reply_markup=reply_markup)\n\treturn ConversationHandler.END\n\n\ndef main():\n\t# Create the EventHandler and pass it your bot's token.\n\tupdater = Updater(telegram_bot_token)\n\n\t# Get the dispatcher to register handlers\n\tdp = updater.dispatcher\n\n\t# Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t\tBUTTON: [CallbackQueryHandler(button),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n\t\t\tCUSTOM_SCAN_ID_INPUT: [MessageHandler(Filters.text, custom_scan_id_input),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n                        ADD_DOMAIN: [MessageHandler(Filters.text, add_domain),\n                                           CommandHandler('cancel', cancel)],\n                        EDIT_DOMAIN: [MessageHandler(Filters.text, edit_domain),\n                                           CommandHandler('cancel', cancel)],\n                        GET_DOMAINS: [MessageHandler(Filters.text, get_domains),\n                                           CommandHandler('cancel', cancel)],\n                        CONTAINS: [MessageHandler(Filters.text, domains_contain),\n                                           CommandHandler('cancel', cancel)]\n\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\n\t# log all errors\n\tdp.add_error_handler(error)\n\n\t# Start the Bot\n\tupdater.start_polling()\n\n\t# Run the bot until you press Ctrl-C or the process receives SIGINT,\n\t# SIGTERM or SIGABRT. This should be used most of the time, since\n\t# start_polling() is non-blocking and will stop the bot gracefully.\n\tupdater.idle()\n\n\nif __name__ == '__main__':\n\tmain()\n", "source_code_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport logging, datetime, MySQLdb, os, telegram, sys\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nfrom random import randint\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\nimport credentials\n\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\ntelegram_bot_token = credentials.telegram_bot_token\n\nlogger = logging.getLogger(__name__)\n\nBUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n\ndef start(bot, update):\n\tprint \"---------- Start -----------\"\n\tif str(update.message.chat_id) != str(credentials.telegram_chat_id):\n\t\tupdate.message.reply_text(\"Not authorized! If you think this is a mistake, please check if your chat_id is in credentials.py. You can also run setup.py in /telegram to setup the right credentials for your telegram.\")\n\t\treturn\n\n\tuser = update.message.from_user\n\thour = datetime.datetime.now().hour\n\tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])\n\n\tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n\t\t\t[InlineKeyboardButton(\"\u00e2\u0153\u02dc Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n\treply_markup = InlineKeyboardMarkup(keyboard)\n\tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n\tprint \"button before\"\n\treturn BUTTON\n\n\ndef button(bot, update):\n\tquery = update.callback_query\n\t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button\n\tchoice = query.data.split('-')[0]\n\tr = str(randint(0, 99))\n\n\theader_1 = \"Catagory:\"\n\tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + r)]]\n\n\theader_2 = \"Action:\"\n\tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n\t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n\t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n\theader_3 = \"Action:\"\n\tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n\t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n\t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n        header_5 = \"Action:\"\n        keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n                         InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n\t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]\n\n        header_6 = \"Which type of domains?\"\n        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='all-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n\n        header_7 = \"How many domains?\"\n        keyboard_7 = [[InlineKeyboardButton(\"Top 20\", callback_data='limit-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='nolimit-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_data-' + r)]]\n\n\n\t#ToDO: Transform into a swtich\n\tif choice == \"back\":\n\t\tbot.edit_message_text(header_1, reply_markup=InlineKeyboardMarkup(keyboard_1), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"close\":\n\t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn ConversationHandler.END\n\telif choice == \"scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"data\":\n\t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif choice == \"latest\":\n\t\tget_latest_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\telif choice == \"custom\":\n\t\tget_custom_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\t\treturn CUSTOM_SCAN_ID_INPUT\n\telif choice == \"run\":\n\t\trun_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\n        if choice == \"add\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"Coming soon, pr's are welcome...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\treturn BUTTON\n\t\t#return ADD_DOMAIN\n        elif choice == \"edit\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return BUTTON\n\t\t#return EDIT_DOMAIN\n        elif choice == \"get\":\n                cursor.close()\n                connection.close()\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"topdomains\":\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = False\n\t\tprint \"choice = topdomains\"\n\t\treturn BUTTON\n        elif choice == \"subdomains\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = True\n\t\treturn BUTTON\n        elif choice == \"contains\":\n\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return BUTTON\n\t\t#return CONTAINS\n        elif choice == \"back_data\":\n                bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"back_get\":\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"active\":\n\t\tglobal active\n\t\tactive = True\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n        elif choice == \"all\":\n                global active\n                active = False\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"nolimit\":\n\t\tprint \"Nolimit\"\n\t\tglobal subdomains\n\t\tif subdomains:\n                        global limit\n                        limit = False\n\t\t\tbot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\treturn GET_DOMAINS\n\t\telse:\n\t\t\tprint \"topdomain\"\n\t\t\tglobal limit\n\t\t\tlimit = False\n\t\t\tget_topdomains(bot, update)\n\n        elif choice == \"limit\":\n                global subdomains\n\t\tprint \"Limit\"\n                if subdomains:\n                        global limit\n                        limit = True\n                        bot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                        return GET_DOMAINS\n                else:\n\t\t\tprint \"Topdomain\"\n                        global limit\n                        limit = True\n\t\t\tget_topdomains(bot, update)\n\n\tif choice == \"yes_scan\":\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telif choice == \"back_scan\" or choice == \"no_scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\ndef get_latest_scan(bot, update, cursor):\n\tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))\n\telse:\n\t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\n\ndef get_custom_scan(bot, update, cursor):\n\tquery = update.callback_query\n\n\tcursor.execute (\"SELECT ScanID FROM scans where EndDate is not null ORDER BY ScanID DESC LIMIT 10\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tlatestScanIds = sorted([str(x[0]) for x in data])\n\t\tfirstRow = latestScanIds[:len(latestScanIds)/2]\n\t\tsecondRow = latestScanIds[len(latestScanIds)/2:]\n\t\tcustom_keyboard = [firstRow, secondRow]\n\t\treply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\n\n\t\tif data:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\ttext=\"Which scan ID? \\n/cancel to cancel\",\n\t\t\t\treply_markup=reply_markup, ForceReply = True)\n\t\telse:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\t text=\"Which scan ID? \\n/cancel to cancel\")\n\n\ndef run_scan(bot, update, cursor):\n\tquery = update.callback_query\n\tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")\n\tdata = cursor.fetchall()\n\ttry:\n\t\tif data[0][2] != None:\n\t\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\t\telse:\n\t\t\tr = str(randint(0, 99))\n\t        \theader_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        \t\tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                \t\t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        \t\t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\t\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\t\treturn BUTTON\n\texcept Exception, e:\n\t\tprint \"error: \" + str(e)\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\n\ndef custom_scan_id_input(bot, update):\n\tprint \"inside input method with data: \" + update.message.text\n\tcustomId = update.message.text\n\ttry:\n\t\tint(customId)\n\texcept ValueError:\n\t\tprint \"invalid number\"\n\t\tupdate.message.reply_text(\"Not a valid number\")\n\telse:\n\t\tprint \"valid number\"\n\t\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n        \tcursor = connection.cursor ()\n\t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))\n\t        data = cursor.fetchall()\n\t\tcursor.close()\n\t\tconnection.close()\n\t\tif data:\n\t\t\tprint \"scan ID was found in the db\"\n\t\t\tprint \"data[0][0] is: \" + str(data[0][0])\n\t\t\tif data[0][0] == None:\n\t\t\t\tprint \"EndDate of scan is empty\"\n\t\t\t\tupdate.message.reply_text(\"This scan hasn't finished yet\")\n\t\t\telse:\n\t\t\t\tprint \"Valid scan found\"\n\t\t\t\treply_markup = telegram.ReplyKeyboardRemove()\n\t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)\n\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))\n\t\t\t\treturn ConversationHandler.END\n\t\telse:\n\t\t\tprint \"Scan ID not found in db\"\n\t\t\tupdate.message.reply_text(\"This scan ID doesn't exist\")\n\n\ndef add_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef edit_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef get_topdomains(bot, update):\n\tglobal limit\n\tprint \"Inside get_topdomains\"\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif limit == True:\n\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain limit 20\")\t\n\telse:\n\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\n\n\n        data = cursor.fetchall()\n        cursor.close()\n        connection.close()\n\n        domains_message = \"\"\n\n        if not data:\n                domains_message = \"No domains found\"\n\n        for row in data:\n                domains_message += \"\\n\" + row[0]\n\n\tbot.send_message(chat_id=credentials.telegram_chat_id, text=domains_message, parse_mode=telegram.ParseMode.MARKDOWN)\n        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n                        [InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n        reply_markup = InlineKeyboardMarkup(keyboard)\n\tbot.send_message(chat_id=credentials.telegram_chat_id, text=\"Hi again!\", reply_markup=reply_markup)\n        return BUTTON\n\n\n\ndef get_domains(bot, update):\n\tglobal active\n\tglobal limit\n\tprint \"active: \" + str(active)\n\tprint \"limit: \" + str(limit)\n\tprint \"domain: \" + update.message.text\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (update.message.text,))\n\n\tdata = cursor.fetchall()\n\tcursor.close()\n\tconnection.close()\n\n\tsubdomains_message = \"\"\n\n\tif not data:\n\t\tsubdomains_message = \"No subdomains found for \" + str(update.message.text)\n\n\tif active == True:\n\t\tdata = [x for x in data if ord(x[1]) == True]\n\n\tif limit == True:\n\t\tprint \"Limit is True if\"\n\t\tdata = data[:20]\n\n\tfor row in data:\n\t\tsubdomains_message += \"\\n\" + row[0]\n\n\tupdate.message.reply_text(subdomains_message)\n\n        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n                        [InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        update.message.reply_text(\"Hi again :wave:\", reply_markup=reply_markup)\n\treturn BUTTON\n\n\n\n\n\ndef domains_contain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef help(bot, update):\n\tupdate.message.reply_text(\"click /start to start :)\")\n\n\ndef error(bot, update, error):\n\tlogger.warning('Update \"%s\" caused error \"%s\"', update, error)\n\t\t\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treply_markup = telegram.ReplyKeyboardRemove()\n\tupdate.message.reply_text(\"canceled! Click or type /start to start again\", reply_markup=reply_markup)\n\treturn ConversationHandler.END\n\n\ndef main():\n\t# Create the EventHandler and pass it your bot's token.\n\tupdater = Updater(telegram_bot_token)\n\n\t# Get the dispatcher to register handlers\n\tdp = updater.dispatcher\n\n\t# Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t\tBUTTON: [CallbackQueryHandler(button),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n\t\t\tCUSTOM_SCAN_ID_INPUT: [MessageHandler(Filters.text, custom_scan_id_input),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n                        ADD_DOMAIN: [MessageHandler(Filters.text, add_domain),\n                                           CommandHandler('cancel', cancel)],\n                        EDIT_DOMAIN: [MessageHandler(Filters.text, edit_domain),\n                                           CommandHandler('cancel', cancel)],\n                        GET_DOMAINS: [MessageHandler(Filters.text, get_domains),\n                                           CommandHandler('cancel', cancel)],\n                        CONTAINS: [MessageHandler(Filters.text, domains_contain),\n                                           CommandHandler('cancel', cancel)]\n\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\n\t# log all errors\n\tdp.add_error_handler(error)\n\n\t# Start the Bot\n\tupdater.start_polling()\n\n\t# Run the bot until you press Ctrl-C or the process receives SIGINT,\n\t# SIGTERM or SIGABRT. This should be used most of the time, since\n\t# start_polling() is non-blocking and will stop the bot gracefully.\n\tupdater.idle()\n\n\nif __name__ == '__main__':\n\tmain()\n", "methods": [{"name": "start", "start_line": 22, "end_line": 39}, {"name": "button", "start_line": 42, "end_line": 202}, {"name": "get_latest_scan", "start_line": 205, "end_line": 211}, {"name": "get_custom_scan", "start_line": 214, "end_line": 232}, {"name": "run_scan", "start_line": 235, "end_line": 254}, {"name": "custom_scan_id_input", "start_line": 257, "end_line": 287}, {"name": "add_domain", "start_line": 290, "end_line": 292}, {"name": "edit_domain", "start_line": 295, "end_line": 297}, {"name": "get_topdomains", "start_line": 300, "end_line": 332}, {"name": "get_domains", "start_line": 336, "end_line": 375}, {"name": "domains_contain", "start_line": 381, "end_line": 383}, {"name": "help", "start_line": 386, "end_line": 387}, {"name": "error", "start_line": 390, "end_line": 391}, {"name": "cancel", "start_line": 394, "end_line": 398}, {"name": "main", "start_line": 401, "end_line": 442}], "methods_before": [{"name": "start", "start_line": 22, "end_line": 39}, {"name": "button", "start_line": 42, "end_line": 202}, {"name": "get_latest_scan", "start_line": 205, "end_line": 211}, {"name": "get_custom_scan", "start_line": 214, "end_line": 232}, {"name": "run_scan", "start_line": 235, "end_line": 254}, {"name": "custom_scan_id_input", "start_line": 257, "end_line": 287}, {"name": "add_domain", "start_line": 290, "end_line": 292}, {"name": "edit_domain", "start_line": 295, "end_line": 297}, {"name": "get_topdomains", "start_line": 300, "end_line": 332}, {"name": "get_domains", "start_line": 336, "end_line": 375}, {"name": "domains_contain", "start_line": 381, "end_line": 383}, {"name": "help", "start_line": 386, "end_line": 387}, {"name": "error", "start_line": 390, "end_line": 391}, {"name": "cancel", "start_line": 394, "end_line": 398}, {"name": "main", "start_line": 401, "end_line": 442}], "changed_methods": [{"name": "start", "start_line": 22, "end_line": 39}], "nloc": 337, "complexity": 60, "token_count": 2966}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "c2bec13da206f3a917ce6e466f959e595c5a70a7", "msg": "Update README.md", "author": {"name": "streaak", "email": "streaksterz@gmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-16 21:49:57+05:30", "author_timezone": -19800, "committer_date": "2018-06-16 21:49:57+05:30", "committer_timezone": -19800, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["07cfa29db2663180161c8566bea7747ddb93972b"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 0, "insertions": 25, "lines": 25, "files": 1, "modified_files": [{"old_path": "README.md", "new_path": "README.md", "filename": "README.md", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -3,6 +3,31 @@ ICU is a tool to constantly keep an updated database of domains and subdomains,\n   \n ICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n \n+# Setting up the MySql server\n+```\n+$sudo mysql_secure_installation\n+Would you like to setup VALIDATE PASSWORD plugin?\n+\n+Press y|Y for Yes, any other key for No: n\n+\n+Remove anonymous users? (Press y|Y for Yes, any other key for No) : y\n+Success.\n+\n+Disallow root login remotely? (Press y|Y for Yes, any other key for No) : y\n+Success.\n+\n+Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y\n+ - Dropping test database...\n+Success.\n+\n+ - Removing privileges on test database...\n+Success.\n+\n+Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y\n+Success.\n+\n+All done!\n+```\n     \n # Install \n ```\n", "diff_parsed": {"added": [[6, "# Setting up the MySql server"], [7, "```"], [8, "$sudo mysql_secure_installation"], [9, "Would you like to setup VALIDATE PASSWORD plugin?"], [10, ""], [11, "Press y|Y for Yes, any other key for No: n"], [12, ""], [13, "Remove anonymous users? (Press y|Y for Yes, any other key for No) : y"], [14, "Success."], [15, ""], [16, "Disallow root login remotely? (Press y|Y for Yes, any other key for No) : y"], [17, "Success."], [18, ""], [19, "Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y"], [20, " - Dropping test database..."], [21, "Success."], [22, ""], [23, " - Removing privileges on test database..."], [24, "Success."], [25, ""], [26, "Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y"], [27, "Success."], [28, ""], [29, "All done!"], [30, "```"]], "deleted": []}, "added_lines": 25, "deleted_lines": 0, "source_code": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n\n# Setting up the MySql server\n```\n$sudo mysql_secure_installation\nWould you like to setup VALIDATE PASSWORD plugin?\n\nPress y|Y for Yes, any other key for No: n\n\nRemove anonymous users? (Press y|Y for Yes, any other key for No) : y\nSuccess.\n\nDisallow root login remotely? (Press y|Y for Yes, any other key for No) : y\nSuccess.\n\nRemove test database and access to it? (Press y|Y for Yes, any other key for No) : y\n - Dropping test database...\nSuccess.\n\n - Removing privileges on test database...\nSuccess.\n\nReload privilege tables now? (Press y|Y for Yes, any other key for No) : y\nSuccess.\n\nAll done!\n```\n    \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n   \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n\n# Images  \n![main.py](https://poc-server.com/github/ICU/main.py.png)\n  ___  \n![Telegram Bot](https://poc-server.com/github/ICU/telegrambot.png)\n\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "source_code_before": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n\n    \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n   \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n\n# Images  \n![main.py](https://poc-server.com/github/ICU/main.py.png)\n  ___  \n![Telegram Bot](https://poc-server.com/github/ICU/telegrambot.png)\n\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "6e86a2053bcc20066f590ed8344888967f002dc1", "msg": "Merge pull request #1 from streaak/master\n\nUpdate README.md", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-16 16:23:38+00:00", "author_timezone": 0, "committer_date": "2018-06-16 16:23:38+00:00", "committer_timezone": 0, "branches": "{'master'}", "in_main_branch": true, "merge": true, "parents": ["07cfa29db2663180161c8566bea7747ddb93972b", "c2bec13da206f3a917ce6e466f959e595c5a70a7"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 0, "insertions": 25, "lines": 25, "files": 1, "modified_files": [], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "c503b8e8e24a5feb3bde8314cd163bd9ead5173f", "msg": "Update REAMME.md PR by Streaak", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-16 16:24:53+00:00", "author_timezone": 0, "committer_date": "2018-06-16 16:24:53+00:00", "committer_timezone": 0, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["6e86a2053bcc20066f590ed8344888967f002dc1"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 19, "insertions": 29, "lines": 48, "files": 1, "modified_files": [{"old_path": "README.md", "new_path": "README.md", "filename": "README.md", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -2,51 +2,61 @@\n ICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n   \n ICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n+  \n+    \n+# Install \n+```\n+git clone https://github.com/003random/ICU  \n+cd ICU\n+./install.sh \n+```  \n+The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n \n-# Setting up the MySql server\n+## Optional (recommended)\n+ICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \n+You need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \n+After you've installed GO; Execute the following commands to install Amass and Subfinder: \n+```\n+go get github.com/caffix/amass\n+go get github.com/Ice3man543/subfinder\n ```\n+ \n+ ## Setting up the MySql server\n+\n+```\n+\n $sudo mysql_secure_installation\n+\n Would you like to setup VALIDATE PASSWORD plugin?\n \n Press y|Y for Yes, any other key for No: n\n \n Remove anonymous users? (Press y|Y for Yes, any other key for No) : y\n+\n Success.\n \n Disallow root login remotely? (Press y|Y for Yes, any other key for No) : y\n+\n Success.\n \n Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y\n+\n  - Dropping test database...\n+\n Success.\n \n  - Removing privileges on test database...\n+\n Success.\n \n Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y\n+\n Success.\n \n All done!\n-```\n-    \n-# Install \n-```\n-git clone https://github.com/003random/ICU  \n-cd ICU\n-./install.sh \n-```  \n-The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n \n-## Optional (recommended)\n-ICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \n-You need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \n-After you've installed GO; Execute the following commands to install Amass and Subfinder: \n ```\n-go get github.com/caffix/amass\n-go get github.com/Ice3man543/subfinder\n-```\n-\n-\n+  \n # Telegram \n ICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n    \n", "diff_parsed": {"added": [[5, ""], [6, ""], [7, "# Install"], [8, "```"], [9, "git clone https://github.com/003random/ICU"], [10, "cd ICU"], [11, "./install.sh"], [12, "```"], [13, "The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on."], [15, "## Optional (recommended)"], [16, "ICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\")."], [17, "You need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO."], [18, "After you've installed GO; Execute the following commands to install Amass and Subfinder:"], [19, "```"], [20, "go get github.com/caffix/amass"], [21, "go get github.com/Ice3man543/subfinder"], [23, ""], [24, " ## Setting up the MySql server"], [25, ""], [26, "```"], [27, ""], [29, ""], [35, ""], [39, ""], [43, ""], [45, ""], [49, ""], [53, ""], [59, ""]], "deleted": [[6, "# Setting up the MySql server"], [30, "```"], [31, ""], [32, "# Install"], [33, "```"], [34, "git clone https://github.com/003random/ICU"], [35, "cd ICU"], [36, "./install.sh"], [37, "```"], [38, "The installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on."], [40, "## Optional (recommended)"], [41, "ICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\")."], [42, "You need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO."], [43, "After you've installed GO; Execute the following commands to install Amass and Subfinder:"], [45, "go get github.com/caffix/amass"], [46, "go get github.com/Ice3man543/subfinder"], [47, "```"], [48, ""], [49, ""]]}, "added_lines": 29, "deleted_lines": 19, "source_code": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n  \n    \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n \n ## Setting up the MySql server\n\n```\n\n$sudo mysql_secure_installation\n\nWould you like to setup VALIDATE PASSWORD plugin?\n\nPress y|Y for Yes, any other key for No: n\n\nRemove anonymous users? (Press y|Y for Yes, any other key for No) : y\n\nSuccess.\n\nDisallow root login remotely? (Press y|Y for Yes, any other key for No) : y\n\nSuccess.\n\nRemove test database and access to it? (Press y|Y for Yes, any other key for No) : y\n\n - Dropping test database...\n\nSuccess.\n\n - Removing privileges on test database...\n\nSuccess.\n\nReload privilege tables now? (Press y|Y for Yes, any other key for No) : y\n\nSuccess.\n\nAll done!\n\n```\n  \n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n   \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n\n# Images  \n![main.py](https://poc-server.com/github/ICU/main.py.png)\n  ___  \n![Telegram Bot](https://poc-server.com/github/ICU/telegrambot.png)\n\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "source_code_before": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n\n# Setting up the MySql server\n```\n$sudo mysql_secure_installation\nWould you like to setup VALIDATE PASSWORD plugin?\n\nPress y|Y for Yes, any other key for No: n\n\nRemove anonymous users? (Press y|Y for Yes, any other key for No) : y\nSuccess.\n\nDisallow root login remotely? (Press y|Y for Yes, any other key for No) : y\nSuccess.\n\nRemove test database and access to it? (Press y|Y for Yes, any other key for No) : y\n - Dropping test database...\nSuccess.\n\n - Removing privileges on test database...\nSuccess.\n\nReload privilege tables now? (Press y|Y for Yes, any other key for No) : y\nSuccess.\n\nAll done!\n```\n    \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n\n\n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n   \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n\n# Images  \n![main.py](https://poc-server.com/github/ICU/main.py.png)\n  ___  \n![Telegram Bot](https://poc-server.com/github/ICU/telegrambot.png)\n\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "8fb7eb613d4510c560e8a7f1e49ba690fac112fe", "msg": "Update README.md; PR by @Streaak", "author": {"name": "003random", "email": "003random@protonmail.com"}, "committer": {"name": "GitHub", "email": "noreply@github.com"}, "author_date": "2018-06-16 16:25:27+00:00", "author_timezone": 0, "committer_date": "2018-06-16 16:25:27+00:00", "committer_timezone": 0, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["c503b8e8e24a5feb3bde8314cd163bd9ead5173f"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 1, "insertions": 1, "lines": 2, "files": 1, "modified_files": [{"old_path": "README.md", "new_path": "README.md", "filename": "README.md", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -21,7 +21,7 @@ go get github.com/caffix/amass\n go get github.com/Ice3man543/subfinder\n ```\n  \n- ## Setting up the MySql server\n+ ## Setting up the MySQL server\n \n ```\n \n", "diff_parsed": {"added": [[24, " ## Setting up the MySQL server"]], "deleted": [[24, " ## Setting up the MySql server"]]}, "added_lines": 1, "deleted_lines": 1, "source_code": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n  \n    \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n \n ## Setting up the MySQL server\n\n```\n\n$sudo mysql_secure_installation\n\nWould you like to setup VALIDATE PASSWORD plugin?\n\nPress y|Y for Yes, any other key for No: n\n\nRemove anonymous users? (Press y|Y for Yes, any other key for No) : y\n\nSuccess.\n\nDisallow root login remotely? (Press y|Y for Yes, any other key for No) : y\n\nSuccess.\n\nRemove test database and access to it? (Press y|Y for Yes, any other key for No) : y\n\n - Dropping test database...\n\nSuccess.\n\n - Removing privileges on test database...\n\nSuccess.\n\nReload privilege tables now? (Press y|Y for Yes, any other key for No) : y\n\nSuccess.\n\nAll done!\n\n```\n  \n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n   \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n\n# Images  \n![main.py](https://poc-server.com/github/ICU/main.py.png)\n  ___  \n![Telegram Bot](https://poc-server.com/github/ICU/telegrambot.png)\n\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "source_code_before": "## \ud83d\udccc Description \nICU is a tool to constantly keep an updated database of domains and subdomains, by regularly scanning domains for subdomains with the most common subdomain scanners.  \n  \nICU works by creating a database with domains and a crontask to launch the subdomain scanners script. You can launch this script manually as well. You can also keep control of your domains and subdomains with the main.py script or with the telegram bot. There is also a simple web application that is meant for a quick view of your domains. This web application is not meant yet for a large number of domains.  \n  \n    \n# Install \n```\ngit clone https://github.com/003random/ICU  \ncd ICU\n./install.sh \n```  \nThe installation script asks for various things, including your MySQL database username and password. These will be saved in credentials.py. You can always change these credentials later on. \n\n## Optional (recommended)\nICU also uses [Subfinder](\"https://github.com/Ice3man543/subfinder\") and [Amass](\"https://github.com/caffix/amass/\"). \nYou need to install those as well. You need to have GO for those tools. [Here](\"https://www.digitalocean.com/community/tutorials/how-to-install-go-on-debian-8\") you can find how to install GO. \nAfter you've installed GO; Execute the following commands to install Amass and Subfinder: \n```\ngo get github.com/caffix/amass\ngo get github.com/Ice3man543/subfinder\n```\n \n ## Setting up the MySql server\n\n```\n\n$sudo mysql_secure_installation\n\nWould you like to setup VALIDATE PASSWORD plugin?\n\nPress y|Y for Yes, any other key for No: n\n\nRemove anonymous users? (Press y|Y for Yes, any other key for No) : y\n\nSuccess.\n\nDisallow root login remotely? (Press y|Y for Yes, any other key for No) : y\n\nSuccess.\n\nRemove test database and access to it? (Press y|Y for Yes, any other key for No) : y\n\n - Dropping test database...\n\nSuccess.\n\n - Removing privileges on test database...\n\nSuccess.\n\nReload privilege tables now? (Press y|Y for Yes, any other key for No) : y\n\nSuccess.\n\nAll done!\n\n```\n  \n# Telegram \nICU also includes a telegram bot and notifications part. If you want to use this, you will have to include your telegram bot token in credentials.py. You can get a telegram bot token [here](\"https://core.telegram.org/bots#3-how-do-i-create-a-bot\"). Next off, you need to run setup.py in /telegram, and then send /start to the bot. This will save your chat_id to credentials.py so it can be used for authentication with the bot, and to send the notifications to.  \n   \n# Modules \nThe following modules are used: MySQLdb, telegram, random, sys, os, datetime, logging, time. \n \nThe install script offers an option to install the modules from requirements.txt. This requires pip to be installed. If, for some reason, some modules are still missing. Then install these modules. The most important one is MySQLdb. [here](\"https://stackoverflow.com/questions/25865270/how-to-install-python-mysqldb-module-using-pip\") you can read how to install MySQLdb.  \n\n# Extra\nTo get ICU up and running, requires some simple skills. If you need serious help, you can contact me via twitter.  \n \n# Credits \nCredits to:  \n[Subfinder](\"https://github.com/Ice3man543/subfinder\"), [Amass](\"https://github.com/caffix/amass/\"), [Sublist3r](\"https://github.com/aboul3la/Sublist3r\")!\n\n# Images  \n![main.py](https://poc-server.com/github/ICU/main.py.png)\n  ___  \n![Telegram Bot](https://poc-server.com/github/ICU/telegrambot.png)\n\n \n*Created by [003random](http://hackerone.com/003random) - [@003random](https://twitter.com/rub003) - [003random.com](https://poc-server.com/blog/)*  \n\n\n\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": null, "complexity": null, "token_count": null}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "852a227eeff0a9544be2111213b6a63ab0136881", "msg": "request from @madaratech solved", "author": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "committer": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "author_date": "2018-07-11 00:20:59+02:00", "author_timezone": -7200, "committer_date": "2018-07-11 00:20:59+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["8fb7eb613d4510c560e8a7f1e49ba690fac112fe"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 6, "insertions": 16, "lines": 22, "files": 2, "modified_files": [{"old_path": "telegram/bot.py", "new_path": "telegram/bot.py", "filename": "bot.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -206,7 +206,7 @@ def get_latest_scan(bot, update, cursor):\n \tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")\n \tdata = cursor.fetchall()\n \tif data:\n-\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))\n+\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]) + \" true\")\n \telse:\n \t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n \n@@ -280,7 +280,7 @@ def custom_scan_id_input(bot, update):\n \t\t\t\tprint \"Valid scan found\"\n \t\t\t\treply_markup = telegram.ReplyKeyboardRemove()\n \t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)\n-\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))\n+\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId) + \" true\")\n \t\t\t\treturn ConversationHandler.END\n \t\telse:\n \t\t\tprint \"Scan ID not found in db\"\n", "diff_parsed": {"added": [[209, "\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]) + \" true\")"], [283, "\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId) + \" true\")"]], "deleted": [[209, "\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))"], [283, "\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))"]]}, "added_lines": 2, "deleted_lines": 2, "source_code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport logging, datetime, MySQLdb, os, telegram, sys\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nfrom random import randint\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\nimport credentials\n\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\ntelegram_bot_token = credentials.telegram_bot_token\n\nlogger = logging.getLogger(__name__)\n\nBUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n\ndef start(bot, update):\n\tprint \"---------- Start -----------\"\n\tif str(update.message.chat_id) != str(credentials.telegram_chat_id):\n\t\tupdate.message.reply_text(\"Not authorized! If you think this is a mistake, please check if your chat_id is in credentials.py. You can also run setup.py in /telegram to setup the right credentials for your telegram.\")\n\t\treturn\n\n\tuser = update.message.from_user\n\thour = datetime.datetime.now().hour\n\tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])\n\n\tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n\t\t\t[InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n\treply_markup = InlineKeyboardMarkup(keyboard)\n\tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n\tprint \"button before\"\n\treturn BUTTON\n\n\ndef button(bot, update):\n\tquery = update.callback_query\n\t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button\n\tchoice = query.data.split('-')[0]\n\tr = str(randint(0, 99))\n\n\theader_1 = \"Catagory:\"\n\tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + r)]]\n\n\theader_2 = \"Action:\"\n\tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n\t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n\t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n\theader_3 = \"Action:\"\n\tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n\t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n\t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n        header_5 = \"Action:\"\n        keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n                         InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n\t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]\n\n        header_6 = \"Which type of domains?\"\n        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='all-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n\n        header_7 = \"How many domains?\"\n        keyboard_7 = [[InlineKeyboardButton(\"Top 20\", callback_data='limit-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='nolimit-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_data-' + r)]]\n\n\n\t#ToDO: Transform into a swtich\n\tif choice == \"back\":\n\t\tbot.edit_message_text(header_1, reply_markup=InlineKeyboardMarkup(keyboard_1), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"close\":\n\t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn ConversationHandler.END\n\telif choice == \"scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"data\":\n\t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif choice == \"latest\":\n\t\tget_latest_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\telif choice == \"custom\":\n\t\tget_custom_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\t\treturn CUSTOM_SCAN_ID_INPUT\n\telif choice == \"run\":\n\t\trun_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\n        if choice == \"add\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"Coming soon, pr's are welcome...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\treturn BUTTON\n\t\t#return ADD_DOMAIN\n        elif choice == \"edit\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return BUTTON\n\t\t#return EDIT_DOMAIN\n        elif choice == \"get\":\n                cursor.close()\n                connection.close()\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"topdomains\":\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = False\n\t\tprint \"choice = topdomains\"\n\t\treturn BUTTON\n        elif choice == \"subdomains\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = True\n\t\treturn BUTTON\n        elif choice == \"contains\":\n\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return BUTTON\n\t\t#return CONTAINS\n        elif choice == \"back_data\":\n                bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"back_get\":\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"active\":\n\t\tglobal active\n\t\tactive = True\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n        elif choice == \"all\":\n                global active\n                active = False\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"nolimit\":\n\t\tprint \"Nolimit\"\n\t\tglobal subdomains\n\t\tif subdomains:\n                        global limit\n                        limit = False\n\t\t\tbot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\treturn GET_DOMAINS\n\t\telse:\n\t\t\tprint \"topdomain\"\n\t\t\tglobal limit\n\t\t\tlimit = False\n\t\t\tget_topdomains(bot, update)\n\n        elif choice == \"limit\":\n                global subdomains\n\t\tprint \"Limit\"\n                if subdomains:\n                        global limit\n                        limit = True\n                        bot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                        return GET_DOMAINS\n                else:\n\t\t\tprint \"Topdomain\"\n                        global limit\n                        limit = True\n\t\t\tget_topdomains(bot, update)\n\n\tif choice == \"yes_scan\":\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telif choice == \"back_scan\" or choice == \"no_scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\ndef get_latest_scan(bot, update, cursor):\n\tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]) + \" true\")\n\telse:\n\t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\n\ndef get_custom_scan(bot, update, cursor):\n\tquery = update.callback_query\n\n\tcursor.execute (\"SELECT ScanID FROM scans where EndDate is not null ORDER BY ScanID DESC LIMIT 10\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tlatestScanIds = sorted([str(x[0]) for x in data])\n\t\tfirstRow = latestScanIds[:len(latestScanIds)/2]\n\t\tsecondRow = latestScanIds[len(latestScanIds)/2:]\n\t\tcustom_keyboard = [firstRow, secondRow]\n\t\treply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\n\n\t\tif data:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\ttext=\"Which scan ID? \\n/cancel to cancel\",\n\t\t\t\treply_markup=reply_markup, ForceReply = True)\n\t\telse:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\t text=\"Which scan ID? \\n/cancel to cancel\")\n\n\ndef run_scan(bot, update, cursor):\n\tquery = update.callback_query\n\tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")\n\tdata = cursor.fetchall()\n\ttry:\n\t\tif data[0][2] != None:\n\t\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\t\telse:\n\t\t\tr = str(randint(0, 99))\n\t        \theader_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        \t\tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                \t\t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        \t\t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\t\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\t\treturn BUTTON\n\texcept Exception, e:\n\t\tprint \"error: \" + str(e)\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\n\ndef custom_scan_id_input(bot, update):\n\tprint \"inside input method with data: \" + update.message.text\n\tcustomId = update.message.text\n\ttry:\n\t\tint(customId)\n\texcept ValueError:\n\t\tprint \"invalid number\"\n\t\tupdate.message.reply_text(\"Not a valid number\")\n\telse:\n\t\tprint \"valid number\"\n\t\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n        \tcursor = connection.cursor ()\n\t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))\n\t        data = cursor.fetchall()\n\t\tcursor.close()\n\t\tconnection.close()\n\t\tif data:\n\t\t\tprint \"scan ID was found in the db\"\n\t\t\tprint \"data[0][0] is: \" + str(data[0][0])\n\t\t\tif data[0][0] == None:\n\t\t\t\tprint \"EndDate of scan is empty\"\n\t\t\t\tupdate.message.reply_text(\"This scan hasn't finished yet\")\n\t\t\telse:\n\t\t\t\tprint \"Valid scan found\"\n\t\t\t\treply_markup = telegram.ReplyKeyboardRemove()\n\t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)\n\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId) + \" true\")\n\t\t\t\treturn ConversationHandler.END\n\t\telse:\n\t\t\tprint \"Scan ID not found in db\"\n\t\t\tupdate.message.reply_text(\"This scan ID doesn't exist\")\n\n\ndef add_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef edit_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef get_topdomains(bot, update):\n\tglobal limit\n\tprint \"Inside get_topdomains\"\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif limit == True:\n\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain limit 20\")\t\n\telse:\n\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\n\n\n        data = cursor.fetchall()\n        cursor.close()\n        connection.close()\n\n        domains_message = \"\"\n\n        if not data:\n                domains_message = \"No domains found\"\n\n        for row in data:\n                domains_message += \"\\n\" + row[0]\n\n\tbot.send_message(chat_id=credentials.telegram_chat_id, text=domains_message, parse_mode=telegram.ParseMode.MARKDOWN)\n        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n                        [InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n        reply_markup = InlineKeyboardMarkup(keyboard)\n\tbot.send_message(chat_id=credentials.telegram_chat_id, text=\"Hi again!\", reply_markup=reply_markup)\n        return BUTTON\n\n\n\ndef get_domains(bot, update):\n\tglobal active\n\tglobal limit\n\tprint \"active: \" + str(active)\n\tprint \"limit: \" + str(limit)\n\tprint \"domain: \" + update.message.text\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (update.message.text,))\n\n\tdata = cursor.fetchall()\n\tcursor.close()\n\tconnection.close()\n\n\tsubdomains_message = \"\"\n\n\tif not data:\n\t\tsubdomains_message = \"No subdomains found for \" + str(update.message.text)\n\n\tif active == True:\n\t\tdata = [x for x in data if ord(x[1]) == True]\n\n\tif limit == True:\n\t\tprint \"Limit is True if\"\n\t\tdata = data[:20]\n\n\tfor row in data:\n\t\tsubdomains_message += \"\\n\" + row[0]\n\n\tupdate.message.reply_text(subdomains_message)\n\n        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n                        [InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        update.message.reply_text(\"Hi again :wave:\", reply_markup=reply_markup)\n\treturn BUTTON\n\n\n\n\n\ndef domains_contain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef help(bot, update):\n\tupdate.message.reply_text(\"click /start to start :)\")\n\n\ndef error(bot, update, error):\n\tlogger.warning('Update \"%s\" caused error \"%s\"', update, error)\n\t\t\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treply_markup = telegram.ReplyKeyboardRemove()\n\tupdate.message.reply_text(\"canceled! Click or type /start to start again\", reply_markup=reply_markup)\n\treturn ConversationHandler.END\n\n\ndef main():\n\t# Create the EventHandler and pass it your bot's token.\n\tupdater = Updater(telegram_bot_token)\n\n\t# Get the dispatcher to register handlers\n\tdp = updater.dispatcher\n\n\t# Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t\tBUTTON: [CallbackQueryHandler(button),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n\t\t\tCUSTOM_SCAN_ID_INPUT: [MessageHandler(Filters.text, custom_scan_id_input),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n                        ADD_DOMAIN: [MessageHandler(Filters.text, add_domain),\n                                           CommandHandler('cancel', cancel)],\n                        EDIT_DOMAIN: [MessageHandler(Filters.text, edit_domain),\n                                           CommandHandler('cancel', cancel)],\n                        GET_DOMAINS: [MessageHandler(Filters.text, get_domains),\n                                           CommandHandler('cancel', cancel)],\n                        CONTAINS: [MessageHandler(Filters.text, domains_contain),\n                                           CommandHandler('cancel', cancel)]\n\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\n\t# log all errors\n\tdp.add_error_handler(error)\n\n\t# Start the Bot\n\tupdater.start_polling()\n\n\t# Run the bot until you press Ctrl-C or the process receives SIGINT,\n\t# SIGTERM or SIGABRT. This should be used most of the time, since\n\t# start_polling() is non-blocking and will stop the bot gracefully.\n\tupdater.idle()\n\n\nif __name__ == '__main__':\n\tmain()\n", "source_code_before": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport logging, datetime, MySQLdb, os, telegram, sys\nfrom telegram import (InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton)\nfrom telegram.ext import Updater, CommandHandler, CallbackQueryHandler, ConversationHandler, MessageHandler, Filters\nfrom random import randint\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\nimport credentials\n\n\n# Enable logging\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n\t\t\t\t\tlevel=logging.INFO)\n\ntelegram_bot_token = credentials.telegram_bot_token\n\nlogger = logging.getLogger(__name__)\n\nBUTTON, CUSTOM_SCAN_ID_INPUT, ADD_DOMAIN, EDIT_DOMAIN, GET_DOMAINS, CONTAINS = range(6)\n\ndef start(bot, update):\n\tprint \"---------- Start -----------\"\n\tif str(update.message.chat_id) != str(credentials.telegram_chat_id):\n\t\tupdate.message.reply_text(\"Not authorized! If you think this is a mistake, please check if your chat_id is in credentials.py. You can also run setup.py in /telegram to setup the right credentials for your telegram.\")\n\t\treturn\n\n\tuser = update.message.from_user\n\thour = datetime.datetime.now().hour\n\tgreeting = \"Good morning \" + str(user['first_name']) if 5<=hour<12 else \"Good afternoon \" + str(user['first_name']) if hour<18 else \"Good evening \" + str(user['first_name'])\n\n\tkeyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n\t\t\t[InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n\treply_markup = InlineKeyboardMarkup(keyboard)\n\tupdate.message.reply_text(greeting, reply_markup=reply_markup)\n\tprint \"button before\"\n\treturn BUTTON\n\n\ndef button(bot, update):\n\tquery = update.callback_query\n\t#each callback_data attr has a random int after the '-' to make the button unique each time so the spinning loading circle goes away after returning to an excisting button\n\tchoice = query.data.split('-')[0]\n\tr = str(randint(0, 99))\n\n\theader_1 = \"Catagory:\"\n\tkeyboard_1 = [[InlineKeyboardButton(\"Data\", callback_data='data-' + r),\n\t\t\t InlineKeyboardButton(\"Scans\", callback_data='scan-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + r)]]\n\n\theader_2 = \"Action:\"\n\tkeyboard_2 = [[InlineKeyboardButton(\"Latest\", callback_data='latest-' + r),\n\t\t\t InlineKeyboardButton(\"Custom\", callback_data='custom-' + r),\n\t\t\t InlineKeyboardButton(\"Run\", callback_data='run-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n\theader_3 = \"Action:\"\n\tkeyboard_3 = [[InlineKeyboardButton(\"Add\", callback_data='add-' + r),\n\t\t\t InlineKeyboardButton(\"Edit\", callback_data='edit-' + r),\n\t\t\t InlineKeyboardButton(\"Get\", callback_data='get-' + r)],\n\t\t\t[InlineKeyboardButton(\"\u00ab Back to catagories\", callback_data='back-' + r)]]\n\n        header_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        keyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\n        header_5 = \"Action:\"\n        keyboard_5 = [[InlineKeyboardButton(\"(top)Domains\", callback_data='topdomains-' + r),\n                         InlineKeyboardButton(\"Subdomains\", callback_data='subdomains-' + r),\n\t\t\t InlineKeyboardButton(\"Contains\", callback_data='contains-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to data\", callback_data='back_data-' + r)]]\n\n        header_6 = \"Which type of domains?\"\n        keyboard_6 = [[InlineKeyboardButton(\"Active\", callback_data='active-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='all-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_get-' + r)]]\n\n        header_7 = \"How many domains?\"\n        keyboard_7 = [[InlineKeyboardButton(\"Top 20\", callback_data='limit-' + r),\n                         InlineKeyboardButton(\"All\", callback_data='nolimit-' + r)],\n                        [InlineKeyboardButton(\"\u00ab Back to actions\", callback_data='back_data-' + r)]]\n\n\n\t#ToDO: Transform into a swtich\n\tif choice == \"back\":\n\t\tbot.edit_message_text(header_1, reply_markup=InlineKeyboardMarkup(keyboard_1), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"close\":\n\t\tbot.edit_message_text(\"/start\", chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn ConversationHandler.END\n\telif choice == \"scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\telif choice == \"data\":\n\t\tbot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif choice == \"latest\":\n\t\tget_latest_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\telif choice == \"custom\":\n\t\tget_custom_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\t\treturn CUSTOM_SCAN_ID_INPUT\n\telif choice == \"run\":\n\t\trun_scan(bot, update, cursor)\n\t\tcursor.close()\n\t\tconnection.close()\n\n        if choice == \"add\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"Coming soon, pr's are welcome...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\treturn BUTTON\n\t\t#return ADD_DOMAIN\n        elif choice == \"edit\":\n                cursor.close()\n                connection.close()\n\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return BUTTON\n\t\t#return EDIT_DOMAIN\n        elif choice == \"get\":\n                cursor.close()\n                connection.close()\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"topdomains\":\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = False\n\t\tprint \"choice = topdomains\"\n\t\treturn BUTTON\n        elif choice == \"subdomains\":\n                bot.edit_message_text(header_6, reply_markup=InlineKeyboardMarkup(keyboard_6), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                global subdomains\n\t\tsubdomains = True\n\t\treturn BUTTON\n        elif choice == \"contains\":\n\t\tbot.send_message(text=\"Coming soon...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                return BUTTON\n\t\t#return CONTAINS\n        elif choice == \"back_data\":\n                bot.edit_message_text(header_3, reply_markup=InlineKeyboardMarkup(keyboard_3), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n        elif choice == \"back_get\":\n                bot.edit_message_text(header_5, reply_markup=InlineKeyboardMarkup(keyboard_5), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"active\":\n\t\tglobal active\n\t\tactive = True\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n        elif choice == \"all\":\n                global active\n                active = False\n                bot.edit_message_text(header_7, reply_markup=InlineKeyboardMarkup(keyboard_7), chat_id=query.message.chat_id, message_id=query.message.message_id)\n                return BUTTON\n\n        if choice == \"nolimit\":\n\t\tprint \"Nolimit\"\n\t\tglobal subdomains\n\t\tif subdomains:\n                        global limit\n                        limit = False\n\t\t\tbot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\treturn GET_DOMAINS\n\t\telse:\n\t\t\tprint \"topdomain\"\n\t\t\tglobal limit\n\t\t\tlimit = False\n\t\t\tget_topdomains(bot, update)\n\n        elif choice == \"limit\":\n                global subdomains\n\t\tprint \"Limit\"\n                if subdomains:\n                        global limit\n                        limit = True\n                        bot.send_message(text=\"What is the (top)domain?\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n                        return GET_DOMAINS\n                else:\n\t\t\tprint \"Topdomain\"\n                        global limit\n                        limit = True\n\t\t\tget_topdomains(bot, update)\n\n\tif choice == \"yes_scan\":\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t#os.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\telif choice == \"back_scan\" or choice == \"no_scan\":\n\t\tbot.edit_message_text(header_2, reply_markup=InlineKeyboardMarkup(keyboard_2), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\treturn BUTTON\n\n\ndef get_latest_scan(bot, update, cursor):\n\tcursor.execute(\"select max(ScanID) from scans where EndDate is not null\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(data[0][0]))\n\telse:\n\t\tbot.send_message(text=\"No completed scans found!\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\n\ndef get_custom_scan(bot, update, cursor):\n\tquery = update.callback_query\n\n\tcursor.execute (\"SELECT ScanID FROM scans where EndDate is not null ORDER BY ScanID DESC LIMIT 10\")\n\tdata = cursor.fetchall()\n\tif data:\n\t\tlatestScanIds = sorted([str(x[0]) for x in data])\n\t\tfirstRow = latestScanIds[:len(latestScanIds)/2]\n\t\tsecondRow = latestScanIds[len(latestScanIds)/2:]\n\t\tcustom_keyboard = [firstRow, secondRow]\n\t\treply_markup = telegram.ReplyKeyboardMarkup(custom_keyboard)\n\n\t\tif data:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\ttext=\"Which scan ID? \\n/cancel to cancel\",\n\t\t\t\treply_markup=reply_markup, ForceReply = True)\n\t\telse:\n\t\t\tbot.send_message(chat_id=query.message.chat_id,\n\t\t\t\t text=\"Which scan ID? \\n/cancel to cancel\")\n\n\ndef run_scan(bot, update, cursor):\n\tquery = update.callback_query\n\tcursor.execute (\"SELECT * FROM scans ORDER BY ScanID DESC LIMIT 1\")\n\tdata = cursor.fetchall()\n\ttry:\n\t\tif data[0][2] != None:\n\t\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\t\telse:\n\t\t\tr = str(randint(0, 99))\n\t        \theader_4 = \"It looks like a scan is already running. Want to start a new one?\"\n        \t\tkeyboard_4 = [[InlineKeyboardButton(\"Yes\", callback_data='yes_scan-' + r),\n                \t\t         InlineKeyboardButton(\"No\", callback_data='no_scan-' + r)],\n                        \t\t[InlineKeyboardButton(\"\u00ab Back to scans\", callback_data='back_scan-' + r)]]\n\t\t\tbot.edit_message_text(header_4, reply_markup=InlineKeyboardMarkup(keyboard_4), chat_id=query.message.chat_id, message_id=query.message.message_id)\n\t\t\treturn BUTTON\n\texcept Exception, e:\n\t\tprint \"error: \" + str(e)\n\t\tbot.send_message(text=\"Starting a new scan...\", chat_id=query.message.chat_id, parse_mode=telegram.ParseMode.MARKDOWN)\n\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/../run.py\")\n\n\ndef custom_scan_id_input(bot, update):\n\tprint \"inside input method with data: \" + update.message.text\n\tcustomId = update.message.text\n\ttry:\n\t\tint(customId)\n\texcept ValueError:\n\t\tprint \"invalid number\"\n\t\tupdate.message.reply_text(\"Not a valid number\")\n\telse:\n\t\tprint \"valid number\"\n\t\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n        \tcursor = connection.cursor ()\n\t        cursor.execute (\"SELECT EndDate FROM scans where scanID = %s\", (customId))\n\t        data = cursor.fetchall()\n\t\tcursor.close()\n\t\tconnection.close()\n\t\tif data:\n\t\t\tprint \"scan ID was found in the db\"\n\t\t\tprint \"data[0][0] is: \" + str(data[0][0])\n\t\t\tif data[0][0] == None:\n\t\t\t\tprint \"EndDate of scan is empty\"\n\t\t\t\tupdate.message.reply_text(\"This scan hasn't finished yet\")\n\t\t\telse:\n\t\t\t\tprint \"Valid scan found\"\n\t\t\t\treply_markup = telegram.ReplyKeyboardRemove()\n\t\t\t\tupdate.message.reply_text(\"Showing scan from scan \" + str(customId), reply_markup=reply_markup)\n\t\t\t\tos.system(\"python \" + os.path.dirname(os.path.abspath(__file__))  + \"/notify.py \" + str(customId))\n\t\t\t\treturn ConversationHandler.END\n\t\telse:\n\t\t\tprint \"Scan ID not found in db\"\n\t\t\tupdate.message.reply_text(\"This scan ID doesn't exist\")\n\n\ndef add_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef edit_domain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef get_topdomains(bot, update):\n\tglobal limit\n\tprint \"Inside get_topdomains\"\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tif limit == True:\n\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain limit 20\")\t\n\telse:\n\t\tcursor.execute (\"select Domain from domains where TopDomainID is NULL order by Domain\")\n\n\n        data = cursor.fetchall()\n        cursor.close()\n        connection.close()\n\n        domains_message = \"\"\n\n        if not data:\n                domains_message = \"No domains found\"\n\n        for row in data:\n                domains_message += \"\\n\" + row[0]\n\n\tbot.send_message(chat_id=credentials.telegram_chat_id, text=domains_message, parse_mode=telegram.ParseMode.MARKDOWN)\n        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n                        [InlineKeyboardButton(\"\u2718 Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n        reply_markup = InlineKeyboardMarkup(keyboard)\n\tbot.send_message(chat_id=credentials.telegram_chat_id, text=\"Hi again!\", reply_markup=reply_markup)\n        return BUTTON\n\n\n\ndef get_domains(bot, update):\n\tglobal active\n\tglobal limit\n\tprint \"active: \" + str(active)\n\tprint \"limit: \" + str(limit)\n\tprint \"domain: \" + update.message.text\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor ()\n\n\tcursor.execute (\"select Domain, Active from domains where TopDomainID = (select DomainID from domains where Domain = %s) order by Domain\", (update.message.text,))\n\n\tdata = cursor.fetchall()\n\tcursor.close()\n\tconnection.close()\n\n\tsubdomains_message = \"\"\n\n\tif not data:\n\t\tsubdomains_message = \"No subdomains found for \" + str(update.message.text)\n\n\tif active == True:\n\t\tdata = [x for x in data if ord(x[1]) == True]\n\n\tif limit == True:\n\t\tprint \"Limit is True if\"\n\t\tdata = data[:20]\n\n\tfor row in data:\n\t\tsubdomains_message += \"\\n\" + row[0]\n\n\tupdate.message.reply_text(subdomains_message)\n\n        keyboard = [[InlineKeyboardButton(\"Data\", callback_data='data-' + str(randint(0, 999))),\n                         InlineKeyboardButton(\"Scans\", callback_data='scan-' + str(randint(0, 999)))],\n                        [InlineKeyboardButton(\"\u2718  Close\", callback_data='close-' + str(randint(0, 999)))]]\n\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        update.message.reply_text(\"Hi again :wave:\", reply_markup=reply_markup)\n\treturn BUTTON\n\n\n\n\n\ndef domains_contain(bot, update):\n\tprint update.message.text\n\treturn BUTTON\n\n\ndef help(bot, update):\n\tupdate.message.reply_text(\"click /start to start :)\")\n\n\ndef error(bot, update, error):\n\tlogger.warning('Update \"%s\" caused error \"%s\"', update, error)\n\t\t\n\ndef cancel(bot, update):\n\tprint \"canceled\"\n\treply_markup = telegram.ReplyKeyboardRemove()\n\tupdate.message.reply_text(\"canceled! Click or type /start to start again\", reply_markup=reply_markup)\n\treturn ConversationHandler.END\n\n\ndef main():\n\t# Create the EventHandler and pass it your bot's token.\n\tupdater = Updater(telegram_bot_token)\n\n\t# Get the dispatcher to register handlers\n\tdp = updater.dispatcher\n\n\t# Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO\n\tconv_handler = ConversationHandler(\n\t\tentry_points=[CommandHandler('start', start)],\n\n\t\tstates={\n\t\t\tBUTTON: [CallbackQueryHandler(button),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n\t\t\tCUSTOM_SCAN_ID_INPUT: [MessageHandler(Filters.text, custom_scan_id_input),\n\t\t\t\t\t   CommandHandler('cancel', cancel)],\n                        ADD_DOMAIN: [MessageHandler(Filters.text, add_domain),\n                                           CommandHandler('cancel', cancel)],\n                        EDIT_DOMAIN: [MessageHandler(Filters.text, edit_domain),\n                                           CommandHandler('cancel', cancel)],\n                        GET_DOMAINS: [MessageHandler(Filters.text, get_domains),\n                                           CommandHandler('cancel', cancel)],\n                        CONTAINS: [MessageHandler(Filters.text, domains_contain),\n                                           CommandHandler('cancel', cancel)]\n\n\t\t},\n\n\t\tfallbacks=[CommandHandler('cancel', cancel)]\n\t)\n\n\tdp.add_handler(conv_handler)\n\n\t# log all errors\n\tdp.add_error_handler(error)\n\n\t# Start the Bot\n\tupdater.start_polling()\n\n\t# Run the bot until you press Ctrl-C or the process receives SIGINT,\n\t# SIGTERM or SIGABRT. This should be used most of the time, since\n\t# start_polling() is non-blocking and will stop the bot gracefully.\n\tupdater.idle()\n\n\nif __name__ == '__main__':\n\tmain()\n", "methods": [{"name": "start", "start_line": 22, "end_line": 39}, {"name": "button", "start_line": 42, "end_line": 202}, {"name": "get_latest_scan", "start_line": 205, "end_line": 211}, {"name": "get_custom_scan", "start_line": 214, "end_line": 232}, {"name": "run_scan", "start_line": 235, "end_line": 254}, {"name": "custom_scan_id_input", "start_line": 257, "end_line": 287}, {"name": "add_domain", "start_line": 290, "end_line": 292}, {"name": "edit_domain", "start_line": 295, "end_line": 297}, {"name": "get_topdomains", "start_line": 300, "end_line": 332}, {"name": "get_domains", "start_line": 336, "end_line": 375}, {"name": "domains_contain", "start_line": 381, "end_line": 383}, {"name": "help", "start_line": 386, "end_line": 387}, {"name": "error", "start_line": 390, "end_line": 391}, {"name": "cancel", "start_line": 394, "end_line": 398}, {"name": "main", "start_line": 401, "end_line": 442}], "methods_before": [{"name": "start", "start_line": 22, "end_line": 39}, {"name": "button", "start_line": 42, "end_line": 202}, {"name": "get_latest_scan", "start_line": 205, "end_line": 211}, {"name": "get_custom_scan", "start_line": 214, "end_line": 232}, {"name": "run_scan", "start_line": 235, "end_line": 254}, {"name": "custom_scan_id_input", "start_line": 257, "end_line": 287}, {"name": "add_domain", "start_line": 290, "end_line": 292}, {"name": "edit_domain", "start_line": 295, "end_line": 297}, {"name": "get_topdomains", "start_line": 300, "end_line": 332}, {"name": "get_domains", "start_line": 336, "end_line": 375}, {"name": "domains_contain", "start_line": 381, "end_line": 383}, {"name": "help", "start_line": 386, "end_line": 387}, {"name": "error", "start_line": 390, "end_line": 391}, {"name": "cancel", "start_line": 394, "end_line": 398}, {"name": "main", "start_line": 401, "end_line": 442}], "changed_methods": [{"name": "custom_scan_id_input", "start_line": 257, "end_line": 287}, {"name": "get_latest_scan", "start_line": 205, "end_line": 211}], "nloc": 337, "complexity": 60, "token_count": 2970}, {"old_path": "telegram/notify.py", "new_path": "telegram/notify.py", "filename": "notify.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -15,7 +15,7 @@ message = \"*\" + str(datetime.datetime.now().replace(microsecond=0)) + \"*\"\n connection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n cursor = connection.cursor()\n \n-cursor.execute (\"select * from domains where scan_Id = %s and Active order by TopDomainID\", (scanId))\n+cursor.execute (\"select Domain from domains where scan_Id = %s and Active order by TopDomainID\", (scanId))\n newSubDomains = cursor.fetchall()\n \n cursor.execute (\"select * from errors where scan_Id = %s order by ErrorDate\", (scanId))\n@@ -23,6 +23,14 @@ errors = cursor.fetchall()\n \n connection.close()\n \n+display_all = False\n+\n+try:\n+\tif sys.argv[2] == \"true\":\n+\t\tdisplay_all = True\n+except:\n+\tprint \"Not called from bot\"\n+\n message += \"\\n_Scan \" + str(scanId) + \"_\"\n \n message += \"\\n\"\n@@ -35,10 +43,12 @@ elif len(errors) == 1:\n if len(errors) > 0:\n \tmessage += \"\\n--------------\"\n \n-if len(newSubDomains) > 1:\n+if (len(newSubDomains) < 15 and display_all == False) or (len(newSubDomains) < 100 and display_all == True):\n \tmessage += \"\\n\\[+] \" + str(len(newSubDomains)) + \" New subdomains:\"\n-elif len(newSubDomains) == 1:\n-\tmessage += \"\\n\\[+] \" + str(len(newSubDomains)) + \" New subdomain:\"\n+\tfor domain in newSubDomains:\n+\t\tmessage += \"\\n\" + str(domain[0])\n+else:\n+\tmessage += \"\\n\\[+] \" + str(len(newSubDomains)) + \" New subdomains\"\n \n message += \"\"\n \n", "diff_parsed": {"added": [[18, "cursor.execute (\"select Domain from domains where scan_Id = %s and Active order by TopDomainID\", (scanId))"], [26, "display_all = False"], [27, ""], [28, "try:"], [29, "\tif sys.argv[2] == \"true\":"], [30, "\t\tdisplay_all = True"], [31, "except:"], [32, "\tprint \"Not called from bot\""], [33, ""], [46, "if (len(newSubDomains) < 15 and display_all == False) or (len(newSubDomains) < 100 and display_all == True):"], [48, "\tfor domain in newSubDomains:"], [49, "\t\tmessage += \"\\n\" + str(domain[0])"], [50, "else:"], [51, "\tmessage += \"\\n\\[+] \" + str(len(newSubDomains)) + \" New subdomains\""]], "deleted": [[18, "cursor.execute (\"select * from domains where scan_Id = %s and Active order by TopDomainID\", (scanId))"], [38, "if len(newSubDomains) > 1:"], [40, "elif len(newSubDomains) == 1:"], [41, "\tmessage += \"\\n\\[+] \" + str(len(newSubDomains)) + \" New subdomain:\""]]}, "added_lines": 14, "deleted_lines": 4, "source_code": "#!/usr/bin/python\n\nimport sys, datetime, MySQLdb, telegram, os\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\nimport credentials\n\nif credentials.telegram_bot_token == \"\" or credentials.telegram_chat_id == \"\":\n\tprint \"[+] No telegram bot token and/or telegram chat id set in credentials.py\"\n\tsys.exit()\n\nbot = telegram.Bot(credentials.telegram_bot_token)\nscanId = sys.argv[1]\nmessage = \"*\" + str(datetime.datetime.now().replace(microsecond=0)) + \"*\"\n\nconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\ncursor = connection.cursor()\n\ncursor.execute (\"select Domain from domains where scan_Id = %s and Active order by TopDomainID\", (scanId))\nnewSubDomains = cursor.fetchall()\n\ncursor.execute (\"select * from errors where scan_Id = %s order by ErrorDate\", (scanId))\nerrors = cursor.fetchall()\n\nconnection.close()\n\ndisplay_all = False\n\ntry:\n\tif sys.argv[2] == \"true\":\n\t\tdisplay_all = True\nexcept:\n\tprint \"Not called from bot\"\n\nmessage += \"\\n_Scan \" + str(scanId) + \"_\"\n\nmessage += \"\\n\"\n\nif len(errors) > 1:\n        message += \"\\n(\" + str(len(errors)) + \"  Errors)\"\nelif len(errors) == 1:\n        message += \"\\n(\" + str(len(errors)) + \"  Error)\"\n\nif len(errors) > 0:\n\tmessage += \"\\n--------------\"\n\nif (len(newSubDomains) < 15 and display_all == False) or (len(newSubDomains) < 100 and display_all == True):\n\tmessage += \"\\n\\[+] \" + str(len(newSubDomains)) + \" New subdomains:\"\n\tfor domain in newSubDomains:\n\t\tmessage += \"\\n\" + str(domain[0])\nelse:\n\tmessage += \"\\n\\[+] \" + str(len(newSubDomains)) + \" New subdomains\"\n\nmessage += \"\"\n\nbot.send_message(chat_id=credentials.telegram_chat_id, text=message, parse_mode=telegram.ParseMode.MARKDOWN)\n", "source_code_before": "#!/usr/bin/python\n\nimport sys, datetime, MySQLdb, telegram, os\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../\")\nimport credentials\n\nif credentials.telegram_bot_token == \"\" or credentials.telegram_chat_id == \"\":\n\tprint \"[+] No telegram bot token and/or telegram chat id set in credentials.py\"\n\tsys.exit()\n\nbot = telegram.Bot(credentials.telegram_bot_token)\nscanId = sys.argv[1]\nmessage = \"*\" + str(datetime.datetime.now().replace(microsecond=0)) + \"*\"\n\nconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\ncursor = connection.cursor()\n\ncursor.execute (\"select * from domains where scan_Id = %s and Active order by TopDomainID\", (scanId))\nnewSubDomains = cursor.fetchall()\n\ncursor.execute (\"select * from errors where scan_Id = %s order by ErrorDate\", (scanId))\nerrors = cursor.fetchall()\n\nconnection.close()\n\nmessage += \"\\n_Scan \" + str(scanId) + \"_\"\n\nmessage += \"\\n\"\n\nif len(errors) > 1:\n        message += \"\\n(\" + str(len(errors)) + \"  Errors)\"\nelif len(errors) == 1:\n        message += \"\\n(\" + str(len(errors)) + \"  Error)\"\n\nif len(errors) > 0:\n\tmessage += \"\\n--------------\"\n\nif len(newSubDomains) > 1:\n\tmessage += \"\\n\\[+] \" + str(len(newSubDomains)) + \" New subdomains:\"\nelif len(newSubDomains) == 1:\n\tmessage += \"\\n\\[+] \" + str(len(newSubDomains)) + \" New subdomain:\"\n\nmessage += \"\"\n\nbot.send_message(chat_id=credentials.telegram_chat_id, text=message, parse_mode=telegram.ParseMode.MARKDOWN)\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": 38, "complexity": 0, "token_count": 357}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null},
    {"hash": "154861420f252f6e0abaae346ed3656bf3e59679", "msg": "Error when running scan from main.py resolved", "author": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "committer": {"name": "RJP", "email": "rjp@debian8svm.debian8svm"}, "author_date": "2018-07-11 00:26:03+02:00", "author_timezone": -7200, "committer_date": "2018-07-11 00:26:03+02:00", "committer_timezone": -7200, "branches": "{'master'}", "in_main_branch": true, "merge": false, "parents": ["852a227eeff0a9544be2111213b6a63ab0136881"], "project_name": "ICU", "project_path": "/Volumes/nVME1T/Py/GitIn/output/temp/003random_all_20250524_145901/26bf7a7e/26bf7a7e/26bf7a7e/ICU", "deletions": 0, "insertions": 2, "lines": 2, "files": 1, "modified_files": [{"old_path": "database/additional_tools/domains_db.py", "new_path": "database/additional_tools/domains_db.py", "filename": "domains_db.py", "change_type": "ModificationType.MODIFY", "change_type_name": "MODIFY", "diff": "@@ -104,6 +104,8 @@ try:\n except Exception as e:\n \t#Handle the errors, and save them to the database\n \tprint \"error in domains_db.py with main domain; \" + domain\n+\tif scanId == \"NULL\":\n+\t\tscanId = None\n \tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in domains_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n \tconnection.commit()\n \tcursor.close()\n", "diff_parsed": {"added": [[107, "\tif scanId == \"NULL\":"], [108, "\t\tscanId = None"]], "deleted": []}, "added_lines": 2, "deleted_lines": 0, "source_code": "#!/usr/bin/python\nimport os, sys, MySQLdb, time\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../../\")\nimport credentials\n\ntry:\n\tdomain = sys.argv[1].strip()\n\tscanId = sys.argv[2]\n\n\tif not os.path.exists(\"/tmp/ICU\"):\n\t\tos.makedirs(\"/tmp/ICU\")\n\n\tif not os.path.exists(\"/tmp/ICU/\"+domain+\"/\"):\n\t    os.makedirs(\"/tmp/ICU/\"+domain+\"/\")\n\n\t#Add new subdomain scanners here. Make sure to let them save the output to /tmp/ICU/{domain}/doains-all.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n\ttime.sleep(2)\n\n\ttry:\n\t\t#Subfinder\n\t\tos.system(\"subfinder -d \" + domain + \" -v -o /tmp/ICU/\"+domain+\"/domains-subfinder.txt --timeout 6\")\n\t\ttime.sleep(2)\n\n\t\t#Amass\n\t\tos.system(\"amass -o /tmp/ICU/\"+domain+\"/domains-amass.txt -d \" + domain)\n        \ttime.sleep(2)\n\texcept Exception as e:\n\t\tprint \"An error occured; You probably dont have either subfinder or amass installed. Check the README.md to see you how to install them. Error: \"\n\t\tprint str(e)\n\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor()\n\n\t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on\n\tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n\tdatabase_data = cursor.fetchall()\n\tdatabase_domains = [d[0] for d in database_data]\n\n        non_active_subdomains = [x[0] for x in database_data if ord(x[2]) == False]\n        program = [x[3] for x in database_data if x[0] == domain][0]\n        topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n\n\t#All the domains from the subdomain scanners\n\tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n\n\ttry:\n\t\t#Domains from subfinder\n\t\tdomains_subfinder = open(\"/tmp/ICU/\"+domain+\"/domains-subfinder.txt\",'r').read().split('\\n')\n\n\t        #Domains from amass\n        \tdomains_amass = open(\"/tmp/ICU/\"+domain+\"/domains-amass.txt\",'r').read().split('\\n')\n\n\t        #Add the subfinder domains\n        \tdomains_all.extend(x for x in domains_subfinder if x not in domains_all)\n\n\t\t#unique\n\t\tdomains_all = list(set(domains_all))\n\n\t        #Add the amass domains\n        \tdomains_all.extend(x for x in domains_amass if x not in domains_all)\n\n        \t#unique\n        \tdomains_all = list(set(domains_all))\n        except Exception as e:\n                print \"An error occured; You probably dont have either subfinder or amass installed. Check the README.md to see you how to install them. Error: \"\n                print str(e)\n\n\t#Add all the database subdomain to it\n\tdomains_all.extend(x for x in database_domains if x not in domains_all)\n\n\t#unique -- Unique each time after adding a new list, to limit ram usage\n\tdomains_all = list(set(domains_all))\n\n\t#Put all the online domains in a domains-online.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")\n\n\t#Convert online domains to array\n\tdomains_online = open(\"/tmp/ICU/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n\n\t#Loop through every subdomain\n\tfor sub_domain in domains_all:\n\t\t#Get the scanID to insert. If the domains was already in the db and isnt changed, then keep the old scanID. otherwise use the scanID of the current scan\n\t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n\n\t\t#If the subdomain is online\n\t\tif sub_domain in domains_online:\n\t\t\tactive=True\n\t\t\t#If the subdomain used to be offline, give it the current scanID\n\t\t\tif sub_domain in non_active_subdomains:\n\t\t\t\tinsertScanId = scanId\n\t\telse:\n\t\t\tactive=False\n\n\n\t\tif sub_domain:\n\t\t\t#Insert the new values, or update them if they already existed\n\t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))\n\t\t\tconnection.commit()\n\n\tcursor.close ()\n\tconnection.close ()\nexcept Exception as e:\n\t#Handle the errors, and save them to the database\n\tprint \"error in domains_db.py with main domain; \" + domain\n\tif scanId == \"NULL\":\n\t\tscanId = None\n\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in domains_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n\tconnection.commit()\n\tcursor.close()\n\tconnection.close()\n\tprint e\nsys.exit()\n", "source_code_before": "#!/usr/bin/python\nimport os, sys, MySQLdb, time\nsys.path.append(os.path.dirname(os.path.abspath(__file__)) + \"/../../\")\nimport credentials\n\ntry:\n\tdomain = sys.argv[1].strip()\n\tscanId = sys.argv[2]\n\n\tif not os.path.exists(\"/tmp/ICU\"):\n\t\tos.makedirs(\"/tmp/ICU\")\n\n\tif not os.path.exists(\"/tmp/ICU/\"+domain+\"/\"):\n\t    os.makedirs(\"/tmp/ICU/\"+domain+\"/\")\n\n\t#Add new subdomain scanners here. Make sure to let them save the output to /tmp/ICU/{domain}/doains-all.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/dependencies/sublister/sublist3r.py -o /tmp/ICU/\"+domain+\"/domains-all.txt -d \"+domain)\n\ttime.sleep(2)\n\n\ttry:\n\t\t#Subfinder\n\t\tos.system(\"subfinder -d \" + domain + \" -v -o /tmp/ICU/\"+domain+\"/domains-subfinder.txt --timeout 6\")\n\t\ttime.sleep(2)\n\n\t\t#Amass\n\t\tos.system(\"amass -o /tmp/ICU/\"+domain+\"/domains-amass.txt -d \" + domain)\n        \ttime.sleep(2)\n\texcept Exception as e:\n\t\tprint \"An error occured; You probably dont have either subfinder or amass installed. Check the README.md to see you how to install them. Error: \"\n\t\tprint str(e)\n\n\n\tconnection = MySQLdb.connect (host = credentials.database_server, user = credentials.database_username, passwd = credentials.database_password, db = credentials.database_name)\n\tcursor = connection.cursor()\n\n\t#Retrieve all info from a top domain and its subdomains, so we can use this data instead of opening new db connections later on\n\tcursor.execute(\"select Domain, TopDomainID, Active, Program, DomainID, scan_Id from domains where TopDomainID = (select DomainID from domains where Domain = %s) or Domain = %s\", (domain, domain))\n\tdatabase_data = cursor.fetchall()\n\tdatabase_domains = [d[0] for d in database_data]\n\n        non_active_subdomains = [x[0] for x in database_data if ord(x[2]) == False]\n        program = [x[3] for x in database_data if x[0] == domain][0]\n        topDomainID = [x[4] for x in database_data if x[0] == domain][0]\n\n\t#All the domains from the subdomain scanners\n\tdomains_all = open(\"/tmp/ICU/\"+domain+\"/domains-all.txt\",'r').read().split('\\n')\n\n\ttry:\n\t\t#Domains from subfinder\n\t\tdomains_subfinder = open(\"/tmp/ICU/\"+domain+\"/domains-subfinder.txt\",'r').read().split('\\n')\n\n\t        #Domains from amass\n        \tdomains_amass = open(\"/tmp/ICU/\"+domain+\"/domains-amass.txt\",'r').read().split('\\n')\n\n\t        #Add the subfinder domains\n        \tdomains_all.extend(x for x in domains_subfinder if x not in domains_all)\n\n\t\t#unique\n\t\tdomains_all = list(set(domains_all))\n\n\t        #Add the amass domains\n        \tdomains_all.extend(x for x in domains_amass if x not in domains_all)\n\n        \t#unique\n        \tdomains_all = list(set(domains_all))\n        except Exception as e:\n                print \"An error occured; You probably dont have either subfinder or amass installed. Check the README.md to see you how to install them. Error: \"\n                print str(e)\n\n\t#Add all the database subdomain to it\n\tdomains_all.extend(x for x in database_domains if x not in domains_all)\n\n\t#unique -- Unique each time after adding a new list, to limit ram usage\n\tdomains_all = list(set(domains_all))\n\n\t#Put all the online domains in a domains-online.txt\n\tos.system(os.path.dirname(os.path.abspath(__file__)) + \"/../../tools/online.py /tmp/ICU/\"+domain+\"/domains-all.txt /tmp/ICU/\"+domain+\"/domains-online.txt\")\n\n\t#Convert online domains to array\n\tdomains_online = open(\"/tmp/ICU/\"+domain+\"/domains-online.txt\",'r').read().split('\\n')\n\n\t#Loop through every subdomain\n\tfor sub_domain in domains_all:\n\t\t#Get the scanID to insert. If the domains was already in the db and isnt changed, then keep the old scanID. otherwise use the scanID of the current scan\n\t        insertScanId = scanId if not [x[5] for x in database_data if x[0] == sub_domain] else [x[5] for x in database_data if x[0] == sub_domain][0]\n\n\t\t#If the subdomain is online\n\t\tif sub_domain in domains_online:\n\t\t\tactive=True\n\t\t\t#If the subdomain used to be offline, give it the current scanID\n\t\t\tif sub_domain in non_active_subdomains:\n\t\t\t\tinsertScanId = scanId\n\t\telse:\n\t\t\tactive=False\n\n\n\t\tif sub_domain:\n\t\t\t#Insert the new values, or update them if they already existed\n\t\t\tcursor.execute(\"INSERT INTO domains (Program, TopDomainID, Active, InScope, Domain, scan_Id) VALUES (%s, %s, %s, %s, %s, %s) ON DUPLICATE KEY UPDATE Active = %s, LastModified = now(), scan_Id = %s\", (program, topDomainID, active, 1, sub_domain, insertScanId, active, insertScanId))\n\t\t\tconnection.commit()\n\n\tcursor.close ()\n\tconnection.close ()\nexcept Exception as e:\n\t#Handle the errors, and save them to the database\n\tprint \"error in domains_db.py with main domain; \" + domain\n\tcursor.execute(\"INSERT INTO errors (Domain, ErrorDescription, Error, Script, scan_Id) VALUES (%s, %s, %s, %s, %s) \", (domain, \"error in domains_db.py with main domain; \"+domain, e, \"sublister_to_db.py\", scanId))\n\tconnection.commit()\n\tcursor.close()\n\tconnection.close()\n\tprint e\nsys.exit()\n", "methods": [], "methods_before": [], "changed_methods": [], "nloc": 66, "complexity": 0, "token_count": 688}], "dmm_unit_size": null, "dmm_unit_complexity": null, "dmm_unit_interfacing": null}
  ],
  "process_metrics": {
  "Week_1_2018-03-29": {
    "productivity": {
      "change_set": {
        "max": 0,
        "avg": 0
      },
      "commits_count": {},
      "contributors_count": {
        "total": {},
        "minor": {}
      },
      "contributors_experience": {},
      "hunks_count": {},
      "lines_count": {
        "added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "removed": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_removed": {
          "total": {},
          "max": {},
          "avg": {}
        }
      }
    },
    "quality": {
      "code_churn": {
        "total_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "net_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "added_removed": {
          "added": 0,
          "removed": 0
        },
        "true_churn": {
          "overall": {
            "contribution": 0,
            "churn": 0
          },
          "per_author": {},
          "per_file": {}
        }
      },
      "bugs": {
        "bug_work_percent_by_file": {},
        "overall_bug_work_percent": 0,
        "total_bug_lines": 0,
        "total_lines": 0
      },
      "code_movement": {
        "moved_lines_count": 0,
        "copy_pasted_lines_count": 0,
        "total_changed_lines": 0,
        "moved_lines_percent": 0,
        "copy_pasted_lines_percent": 0
      },
      "test_doc_pct": {
        "test_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "doc_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "total": {
          "files": 0,
          "lines": 0
        },
        "quality_score": 0.0
      },
      "meaningful_code": {
        "total": {
          "files": 0,
          "lines": 0,
          "meaningful_lines": 0,
          "meaningful_percent": 0
        },
        "quality_score": 0.0,
        "unrealistic_commits": {
          "large_commits": 0,
          "rapid_large_commits": 0,
          "total": 0,
          "skipped_lines": 0
        },
        "auto_generated": {
          "long_sequences": 0,
          "repeated_chars": 0,
          "repetitive_patterns": 0,
          "total": 0,
          "percent": 0
        }
      }
    },
    "timings": {
      "diff_delta": {},
      "code_provenance": {},
      "developer_hours": {},
      "code_domain": {},
      "comprehensive_time_analysis": {}
    }
  },
  "Week_2_2018-04-05": {
    "productivity": {
      "change_set": {
        "max": 0,
        "avg": 0
      },
      "commits_count": {},
      "contributors_count": {
        "total": {},
        "minor": {}
      },
      "contributors_experience": {},
      "hunks_count": {},
      "lines_count": {
        "added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "removed": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_removed": {
          "total": {},
          "max": {},
          "avg": {}
        }
      }
    },
    "quality": {
      "code_churn": {
        "total_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "net_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "added_removed": {
          "added": 0,
          "removed": 0
        },
        "true_churn": {
          "overall": {
            "contribution": 0,
            "churn": 0
          },
          "per_author": {},
          "per_file": {}
        }
      },
      "bugs": {
        "bug_work_percent_by_file": {},
        "overall_bug_work_percent": 0,
        "total_bug_lines": 0,
        "total_lines": 0
      },
      "code_movement": {
        "moved_lines_count": 0,
        "copy_pasted_lines_count": 0,
        "total_changed_lines": 0,
        "moved_lines_percent": 0,
        "copy_pasted_lines_percent": 0
      },
      "test_doc_pct": {
        "test_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "doc_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "total": {
          "files": 0,
          "lines": 0
        },
        "quality_score": 0.0
      },
      "meaningful_code": {
        "total": {
          "files": 0,
          "lines": 0,
          "meaningful_lines": 0,
          "meaningful_percent": 0
        },
        "quality_score": 0.0,
        "unrealistic_commits": {
          "large_commits": 0,
          "rapid_large_commits": 0,
          "total": 0,
          "skipped_lines": 0
        },
        "auto_generated": {
          "long_sequences": 0,
          "repeated_chars": 0,
          "repetitive_patterns": 0,
          "total": 0,
          "percent": 0
        }
      }
    },
    "timings": {
      "diff_delta": {},
      "code_provenance": {},
      "developer_hours": {},
      "code_domain": {},
      "comprehensive_time_analysis": {}
    }
  },
  "Week_3_2018-04-12": {
    "productivity": {
      "change_set": {
        "max": 0,
        "avg": 0
      },
      "commits_count": {},
      "contributors_count": {
        "total": {},
        "minor": {}
      },
      "contributors_experience": {},
      "hunks_count": {},
      "lines_count": {
        "added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "removed": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_removed": {
          "total": {},
          "max": {},
          "avg": {}
        }
      }
    },
    "quality": {
      "code_churn": {
        "total_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "net_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "added_removed": {
          "added": 0,
          "removed": 0
        },
        "true_churn": {
          "overall": {
            "contribution": 0,
            "churn": 0
          },
          "per_author": {},
          "per_file": {}
        }
      },
      "bugs": {
        "bug_work_percent_by_file": {},
        "overall_bug_work_percent": 0,
        "total_bug_lines": 0,
        "total_lines": 0
      },
      "code_movement": {
        "moved_lines_count": 0,
        "copy_pasted_lines_count": 0,
        "total_changed_lines": 0,
        "moved_lines_percent": 0,
        "copy_pasted_lines_percent": 0
      },
      "test_doc_pct": {
        "test_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "doc_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "total": {
          "files": 0,
          "lines": 0
        },
        "quality_score": 0.0
      },
      "meaningful_code": {
        "total": {
          "files": 0,
          "lines": 0,
          "meaningful_lines": 0,
          "meaningful_percent": 0
        },
        "quality_score": 0.0,
        "unrealistic_commits": {
          "large_commits": 0,
          "rapid_large_commits": 0,
          "total": 0,
          "skipped_lines": 0
        },
        "auto_generated": {
          "long_sequences": 0,
          "repeated_chars": 0,
          "repetitive_patterns": 0,
          "total": 0,
          "percent": 0
        }
      }
    },
    "timings": {
      "diff_delta": {},
      "code_provenance": {},
      "developer_hours": {},
      "code_domain": {},
      "comprehensive_time_analysis": {}
    }
  },
  "Week_4_2018-04-19": {
    "productivity": {
      "change_set": {
        "max": 0,
        "avg": 0
      },
      "commits_count": {},
      "contributors_count": {
        "total": {},
        "minor": {}
      },
      "contributors_experience": {},
      "hunks_count": {},
      "lines_count": {
        "added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "removed": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_removed": {
          "total": {},
          "max": {},
          "avg": {}
        }
      }
    },
    "quality": {
      "code_churn": {
        "total_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "net_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "added_removed": {
          "added": 0,
          "removed": 0
        },
        "true_churn": {
          "overall": {
            "contribution": 0,
            "churn": 0
          },
          "per_author": {},
          "per_file": {}
        }
      },
      "bugs": {
        "bug_work_percent_by_file": {},
        "overall_bug_work_percent": 0,
        "total_bug_lines": 0,
        "total_lines": 0
      },
      "code_movement": {
        "moved_lines_count": 0,
        "copy_pasted_lines_count": 0,
        "total_changed_lines": 0,
        "moved_lines_percent": 0,
        "copy_pasted_lines_percent": 0
      },
      "test_doc_pct": {
        "test_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "doc_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "total": {
          "files": 0,
          "lines": 0
        },
        "quality_score": 0.0
      },
      "meaningful_code": {
        "total": {
          "files": 0,
          "lines": 0,
          "meaningful_lines": 0,
          "meaningful_percent": 0
        },
        "quality_score": 0.0,
        "unrealistic_commits": {
          "large_commits": 0,
          "rapid_large_commits": 0,
          "total": 0,
          "skipped_lines": 0
        },
        "auto_generated": {
          "long_sequences": 0,
          "repeated_chars": 0,
          "repetitive_patterns": 0,
          "total": 0,
          "percent": 0
        }
      }
    },
    "timings": {
      "diff_delta": {},
      "code_provenance": {},
      "developer_hours": {},
      "code_domain": {},
      "comprehensive_time_analysis": {}
    }
  },
  "Week_5_2018-04-26": {
    "productivity": {
      "change_set": {
        "max": 0,
        "avg": 0
      },
      "commits_count": {},
      "contributors_count": {
        "total": {},
        "minor": {}
      },
      "contributors_experience": {},
      "hunks_count": {},
      "lines_count": {
        "added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "removed": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_removed": {
          "total": {},
          "max": {},
          "avg": {}
        }
      }
    },
    "quality": {
      "code_churn": {
        "total_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "net_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "added_removed": {
          "added": 0,
          "removed": 0
        },
        "true_churn": {
          "overall": {
            "contribution": 0,
            "churn": 0
          },
          "per_author": {},
          "per_file": {}
        }
      },
      "bugs": {
        "bug_work_percent_by_file": {},
        "overall_bug_work_percent": 0,
        "total_bug_lines": 0,
        "total_lines": 0
      },
      "code_movement": {
        "moved_lines_count": 0,
        "copy_pasted_lines_count": 0,
        "total_changed_lines": 0,
        "moved_lines_percent": 0,
        "copy_pasted_lines_percent": 0
      },
      "test_doc_pct": {
        "test_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "doc_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "total": {
          "files": 0,
          "lines": 0
        },
        "quality_score": 0.0
      },
      "meaningful_code": {
        "total": {
          "files": 0,
          "lines": 0,
          "meaningful_lines": 0,
          "meaningful_percent": 0
        },
        "quality_score": 0.0,
        "unrealistic_commits": {
          "large_commits": 0,
          "rapid_large_commits": 0,
          "total": 0,
          "skipped_lines": 0
        },
        "auto_generated": {
          "long_sequences": 0,
          "repeated_chars": 0,
          "repetitive_patterns": 0,
          "total": 0,
          "percent": 0
        }
      }
    },
    "timings": {
      "diff_delta": {},
      "code_provenance": {},
      "developer_hours": {},
      "code_domain": {},
      "comprehensive_time_analysis": {}
    }
  },
  "Week_6_2018-05-03": {
    "productivity": {
      "change_set": {
        "max": 0,
        "avg": 0
      },
      "commits_count": {},
      "contributors_count": {
        "total": {},
        "minor": {}
      },
      "contributors_experience": {},
      "hunks_count": {},
      "lines_count": {
        "added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "removed": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_removed": {
          "total": {},
          "max": {},
          "avg": {}
        }
      }
    },
    "quality": {
      "code_churn": {
        "total_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "net_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "added_removed": {
          "added": 0,
          "removed": 0
        },
        "true_churn": {
          "overall": {
            "contribution": 0,
            "churn": 0
          },
          "per_author": {},
          "per_file": {}
        }
      },
      "bugs": {
        "bug_work_percent_by_file": {},
        "overall_bug_work_percent": 0,
        "total_bug_lines": 0,
        "total_lines": 0
      },
      "code_movement": {
        "moved_lines_count": 0,
        "copy_pasted_lines_count": 0,
        "total_changed_lines": 0,
        "moved_lines_percent": 0,
        "copy_pasted_lines_percent": 0
      },
      "test_doc_pct": {
        "test_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "doc_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "total": {
          "files": 0,
          "lines": 0
        },
        "quality_score": 0.0
      },
      "meaningful_code": {
        "total": {
          "files": 0,
          "lines": 0,
          "meaningful_lines": 0,
          "meaningful_percent": 0
        },
        "quality_score": 0.0,
        "unrealistic_commits": {
          "large_commits": 0,
          "rapid_large_commits": 0,
          "total": 0,
          "skipped_lines": 0
        },
        "auto_generated": {
          "long_sequences": 0,
          "repeated_chars": 0,
          "repetitive_patterns": 0,
          "total": 0,
          "percent": 0
        }
      }
    },
    "timings": {
      "diff_delta": {},
      "code_provenance": {},
      "developer_hours": {},
      "code_domain": {},
      "comprehensive_time_analysis": {}
    }
  },
  "Week_7_2018-05-10": {
    "productivity": {
      "change_set": {
        "max": 0,
        "avg": 0
      },
      "commits_count": {},
      "contributors_count": {
        "total": {},
        "minor": {}
      },
      "contributors_experience": {},
      "hunks_count": {},
      "lines_count": {
        "added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "removed": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_removed": {
          "total": {},
          "max": {},
          "avg": {}
        }
      }
    },
    "quality": {
      "code_churn": {
        "total_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "net_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "added_removed": {
          "added": 0,
          "removed": 0
        },
        "true_churn": {
          "overall": {
            "contribution": 0,
            "churn": 0
          },
          "per_author": {},
          "per_file": {}
        }
      },
      "bugs": {
        "bug_work_percent_by_file": {},
        "overall_bug_work_percent": 0,
        "total_bug_lines": 0,
        "total_lines": 0
      },
      "code_movement": {
        "moved_lines_count": 0,
        "copy_pasted_lines_count": 0,
        "total_changed_lines": 0,
        "moved_lines_percent": 0,
        "copy_pasted_lines_percent": 0
      },
      "test_doc_pct": {
        "test_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "doc_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "total": {
          "files": 0,
          "lines": 0
        },
        "quality_score": 0.0
      },
      "meaningful_code": {
        "total": {
          "files": 0,
          "lines": 0,
          "meaningful_lines": 0,
          "meaningful_percent": 0
        },
        "quality_score": 0.0,
        "unrealistic_commits": {
          "large_commits": 0,
          "rapid_large_commits": 0,
          "total": 0,
          "skipped_lines": 0
        },
        "auto_generated": {
          "long_sequences": 0,
          "repeated_chars": 0,
          "repetitive_patterns": 0,
          "total": 0,
          "percent": 0
        }
      }
    },
    "timings": {
      "diff_delta": {},
      "code_provenance": {},
      "developer_hours": {},
      "code_domain": {},
      "comprehensive_time_analysis": {}
    }
  },
  "Week_8_2018-05-17": {
    "productivity": {
      "change_set": {
        "max": 0,
        "avg": 0
      },
      "commits_count": {},
      "contributors_count": {
        "total": {},
        "minor": {}
      },
      "contributors_experience": {},
      "hunks_count": {},
      "lines_count": {
        "added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "removed": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_removed": {
          "total": {},
          "max": {},
          "avg": {}
        }
      }
    },
    "quality": {
      "code_churn": {
        "total_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "net_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "added_removed": {
          "added": 0,
          "removed": 0
        },
        "true_churn": {
          "overall": {
            "contribution": 0,
            "churn": 0
          },
          "per_author": {},
          "per_file": {}
        }
      },
      "bugs": {
        "bug_work_percent_by_file": {},
        "overall_bug_work_percent": 0,
        "total_bug_lines": 0,
        "total_lines": 0
      },
      "code_movement": {
        "moved_lines_count": 0,
        "copy_pasted_lines_count": 0,
        "total_changed_lines": 0,
        "moved_lines_percent": 0,
        "copy_pasted_lines_percent": 0
      },
      "test_doc_pct": {
        "test_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "doc_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "total": {
          "files": 0,
          "lines": 0
        },
        "quality_score": 0.0
      },
      "meaningful_code": {
        "total": {
          "files": 0,
          "lines": 0,
          "meaningful_lines": 0,
          "meaningful_percent": 0
        },
        "quality_score": 0.0,
        "unrealistic_commits": {
          "large_commits": 0,
          "rapid_large_commits": 0,
          "total": 0,
          "skipped_lines": 0
        },
        "auto_generated": {
          "long_sequences": 0,
          "repeated_chars": 0,
          "repetitive_patterns": 0,
          "total": 0,
          "percent": 0
        }
      }
    },
    "timings": {
      "diff_delta": {},
      "code_provenance": {},
      "developer_hours": {},
      "code_domain": {},
      "comprehensive_time_analysis": {}
    }
  },
  "Week_9_2018-05-24": {
    "productivity": {
      "change_set": {
        "max": 9,
        "avg": 3.5
      },
      "commits_count": {
        "install.sh": 3,
        "telegram/bot.py": 2,
        "database/additional_tools/sublister_to_db.py": 1,
        "database/db_test.py": 2,
        "database/init_db.py": 1,
        "main.py": 1,
        "run.py": 1,
        "tools/dependencies/sublister": 1,
        "tools/online.py": 1,
        "README.md": 1
      },
      "contributors_count": {
        "total": {
          "install.sh": 1,
          "telegram/bot.py": 1,
          "database/additional_tools/sublister_to_db.py": 1,
          "database/db_test.py": 1,
          "database/init_db.py": 1,
          "main.py": 1,
          "run.py": 1,
          "tools/dependencies/sublister": 1,
          "tools/online.py": 1,
          "README.md": 1
        },
        "minor": {
          "install.sh": 0,
          "telegram/bot.py": 0,
          "database/additional_tools/sublister_to_db.py": 0,
          "database/db_test.py": 0,
          "database/init_db.py": 0,
          "main.py": 0,
          "run.py": 0,
          "tools/dependencies/sublister": 0,
          "tools/online.py": 0,
          "README.md": 0
        }
      },
      "contributors_experience": {
        "install.sh": 1,
        "telegram/bot.py": 1,
        "database/additional_tools/sublister_to_db.py": 1,
        "database/db_test.py": 1,
        "database/init_db.py": 1,
        "main.py": 1,
        "run.py": 1,
        "tools/dependencies/sublister": 1,
        "tools/online.py": 1,
        "README.md": 1
      },
      "hunks_count": {
        "install.sh": 1,
        "telegram/bot.py": 4.0,
        "database/additional_tools/sublister_to_db.py": 6,
        "database/db_test.py": 4.0,
        "database/init_db.py": 7,
        "main.py": 4,
        "run.py": 6,
        "tools/dependencies/sublister": 1,
        "tools/online.py": 1,
        "README.md": 1
      },
      "lines_count": {
        "added": {
          "total": {
            "install.sh": 33,
            "telegram/bot.py": 52,
            "database/additional_tools/sublister_to_db.py": 12,
            "database/db_test.py": 38,
            "database/init_db.py": 23,
            "main.py": 25,
            "run.py": 23,
            "tools/dependencies/sublister": 1,
            "tools/online.py": 45,
            "README.md": 1
          },
          "max": {
            "install.sh": 20,
            "telegram/bot.py": 48,
            "database/additional_tools/sublister_to_db.py": 12,
            "database/db_test.py": 32,
            "database/init_db.py": 23,
            "main.py": 25,
            "run.py": 23,
            "tools/dependencies/sublister": 1,
            "tools/online.py": 45,
            "README.md": 1
          },
          "avg": {
            "install.sh": 11,
            "telegram/bot.py": 26,
            "database/additional_tools/sublister_to_db.py": 12,
            "database/db_test.py": 19,
            "database/init_db.py": 23,
            "main.py": 25,
            "run.py": 23,
            "tools/dependencies/sublister": 1,
            "tools/online.py": 45,
            "README.md": 1
          }
        },
        "removed": {
          "total": {
            "install.sh": 9,
            "telegram/bot.py": 11,
            "database/additional_tools/sublister_to_db.py": 8,
            "database/db_test.py": 11,
            "database/init_db.py": 45,
            "main.py": 1,
            "run.py": 19,
            "tools/dependencies/sublister": 0,
            "tools/online.py": 0,
            "README.md": 0
          },
          "max": {
            "install.sh": 8,
            "telegram/bot.py": 10,
            "database/additional_tools/sublister_to_db.py": 8,
            "database/db_test.py": 6,
            "database/init_db.py": 45,
            "main.py": 1,
            "run.py": 19,
            "tools/dependencies/sublister": 0,
            "tools/online.py": 0,
            "README.md": 0
          },
          "avg": {
            "install.sh": 3,
            "telegram/bot.py": 6,
            "database/additional_tools/sublister_to_db.py": 8,
            "database/db_test.py": 6,
            "database/init_db.py": 45,
            "main.py": 1,
            "run.py": 19,
            "tools/dependencies/sublister": 0,
            "tools/online.py": 0,
            "README.md": 0
          }
        },
        "noop_added": {
          "total": {
            "install.sh": 5,
            "telegram/bot.py": 4,
            "database/additional_tools/sublister_to_db.py": 1,
            "database/db_test.py": 5,
            "database/init_db.py": 4,
            "main.py": 9,
            "run.py": 0,
            "tools/dependencies/sublister": 0,
            "tools/online.py": 9,
            "README.md": 0
          },
          "max": {
            "install.sh": 4,
            "telegram/bot.py": 2,
            "database/additional_tools/sublister_to_db.py": 1,
            "database/db_test.py": 5,
            "database/init_db.py": 4,
            "main.py": 9,
            "run.py": 0,
            "tools/dependencies/sublister": 0,
            "tools/online.py": 9,
            "README.md": 0
          },
          "avg": {
            "install.sh": 2,
            "telegram/bot.py": 2,
            "database/additional_tools/sublister_to_db.py": 1,
            "database/db_test.py": 2,
            "database/init_db.py": 4,
            "main.py": 9,
            "run.py": 0,
            "tools/dependencies/sublister": 0,
            "tools/online.py": 9,
            "README.md": 0
          }
        },
        "noop_removed": {
          "total": {
            "install.sh": 0,
            "telegram/bot.py": 0,
            "database/additional_tools/sublister_to_db.py": 0,
            "database/db_test.py": 0,
            "database/init_db.py": 6,
            "main.py": 0,
            "run.py": 1,
            "tools/dependencies/sublister": 0,
            "tools/online.py": 0,
            "README.md": 0
          },
          "max": {
            "install.sh": 0,
            "telegram/bot.py": 0,
            "database/additional_tools/sublister_to_db.py": 0,
            "database/db_test.py": 0,
            "database/init_db.py": 6,
            "main.py": 0,
            "run.py": 1,
            "tools/dependencies/sublister": 0,
            "tools/online.py": 0,
            "README.md": 0
          },
          "avg": {
            "install.sh": 0,
            "telegram/bot.py": 0,
            "database/additional_tools/sublister_to_db.py": 0,
            "database/db_test.py": 0,
            "database/init_db.py": 6,
            "main.py": 0,
            "run.py": 1,
            "tools/dependencies/sublister": 0,
            "tools/online.py": 0,
            "README.md": 0
          }
        }
      }
    },
    "quality": {
      "code_churn": {
        "total_churn": {
          "count": 357,
          "max": 68,
          "avg": 36
        },
        "net_churn": {
          "count": 149,
          "max": 45,
          "avg": 15
        },
        "added_removed": {
          "added": 253,
          "removed": 104
        },
        "true_churn": {
          "overall": {
            "contribution": 253,
            "churn": 32
          },
          "per_author": {
            "RJP": {
              "contribution": 253,
              "churn": 32
            }
          },
          "per_file": {
            "install.sh": {
              "contribution": 33,
              "churn": 9
            },
            "telegram/bot.py": {
              "contribution": 52,
              "churn": 2
            },
            "database/additional_tools/sublister_to_db.py": {
              "contribution": 12,
              "churn": 1
            },
            "database/db_test.py": {
              "contribution": 38,
              "churn": 8
            },
            "database/init_db.py": {
              "contribution": 23,
              "churn": 1
            },
            "main.py": {
              "contribution": 25,
              "churn": 0
            },
            "run.py": {
              "contribution": 23,
              "churn": 11
            },
            "tools/dependencies/sublister": {
              "contribution": 1,
              "churn": 0
            },
            "tools/online.py": {
              "contribution": 45,
              "churn": 0
            },
            "README.md": {
              "contribution": 1,
              "churn": 0
            }
          }
        }
      },
      "bugs": {
        "bug_work_percent_by_file": {
          "install.sh": 0.0,
          "telegram/bot.py": 0.0,
          "database/additional_tools/sublister_to_db.py": 0.0,
          "database/db_test.py": 0.0,
          "database/init_db.py": 0.0,
          "main.py": 0.0,
          "run.py": 0.0,
          "tools/dependencies/sublister": 0.0,
          "tools/online.py": 0.0,
          "README.md": 0.0
        },
        "overall_bug_work_percent": 0.0,
        "total_bug_lines": 0,
        "total_lines": 357
      },
      "code_movement": {
        "moved_lines_count": 9,
        "copy_pasted_lines_count": 23,
        "total_changed_lines": 288,
        "moved_lines_percent": 3.125,
        "copy_pasted_lines_percent": 7.986111111111111
      },
      "test_doc_pct": {
        "test_coverage": {
          "files": 1,
          "lines": 96,
          "percent": 7.5
        },
        "doc_coverage": {
          "files": 1,
          "lines": 138,
          "percent": 10.78125
        },
        "total": {
          "files": 10,
          "lines": 1280
        },
        "quality_score": 9.140625
      },
      "meaningful_code": {
        "total": {
          "files": 10,
          "lines": 1280,
          "meaningful_lines": 917,
          "meaningful_percent": 71.640625
        },
        "quality_score": 9.140625,
        "unrealistic_commits": {
          "large_commits": 0,
          "rapid_large_commits": 0,
          "total": 0,
          "skipped_lines": 357
        },
        "auto_generated": {
          "long_sequences": 0,
          "repeated_chars": 3,
          "repetitive_patterns": 0,
          "total": 3,
          "percent": 0.234375
        }
      }
    },
    "timings": {
      "diff_delta": {
        "rjp@debian8svm.debian8svm": {
          "total_diff_delta": 218.29999999999998,
          "total_commits": 4,
          "weekly_velocity": {
            "2018-05-21": {
              "diff_delta": 218.29999999999998,
              "lines_added": 166,
              "lines_updated": 42,
              "lines_deleted": 74,
              "lines_moved": 23,
              "commits": 4,
              "files_changed": 10,
              "active_days": 2,
              "velocity_per_day": 109.14999999999999
            }
          }
        }
      },
      "code_provenance": {
        "rjp@debian8svm.debian8svm": {
          "weekly_provenance": {
            "2018-05-21": {
              "new_code_lines": 130,
              "recent_code_lines": 0,
              "old_code_lines": 54,
              "legacy_code_lines": 0,
              "total_lines": 184,
              "new_code_percent": 70.65217391304348,
              "recent_code_percent": 0.0,
              "old_code_percent": 29.347826086956523,
              "legacy_code_percent": 0.0
            }
          }
        }
      },
      "developer_hours": {
        "rjp@debian8svm.debian8svm": {
          "total_estimated_hours": 1.5416666666666665,
          "total_sessions": 2,
          "weekly_hours": {
            "2018-W21": {
              "estimated_hours": 1.54,
              "sessions": 2,
              "commits": 4,
              "hours_per_day": 0.77
            }
          }
        }
      },
      "code_domain": {
        "rjp@debian8svm.debian8svm": {
          "total_by_domain": {
            "devops": 42,
            "backend": 313,
            "other": 1,
            "docs": 1
          },
          "weekly_domains": {
            "2018-05-21": {
              "domains": {
                "devops": 42,
                "backend": 313,
                "other": 1,
                "docs": 1
              },
              "total_changes": 357,
              "percentages": {
                "devops": 11.76470588235294,
                "backend": 87.6750700280112,
                "other": 0.2801120448179272,
                "docs": 0.2801120448179272
              }
            }
          },
          "domain_percentages": {
            "devops": 11.76470588235294,
            "backend": 87.6750700280112,
            "other": 0.2801120448179272,
            "docs": 0.2801120448179272
          }
        }
      },
      "comprehensive_time_analysis": {
        "rjp@debian8svm.debian8svm": {
          "basic_stats": {
            "total_commits": 4,
            "total_repos": 1,
            "first_commit_date": "2018-05-26T21:45:08+02:00",
            "last_commit_date": "2018-05-27T02:57:12+02:00",
            "total_span_days": 0.22,
            "commits_per_day": 4.0,
            "total_lines_changed": 357,
            "total_files_changed": 14
          },
          "timing_patterns": {
            "mean_interval_hours": 1.73,
            "median_interval_hours": 0.19,
            "min_interval_minutes": 2.22,
            "max_interval_days": 0.21
          },
          "work_sessions": {
            "session_count": 2,
            "avg_session_length_hours": 0.11,
            "max_session_length_hours": 0.23,
            "avg_commits_per_session": 2,
            "max_commits_per_session": 3,
            "sessions": [
              {
                "start": "2018-05-26T21:45:08+02:00",
                "end": "2018-05-26T21:45:08+02:00",
                "length_hours": 0.0,
                "commits": 1
              },
              {
                "start": "2018-05-27T02:43:27+02:00",
                "end": "2018-05-27T02:57:12+02:00",
                "length_hours": 0.23,
                "commits": 3
              }
            ]
          },
          "daily_patterns": {
            "peak_day": 6,
            "peak_day_count": 3,
            "day_distribution": {
              "5": 1,
              "6": 3
            }
          },
          "weekly_patterns": {
            "total_weeks": 2,
            "avg_activities_per_week": 2,
            "max_activities_per_week": 3,
            "min_activities_per_week": 1
          },
          "downtime_analysis": {
            "short_breaks_count": 2,
            "long_breaks_count": 0,
            "avg_break_hours": 1.7337037037037035
          },
          "rhythm_analysis": {
            "activities_per_day": 4.0,
            "consistency_score": 0.0
          },
          "sustained_activity": {
            "total_active_days": 2,
            "max_consecutive_days": 2,
            "avg_activities_per_active_day": 2.0
          }
        }
      }
    }
  },
  "Week_10_2018-05-31": {
    "productivity": {
      "change_set": {
        "max": 6,
        "avg": 1.8
      },
      "commits_count": {
        "logs/run_logs.txt": 2,
        "null": 4,
        "README.md": 6,
        "credentials.py": 1,
        "credentials.pyc": 2,
        "database/additional_tools/domains_db.py": 4,
        "tools/dependencies/sublister": 1,
        "main.py": 1,
        "install.sh": 1,
        "web/setup.sh": 2,
        "telegram/setup.py": 1,
        "run.py": 1,
        "tools/online.py": 1
      },
      "contributors_count": {
        "total": {
          "logs/run_logs.txt": 1,
          "null": 1,
          "README.md": 2,
          "credentials.py": 1,
          "database/additional_tools/domains_db.py": 1,
          "tools/dependencies/sublister": 1,
          "main.py": 1,
          "install.sh": 1,
          "web/setup.sh": 1,
          "telegram/setup.py": 1,
          "run.py": 1,
          "tools/online.py": 1
        },
        "minor": {
          "logs/run_logs.txt": 0,
          "null": 0,
          "README.md": 0,
          "credentials.py": 0,
          "database/additional_tools/domains_db.py": 0,
          "tools/dependencies/sublister": 0,
          "main.py": 0,
          "install.sh": 0,
          "web/setup.sh": 0,
          "telegram/setup.py": 0,
          "run.py": 0,
          "tools/online.py": 0
        }
      },
      "contributors_experience": {
        "logs/run_logs.txt": 1,
        "null": 1,
        "README.md": 2,
        "credentials.py": 1,
        "credentials.pyc": 1,
        "database/additional_tools/domains_db.py": 1,
        "tools/dependencies/sublister": 1,
        "main.py": 1,
        "install.sh": 1,
        "web/setup.sh": 1,
        "telegram/setup.py": 1,
        "run.py": 1,
        "tools/online.py": 1
      },
      "hunks_count": {
        "logs/run_logs.txt": 1.0,
        "null": 1.0,
        "README.md": 1.0,
        "credentials.py": 1,
        "credentials.pyc": 0.0,
        "database/additional_tools/domains_db.py": 2.5,
        "tools/dependencies/sublister": 1,
        "main.py": 1,
        "install.sh": 4,
        "web/setup.sh": 1.0,
        "telegram/setup.py": 1,
        "run.py": 1,
        "tools/online.py": 3
      },
      "lines_count": {
        "added": {
          "total": {
            "logs/run_logs.txt": 2,
            "null": 0,
            "README.md": 58,
            "credentials.py": 9,
            "credentials.pyc": 0,
            "database/additional_tools/domains_db.py": 56,
            "tools/dependencies/sublister": 1,
            "main.py": 1,
            "install.sh": 20,
            "web/setup.sh": 318,
            "telegram/setup.py": 2,
            "run.py": 1,
            "tools/online.py": 20
          },
          "max": {
            "logs/run_logs.txt": 1,
            "null": 0,
            "README.md": 21,
            "credentials.py": 9,
            "credentials.pyc": 0,
            "database/additional_tools/domains_db.py": 32,
            "tools/dependencies/sublister": 1,
            "main.py": 1,
            "install.sh": 20,
            "web/setup.sh": 313,
            "telegram/setup.py": 2,
            "run.py": 1,
            "tools/online.py": 20
          },
          "avg": {
            "logs/run_logs.txt": 1,
            "null": 0,
            "README.md": 10,
            "credentials.py": 9,
            "credentials.pyc": 0,
            "database/additional_tools/domains_db.py": 14,
            "tools/dependencies/sublister": 1,
            "main.py": 1,
            "install.sh": 20,
            "web/setup.sh": 159,
            "telegram/setup.py": 2,
            "run.py": 1,
            "tools/online.py": 20
          }
        },
        "removed": {
          "total": {
            "logs/run_logs.txt": 0,
            "null": 12,
            "README.md": 19,
            "credentials.py": 0,
            "credentials.pyc": 0,
            "database/additional_tools/domains_db.py": 19,
            "tools/dependencies/sublister": 0,
            "main.py": 1,
            "install.sh": 1,
            "web/setup.sh": 1,
            "telegram/setup.py": 0,
            "run.py": 1,
            "tools/online.py": 27
          },
          "max": {
            "logs/run_logs.txt": 0,
            "null": 9,
            "README.md": 16,
            "credentials.py": 0,
            "credentials.pyc": 0,
            "database/additional_tools/domains_db.py": 14,
            "tools/dependencies/sublister": 0,
            "main.py": 1,
            "install.sh": 1,
            "web/setup.sh": 1,
            "telegram/setup.py": 0,
            "run.py": 1,
            "tools/online.py": 27
          },
          "avg": {
            "logs/run_logs.txt": 0,
            "null": 3,
            "README.md": 3,
            "credentials.py": 0,
            "credentials.pyc": 0,
            "database/additional_tools/domains_db.py": 5,
            "tools/dependencies/sublister": 0,
            "main.py": 1,
            "install.sh": 1,
            "web/setup.sh": 0,
            "telegram/setup.py": 0,
            "run.py": 1,
            "tools/online.py": 27
          }
        },
        "noop_added": {
          "total": {
            "logs/run_logs.txt": 0,
            "null": 0,
            "README.md": 13,
            "credentials.py": 3,
            "credentials.pyc": 0,
            "database/additional_tools/domains_db.py": 12,
            "tools/dependencies/sublister": 0,
            "main.py": 0,
            "install.sh": 7,
            "web/setup.sh": 48,
            "telegram/setup.py": 1,
            "run.py": 0,
            "tools/online.py": 5
          },
          "max": {
            "logs/run_logs.txt": 0,
            "null": 0,
            "README.md": 5,
            "credentials.py": 3,
            "credentials.pyc": 0,
            "database/additional_tools/domains_db.py": 7,
            "tools/dependencies/sublister": 0,
            "main.py": 0,
            "install.sh": 7,
            "web/setup.sh": 48,
            "telegram/setup.py": 1,
            "run.py": 0,
            "tools/online.py": 5
          },
          "avg": {
            "logs/run_logs.txt": 0,
            "null": 0,
            "README.md": 2,
            "credentials.py": 3,
            "credentials.pyc": 0,
            "database/additional_tools/domains_db.py": 3,
            "tools/dependencies/sublister": 0,
            "main.py": 0,
            "install.sh": 7,
            "web/setup.sh": 24,
            "telegram/setup.py": 1,
            "run.py": 0,
            "tools/online.py": 5
          }
        },
        "noop_removed": {
          "total": {
            "logs/run_logs.txt": 0,
            "null": 3,
            "README.md": 1,
            "credentials.py": 0,
            "credentials.pyc": 0,
            "database/additional_tools/domains_db.py": 2,
            "tools/dependencies/sublister": 0,
            "main.py": 0,
            "install.sh": 0,
            "web/setup.sh": 0,
            "telegram/setup.py": 0,
            "run.py": 0,
            "tools/online.py": 2
          },
          "max": {
            "logs/run_logs.txt": 0,
            "null": 3,
            "README.md": 1,
            "credentials.py": 0,
            "credentials.pyc": 0,
            "database/additional_tools/domains_db.py": 1,
            "tools/dependencies/sublister": 0,
            "main.py": 0,
            "install.sh": 0,
            "web/setup.sh": 0,
            "telegram/setup.py": 0,
            "run.py": 0,
            "tools/online.py": 2
          },
          "avg": {
            "logs/run_logs.txt": 0,
            "null": 1,
            "README.md": 0,
            "credentials.py": 0,
            "credentials.pyc": 0,
            "database/additional_tools/domains_db.py": 0,
            "tools/dependencies/sublister": 0,
            "main.py": 0,
            "install.sh": 0,
            "web/setup.sh": 0,
            "telegram/setup.py": 0,
            "run.py": 0,
            "tools/online.py": 2
          }
        }
      }
    },
    "quality": {
      "code_churn": {
        "total_churn": {
          "count": 569,
          "max": 319,
          "avg": 41
        },
        "net_churn": {
          "count": 407,
          "max": 317,
          "avg": 29
        },
        "added_removed": {
          "added": 488,
          "removed": 81
        },
        "true_churn": {
          "overall": {
            "contribution": 488,
            "churn": 42
          },
          "per_author": {
            "RJP": {
              "contribution": 444,
              "churn": 41
            },
            "003random": {
              "contribution": 44,
              "churn": 1
            }
          },
          "per_file": {
            "logs/run_logs.txt": {
              "contribution": 2,
              "churn": 0
            },
            "run_logs.txt": {
              "contribution": 0,
              "churn": 0
            },
            "README.md": {
              "contribution": 58,
              "churn": 17
            },
            "credentials.py": {
              "contribution": 9,
              "churn": 9
            },
            "credentials.pyc": {
              "contribution": 0,
              "churn": 0
            },
            "database/additional_tools/domains_db.py": {
              "contribution": 56,
              "churn": 15
            },
            "tools/dependencies/sublister": {
              "contribution": 1,
              "churn": 0
            },
            "main.py": {
              "contribution": 1,
              "churn": 0
            },
            "sublister": {
              "contribution": 0,
              "churn": 0
            },
            "install.sh": {
              "contribution": 20,
              "churn": 0
            },
            "web/setup.sh": {
              "contribution": 318,
              "churn": 1
            },
            "telegram/setup.py": {
              "contribution": 2,
              "churn": 0
            },
            "run.py": {
              "contribution": 1,
              "churn": 0
            },
            "tools/online.py": {
              "contribution": 20,
              "churn": 0
            }
          }
        }
      },
      "bugs": {
        "bug_work_percent_by_file": {
          "logs/run_logs.txt": 0.0,
          "null": 0.0,
          "README.md": 0.0,
          "credentials.py": 0.0,
          "credentials.pyc": 0,
          "database/additional_tools/domains_db.py": 0.0,
          "tools/dependencies/sublister": 0.0,
          "main.py": 0.0,
          "install.sh": 0.0,
          "web/setup.sh": 0.0,
          "telegram/setup.py": 0.0,
          "run.py": 0.0,
          "tools/online.py": 0.0
        },
        "overall_bug_work_percent": 0.0,
        "total_bug_lines": 0,
        "total_lines": 569
      },
      "code_movement": {
        "moved_lines_count": 0,
        "copy_pasted_lines_count": 29,
        "total_changed_lines": 407,
        "moved_lines_percent": 0.0,
        "copy_pasted_lines_percent": 7.125307125307126
      },
      "test_doc_pct": {
        "test_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0.0
        },
        "doc_coverage": {
          "files": 2,
          "lines": 290,
          "percent": 17.543859649122805
        },
        "total": {
          "files": 12,
          "lines": 1653
        },
        "quality_score": 8.771929824561402
      },
      "meaningful_code": {
        "total": {
          "files": 12,
          "lines": 1653,
          "meaningful_lines": 1021,
          "meaningful_percent": 61.766485178463405
        },
        "quality_score": 8.771929824561402,
        "unrealistic_commits": {
          "large_commits": 0,
          "rapid_large_commits": 0,
          "total": 0,
          "skipped_lines": 569
        },
        "auto_generated": {
          "long_sequences": 0,
          "repeated_chars": 14,
          "repetitive_patterns": 0,
          "total": 14,
          "percent": 0.8469449485783425
        }
      }
    },
    "timings": {
      "diff_delta": {
        "rjp@debian8svm.debian8svm": {
          "total_diff_delta": 305.6,
          "total_commits": 9,
          "weekly_velocity": {
            "2018-05-28": {
              "diff_delta": 278.25,
              "lines_added": 264,
              "lines_updated": 10,
              "lines_deleted": 25,
              "lines_moved": 5,
              "commits": 7,
              "files_changed": 10,
              "active_days": 2,
              "velocity_per_day": 139.125
            },
            "2018-06-04": {
              "diff_delta": 27.35,
              "lines_added": 22,
              "lines_updated": 3,
              "lines_deleted": 8,
              "lines_moved": 11,
              "commits": 2,
              "files_changed": 2,
              "active_days": 2,
              "velocity_per_day": 13.675
            }
          }
        },
        "003random@protonmail.com": {
          "total_diff_delta": 40.85,
          "total_commits": 6,
          "weekly_velocity": {
            "2018-06-04": {
              "diff_delta": 40.85,
              "lines_added": 26,
              "lines_updated": 11,
              "lines_deleted": 24,
              "lines_moved": 6,
              "commits": 6,
              "files_changed": 3,
              "active_days": 1,
              "velocity_per_day": 40.85
            }
          }
        }
      },
      "code_provenance": {
        "rjp@debian8svm.debian8svm": {
          "weekly_provenance": {
            "2018-05-28": {
              "new_code_lines": 12,
              "recent_code_lines": 0,
              "old_code_lines": 1,
              "legacy_code_lines": 0,
              "total_lines": 13,
              "new_code_percent": 92.3076923076923,
              "recent_code_percent": 0.0,
              "old_code_percent": 7.6923076923076925,
              "legacy_code_percent": 0.0
            },
            "2018-06-04": {
              "new_code_lines": 13,
              "recent_code_lines": 0,
              "old_code_lines": 12,
              "legacy_code_lines": 0,
              "total_lines": 25,
              "new_code_percent": 52.0,
              "recent_code_percent": 0.0,
              "old_code_percent": 48.0,
              "legacy_code_percent": 0.0
            }
          }
        },
        "003random@protonmail.com": {
          "weekly_provenance": {
            "2018-06-04": {
              "new_code_lines": 12,
              "recent_code_lines": 0,
              "old_code_lines": 4,
              "legacy_code_lines": 0,
              "total_lines": 16,
              "new_code_percent": 75.0,
              "recent_code_percent": 0.0,
              "old_code_percent": 25.0,
              "legacy_code_percent": 0.0
            }
          }
        }
      },
      "developer_hours": {
        "rjp@debian8svm.debian8svm": {
          "total_estimated_hours": 4.803861111111112,
          "total_sessions": 4,
          "weekly_hours": {
            "2018-W22": {
              "estimated_hours": 3.57,
              "sessions": 2,
              "commits": 7,
              "hours_per_day": 3.57
            },
            "2018-W23": {
              "estimated_hours": 1.24,
              "sessions": 2,
              "commits": 2,
              "hours_per_day": 0.62
            }
          }
        },
        "003random@protonmail.com": {
          "total_estimated_hours": 1.5491388888888888,
          "total_sessions": 2,
          "weekly_hours": {
            "2018-W23": {
              "estimated_hours": 1.55,
              "sessions": 2,
              "commits": 6,
              "hours_per_day": 1.55
            }
          }
        }
      },
      "code_domain": {
        "rjp@debian8svm.debian8svm": {
          "total_by_domain": {
            "docs": 56,
            "backend": 97,
            "other": 2,
            "devops": 340
          },
          "weekly_domains": {
            "2018-05-28": {
              "domains": {
                "docs": 56,
                "backend": 32,
                "other": 2,
                "devops": 334
              },
              "total_changes": 424,
              "percentages": {
                "docs": 13.20754716981132,
                "backend": 7.547169811320755,
                "other": 0.4716981132075472,
                "devops": 78.77358490566037
              }
            },
            "2018-06-04": {
              "domains": {
                "backend": 65,
                "devops": 6
              },
              "total_changes": 71,
              "percentages": {
                "backend": 91.54929577464789,
                "devops": 8.450704225352112
              }
            }
          },
          "domain_percentages": {
            "docs": 11.313131313131313,
            "backend": 19.5959595959596,
            "other": 0.40404040404040403,
            "devops": 68.68686868686868
          }
        },
        "003random@protonmail.com": {
          "total_by_domain": {
            "docs": 25,
            "backend": 49
          },
          "weekly_domains": {
            "2018-06-04": {
              "domains": {
                "docs": 25,
                "backend": 49
              },
              "total_changes": 74,
              "percentages": {
                "docs": 33.78378378378378,
                "backend": 66.21621621621621
              }
            }
          },
          "domain_percentages": {
            "docs": 33.78378378378378,
            "backend": 66.21621621621621
          }
        }
      },
      "comprehensive_time_analysis": {
        "rjp@debian8svm.debian8svm": {
          "basic_stats": {
            "total_commits": 9,
            "total_repos": 1,
            "first_commit_date": "2018-05-31T11:08:34+02:00",
            "last_commit_date": "2018-06-05T14:42:32+02:00",
            "total_span_days": 5.15,
            "commits_per_day": 1.748,
            "total_lines_changed": 495,
            "total_files_changed": 21
          },
          "timing_patterns": {
            "mean_interval_hours": 15.45,
            "median_interval_hours": 0.82,
            "min_interval_minutes": 1.53,
            "max_interval_days": 3.96
          },
          "work_sessions": {
            "session_count": 4,
            "avg_session_length_hours": 0.46,
            "max_session_length_hours": 1.33,
            "avg_commits_per_session": 2.25,
            "max_commits_per_session": 4,
            "sessions": [
              {
                "start": "2018-05-31T11:08:34+02:00",
                "end": "2018-05-31T12:28:33+02:00",
                "length_hours": 1.33,
                "commits": 4
              },
              {
                "start": "2018-05-31T23:38:52+02:00",
                "end": "2018-06-01T00:10:22+02:00",
                "length_hours": 0.53,
                "commits": 3
              },
              {
                "start": "2018-06-04T23:15:30+02:00",
                "end": "2018-06-04T23:15:30+02:00",
                "length_hours": 0.0,
                "commits": 1
              },
              {
                "start": "2018-06-05T14:42:32+02:00",
                "end": "2018-06-05T14:42:32+02:00",
                "length_hours": 0.0,
                "commits": 1
              }
            ]
          },
          "daily_patterns": {
            "peak_day": 3,
            "peak_day_count": 6,
            "day_distribution": {
              "3": 6,
              "4": 1,
              "0": 1,
              "1": 1
            }
          },
          "weekly_patterns": {
            "total_weeks": 2,
            "avg_activities_per_week": 4.5,
            "max_activities_per_week": 7,
            "min_activities_per_week": 2
          },
          "downtime_analysis": {
            "short_breaks_count": 5,
            "long_breaks_count": 1,
            "avg_break_hours": 15.445763888888889
          },
          "rhythm_analysis": {
            "activities_per_day": 1.5,
            "consistency_score": 0.0
          },
          "sustained_activity": {
            "total_active_days": 4,
            "max_consecutive_days": 2,
            "avg_activities_per_active_day": 2.25
          }
        },
        "003random@protonmail.com": {
          "basic_stats": {
            "total_commits": 6,
            "total_repos": 1,
            "first_commit_date": "2018-06-05T12:43:12+00:00",
            "last_commit_date": "2018-06-05T19:05:00+00:00",
            "total_span_days": 0.27,
            "commits_per_day": 6.0,
            "total_lines_changed": 74,
            "total_files_changed": 6
          },
          "timing_patterns": {
            "mean_interval_hours": 1.27,
            "median_interval_hours": 0.03,
            "min_interval_minutes": 0.48,
            "max_interval_days": 0.26
          },
          "work_sessions": {
            "session_count": 2,
            "avg_session_length_hours": 0.07,
            "max_session_length_hours": 0.15,
            "avg_commits_per_session": 3,
            "max_commits_per_session": 5,
            "sessions": [
              {
                "start": "2018-06-05T12:43:12+00:00",
                "end": "2018-06-05T12:52:01+00:00",
                "length_hours": 0.15,
                "commits": 5
              },
              {
                "start": "2018-06-05T19:05:00+00:00",
                "end": "2018-06-05T19:05:00+00:00",
                "length_hours": 0.0,
                "commits": 1
              }
            ]
          },
          "daily_patterns": {
            "peak_day": 1,
            "peak_day_count": 6,
            "day_distribution": {
              "1": 6
            }
          },
          "weekly_patterns": {
            "total_weeks": 1,
            "avg_activities_per_week": 6,
            "max_activities_per_week": 6,
            "min_activities_per_week": 6
          },
          "downtime_analysis": {
            "short_breaks_count": 4,
            "long_breaks_count": 0,
            "avg_break_hours": 1.2726666666666666
          },
          "rhythm_analysis": {
            "activities_per_day": 6.0,
            "consistency_score": 0.0
          },
          "sustained_activity": {
            "total_active_days": 1,
            "max_consecutive_days": 1,
            "avg_activities_per_active_day": 6.0
          }
        }
      }
    }
  },
  "Week_11_2018-06-07": {
    "productivity": {
      "change_set": {
        "max": 0,
        "avg": 0
      },
      "commits_count": {},
      "contributors_count": {
        "total": {},
        "minor": {}
      },
      "contributors_experience": {},
      "hunks_count": {},
      "lines_count": {
        "added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "removed": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_removed": {
          "total": {},
          "max": {},
          "avg": {}
        }
      }
    },
    "quality": {
      "code_churn": {
        "total_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "net_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "added_removed": {
          "added": 0,
          "removed": 0
        },
        "true_churn": {
          "overall": {
            "contribution": 0,
            "churn": 0
          },
          "per_author": {},
          "per_file": {}
        }
      },
      "bugs": {
        "bug_work_percent_by_file": {},
        "overall_bug_work_percent": 0,
        "total_bug_lines": 0,
        "total_lines": 0
      },
      "code_movement": {
        "moved_lines_count": 0,
        "copy_pasted_lines_count": 0,
        "total_changed_lines": 0,
        "moved_lines_percent": 0,
        "copy_pasted_lines_percent": 0
      },
      "test_doc_pct": {
        "test_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "doc_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "total": {
          "files": 0,
          "lines": 0
        },
        "quality_score": 0.0
      },
      "meaningful_code": {
        "total": {
          "files": 0,
          "lines": 0,
          "meaningful_lines": 0,
          "meaningful_percent": 0
        },
        "quality_score": 0.0,
        "unrealistic_commits": {
          "large_commits": 0,
          "rapid_large_commits": 0,
          "total": 0,
          "skipped_lines": 0
        },
        "auto_generated": {
          "long_sequences": 0,
          "repeated_chars": 0,
          "repetitive_patterns": 0,
          "total": 0,
          "percent": 0
        }
      }
    },
    "timings": {
      "diff_delta": {},
      "code_provenance": {},
      "developer_hours": {},
      "code_domain": {},
      "comprehensive_time_analysis": {}
    }
  },
  "Week_12_2018-06-14": {
    "productivity": {
      "change_set": {
        "max": 1,
        "avg": 0.9090909090909091
      },
      "commits_count": {
        "README.md": 5,
        "credentials.pyc": 1,
        "telegram/bot.py": 4
      },
      "contributors_count": {
        "total": {
          "README.md": 2,
          "telegram/bot.py": 1
        },
        "minor": {
          "README.md": 0,
          "telegram/bot.py": 0
        }
      },
      "contributors_experience": {
        "README.md": 2,
        "credentials.pyc": 1,
        "telegram/bot.py": 1
      },
      "hunks_count": {
        "README.md": 1,
        "credentials.pyc": 0,
        "telegram/bot.py": 5.0
      },
      "lines_count": {
        "added": {
          "total": {
            "README.md": 64,
            "credentials.pyc": 0,
            "telegram/bot.py": 117
          },
          "max": {
            "README.md": 29,
            "credentials.pyc": 0,
            "telegram/bot.py": 106
          },
          "avg": {
            "README.md": 13,
            "credentials.pyc": 0,
            "telegram/bot.py": 29
          }
        },
        "removed": {
          "total": {
            "README.md": 27,
            "credentials.pyc": 0,
            "telegram/bot.py": 32
          },
          "max": {
            "README.md": 19,
            "credentials.pyc": 0,
            "telegram/bot.py": 21
          },
          "avg": {
            "README.md": 5,
            "credentials.pyc": 0,
            "telegram/bot.py": 8
          }
        },
        "noop_added": {
          "total": {
            "README.md": 24,
            "credentials.pyc": 0,
            "telegram/bot.py": 27
          },
          "max": {
            "README.md": 13,
            "credentials.pyc": 0,
            "telegram/bot.py": 27
          },
          "avg": {
            "README.md": 5,
            "credentials.pyc": 0,
            "telegram/bot.py": 7
          }
        },
        "noop_removed": {
          "total": {
            "README.md": 7,
            "credentials.pyc": 0,
            "telegram/bot.py": 0
          },
          "max": {
            "README.md": 4,
            "credentials.pyc": 0,
            "telegram/bot.py": 0
          },
          "avg": {
            "README.md": 1,
            "credentials.pyc": 0,
            "telegram/bot.py": 0
          }
        }
      }
    },
    "quality": {
      "code_churn": {
        "total_churn": {
          "count": 240,
          "max": 149,
          "avg": 80
        },
        "net_churn": {
          "count": 122,
          "max": 85,
          "avg": 41
        },
        "added_removed": {
          "added": 181,
          "removed": 59
        },
        "true_churn": {
          "overall": {
            "contribution": 181,
            "churn": 21
          },
          "per_author": {
            "003random": {
              "contribution": 156,
              "churn": 21
            },
            "streaak": {
              "contribution": 25,
              "churn": 0
            }
          },
          "per_file": {
            "README.md": {
              "contribution": 64,
              "churn": 10
            },
            "credentials.pyc": {
              "contribution": 0,
              "churn": 0
            },
            "telegram/bot.py": {
              "contribution": 117,
              "churn": 11
            }
          }
        }
      },
      "bugs": {
        "bug_work_percent_by_file": {
          "README.md": 0.0,
          "credentials.pyc": 0,
          "telegram/bot.py": 0.0
        },
        "overall_bug_work_percent": 0.0,
        "total_bug_lines": 0,
        "total_lines": 240
      },
      "code_movement": {
        "moved_lines_count": 0,
        "copy_pasted_lines_count": 27,
        "total_changed_lines": 170,
        "moved_lines_percent": 0.0,
        "copy_pasted_lines_percent": 15.88235294117647
      },
      "test_doc_pct": {
        "test_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0.0
        },
        "doc_coverage": {
          "files": 1,
          "lines": 413,
          "percent": 19.362400375058602
        },
        "total": {
          "files": 3,
          "lines": 2133
        },
        "quality_score": 9.681200187529301
      },
      "meaningful_code": {
        "total": {
          "files": 3,
          "lines": 2133,
          "meaningful_lines": 1400,
          "meaningful_percent": 65.63525550867323
        },
        "quality_score": 9.681200187529301,
        "unrealistic_commits": {
          "large_commits": 0,
          "rapid_large_commits": 0,
          "total": 0,
          "skipped_lines": 240
        },
        "auto_generated": {
          "long_sequences": 0,
          "repeated_chars": 4,
          "repetitive_patterns": 0,
          "total": 4,
          "percent": 0.1875293014533521
        }
      }
    },
    "timings": {
      "diff_delta": {
        "003random@protonmail.com": {
          "total_diff_delta": 121.9,
          "total_commits": 10,
          "weekly_velocity": {
            "2018-06-11": {
              "diff_delta": 121.9,
              "lines_added": 89,
              "lines_updated": 31,
              "lines_deleted": 33,
              "lines_moved": 14,
              "commits": 10,
              "files_changed": 3,
              "active_days": 3,
              "velocity_per_day": 40.63333333333333
            }
          }
        },
        "streaksterz@gmail.com": {
          "total_diff_delta": 17.0,
          "total_commits": 1,
          "weekly_velocity": {
            "2018-06-11": {
              "diff_delta": 17.0,
              "lines_added": 17,
              "lines_updated": 0,
              "lines_deleted": 0,
              "lines_moved": 0,
              "commits": 1,
              "files_changed": 1,
              "active_days": 1,
              "velocity_per_day": 17.0
            }
          }
        }
      },
      "code_provenance": {
        "003random@protonmail.com": {
          "weekly_provenance": {
            "2018-06-11": {
              "new_code_lines": 51,
              "recent_code_lines": 0,
              "old_code_lines": 36,
              "legacy_code_lines": 0,
              "total_lines": 87,
              "new_code_percent": 58.620689655172406,
              "recent_code_percent": 0.0,
              "old_code_percent": 41.37931034482759,
              "legacy_code_percent": 0.0
            }
          }
        }
      },
      "developer_hours": {
        "003random@protonmail.com": {
          "total_estimated_hours": 3.288138888888889,
          "total_sessions": 4,
          "weekly_hours": {
            "2018-W24": {
              "estimated_hours": 3.29,
              "sessions": 4,
              "commits": 10,
              "hours_per_day": 1.1
            }
          }
        },
        "streaksterz@gmail.com": {
          "total_estimated_hours": 0.61875,
          "total_sessions": 1,
          "weekly_hours": {
            "2018-W24": {
              "estimated_hours": 0.62,
              "sessions": 1,
              "commits": 1,
              "hours_per_day": 0.62
            }
          }
        }
      },
      "code_domain": {
        "003random@protonmail.com": {
          "total_by_domain": {
            "docs": 66,
            "backend": 149
          },
          "weekly_domains": {
            "2018-06-11": {
              "domains": {
                "docs": 66,
                "backend": 149
              },
              "total_changes": 215,
              "percentages": {
                "docs": 30.697674418604652,
                "backend": 69.30232558139535
              }
            }
          },
          "domain_percentages": {
            "docs": 30.697674418604652,
            "backend": 69.30232558139535
          }
        },
        "streaksterz@gmail.com": {
          "total_by_domain": {
            "docs": 25
          },
          "weekly_domains": {
            "2018-06-11": {
              "domains": {
                "docs": 25
              },
              "total_changes": 25,
              "percentages": {
                "docs": 100.0
              }
            }
          },
          "domain_percentages": {
            "docs": 100.0
          }
        }
      },
      "comprehensive_time_analysis": {
        "003random@protonmail.com": {
          "basic_stats": {
            "total_commits": 10,
            "total_repos": 1,
            "first_commit_date": "2018-06-14T11:40:44+02:00",
            "last_commit_date": "2018-06-16T16:25:27+00:00",
            "total_span_days": 2.28,
            "commits_per_day": 4.384,
            "total_lines_changed": 215,
            "total_files_changed": 9
          },
          "timing_patterns": {
            "mean_interval_hours": 6.08,
            "median_interval_hours": 0.06,
            "min_interval_minutes": 0.57,
            "max_interval_days": 1.22
          },
          "work_sessions": {
            "session_count": 4,
            "avg_session_length_hours": 0.07,
            "max_session_length_hours": 0.17,
            "avg_commits_per_session": 2.5,
            "max_commits_per_session": 4,
            "sessions": [
              {
                "start": "2018-06-14T11:40:44+02:00",
                "end": "2018-06-14T11:44:13+02:00",
                "length_hours": 0.06,
                "commits": 2
              },
              {
                "start": "2018-06-14T18:31:00+00:00",
                "end": "2018-06-14T18:31:00+00:00",
                "length_hours": 0.0,
                "commits": 1
              },
              {
                "start": "2018-06-15T13:00:44+02:00",
                "end": "2018-06-15T13:11:04+02:00",
                "length_hours": 0.17,
                "commits": 4
              },
              {
                "start": "2018-06-16T16:23:38+00:00",
                "end": "2018-06-16T16:25:27+00:00",
                "length_hours": 0.03,
                "commits": 3
              }
            ]
          },
          "daily_patterns": {
            "peak_day": 4,
            "peak_day_count": 4,
            "day_distribution": {
              "3": 3,
              "4": 4,
              "5": 3
            }
          },
          "weekly_patterns": {
            "total_weeks": 1,
            "avg_activities_per_week": 10,
            "max_activities_per_week": 10,
            "min_activities_per_week": 10
          },
          "downtime_analysis": {
            "short_breaks_count": 6,
            "long_breaks_count": 1,
            "avg_break_hours": 6.082808641975309
          },
          "rhythm_analysis": {
            "activities_per_day": 3.3333333333333335,
            "consistency_score": 0.0
          },
          "sustained_activity": {
            "total_active_days": 3,
            "max_consecutive_days": 3,
            "avg_activities_per_active_day": 3.3333333333333335
          }
        }
      }
    }
  },
  "Week_13_2018-06-21": {
    "productivity": {
      "change_set": {
        "max": 0,
        "avg": 0
      },
      "commits_count": {},
      "contributors_count": {
        "total": {},
        "minor": {}
      },
      "contributors_experience": {},
      "hunks_count": {},
      "lines_count": {
        "added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "removed": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_removed": {
          "total": {},
          "max": {},
          "avg": {}
        }
      }
    },
    "quality": {
      "code_churn": {
        "total_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "net_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "added_removed": {
          "added": 0,
          "removed": 0
        },
        "true_churn": {
          "overall": {
            "contribution": 0,
            "churn": 0
          },
          "per_author": {},
          "per_file": {}
        }
      },
      "bugs": {
        "bug_work_percent_by_file": {},
        "overall_bug_work_percent": 0,
        "total_bug_lines": 0,
        "total_lines": 0
      },
      "code_movement": {
        "moved_lines_count": 0,
        "copy_pasted_lines_count": 0,
        "total_changed_lines": 0,
        "moved_lines_percent": 0,
        "copy_pasted_lines_percent": 0
      },
      "test_doc_pct": {
        "test_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "doc_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "total": {
          "files": 0,
          "lines": 0
        },
        "quality_score": 0.0
      },
      "meaningful_code": {
        "total": {
          "files": 0,
          "lines": 0,
          "meaningful_lines": 0,
          "meaningful_percent": 0
        },
        "quality_score": 0.0,
        "unrealistic_commits": {
          "large_commits": 0,
          "rapid_large_commits": 0,
          "total": 0,
          "skipped_lines": 0
        },
        "auto_generated": {
          "long_sequences": 0,
          "repeated_chars": 0,
          "repetitive_patterns": 0,
          "total": 0,
          "percent": 0
        }
      }
    },
    "timings": {
      "diff_delta": {},
      "code_provenance": {},
      "developer_hours": {},
      "code_domain": {},
      "comprehensive_time_analysis": {}
    }
  },
  "Week_14_2018-06-28": {
    "productivity": {
      "change_set": {
        "max": 0,
        "avg": 0
      },
      "commits_count": {},
      "contributors_count": {
        "total": {},
        "minor": {}
      },
      "contributors_experience": {},
      "hunks_count": {},
      "lines_count": {
        "added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "removed": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_added": {
          "total": {},
          "max": {},
          "avg": {}
        },
        "noop_removed": {
          "total": {},
          "max": {},
          "avg": {}
        }
      }
    },
    "quality": {
      "code_churn": {
        "total_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "net_churn": {
          "count": 0,
          "max": 0,
          "avg": 0
        },
        "added_removed": {
          "added": 0,
          "removed": 0
        },
        "true_churn": {
          "overall": {
            "contribution": 0,
            "churn": 0
          },
          "per_author": {},
          "per_file": {}
        }
      },
      "bugs": {
        "bug_work_percent_by_file": {},
        "overall_bug_work_percent": 0,
        "total_bug_lines": 0,
        "total_lines": 0
      },
      "code_movement": {
        "moved_lines_count": 0,
        "copy_pasted_lines_count": 0,
        "total_changed_lines": 0,
        "moved_lines_percent": 0,
        "copy_pasted_lines_percent": 0
      },
      "test_doc_pct": {
        "test_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "doc_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0
        },
        "total": {
          "files": 0,
          "lines": 0
        },
        "quality_score": 0.0
      },
      "meaningful_code": {
        "total": {
          "files": 0,
          "lines": 0,
          "meaningful_lines": 0,
          "meaningful_percent": 0
        },
        "quality_score": 0.0,
        "unrealistic_commits": {
          "large_commits": 0,
          "rapid_large_commits": 0,
          "total": 0,
          "skipped_lines": 0
        },
        "auto_generated": {
          "long_sequences": 0,
          "repeated_chars": 0,
          "repetitive_patterns": 0,
          "total": 0,
          "percent": 0
        }
      }
    },
    "timings": {
      "diff_delta": {},
      "code_provenance": {},
      "developer_hours": {},
      "code_domain": {},
      "comprehensive_time_analysis": {}
    }
  },
  "Week_15_2018-07-05": {
    "productivity": {
      "change_set": {
        "max": 2,
        "avg": 1.5
      },
      "commits_count": {
        "telegram/bot.py": 1,
        "telegram/notify.py": 1,
        "database/additional_tools/domains_db.py": 1
      },
      "contributors_count": {
        "total": {
          "telegram/bot.py": 1,
          "telegram/notify.py": 1,
          "database/additional_tools/domains_db.py": 1
        },
        "minor": {
          "telegram/bot.py": 0,
          "telegram/notify.py": 0,
          "database/additional_tools/domains_db.py": 0
        }
      },
      "contributors_experience": {
        "telegram/bot.py": 1,
        "telegram/notify.py": 1,
        "database/additional_tools/domains_db.py": 1
      },
      "hunks_count": {
        "telegram/bot.py": 2,
        "telegram/notify.py": 4,
        "database/additional_tools/domains_db.py": 1
      },
      "lines_count": {
        "added": {
          "total": {
            "telegram/bot.py": 2,
            "telegram/notify.py": 14,
            "database/additional_tools/domains_db.py": 2
          },
          "max": {
            "telegram/bot.py": 2,
            "telegram/notify.py": 14,
            "database/additional_tools/domains_db.py": 2
          },
          "avg": {
            "telegram/bot.py": 2,
            "telegram/notify.py": 14,
            "database/additional_tools/domains_db.py": 2
          }
        },
        "removed": {
          "total": {
            "telegram/bot.py": 2,
            "telegram/notify.py": 4,
            "database/additional_tools/domains_db.py": 0
          },
          "max": {
            "telegram/bot.py": 2,
            "telegram/notify.py": 4,
            "database/additional_tools/domains_db.py": 0
          },
          "avg": {
            "telegram/bot.py": 2,
            "telegram/notify.py": 4,
            "database/additional_tools/domains_db.py": 0
          }
        },
        "noop_added": {
          "total": {
            "telegram/bot.py": 0,
            "telegram/notify.py": 2,
            "database/additional_tools/domains_db.py": 0
          },
          "max": {
            "telegram/bot.py": 0,
            "telegram/notify.py": 2,
            "database/additional_tools/domains_db.py": 0
          },
          "avg": {
            "telegram/bot.py": 0,
            "telegram/notify.py": 2,
            "database/additional_tools/domains_db.py": 0
          }
        },
        "noop_removed": {
          "total": {
            "telegram/bot.py": 0,
            "telegram/notify.py": 0,
            "database/additional_tools/domains_db.py": 0
          },
          "max": {
            "telegram/bot.py": 0,
            "telegram/notify.py": 0,
            "database/additional_tools/domains_db.py": 0
          },
          "avg": {
            "telegram/bot.py": 0,
            "telegram/notify.py": 0,
            "database/additional_tools/domains_db.py": 0
          }
        }
      }
    },
    "quality": {
      "code_churn": {
        "total_churn": {
          "count": 24,
          "max": 18,
          "avg": 8
        },
        "net_churn": {
          "count": 12,
          "max": 10,
          "avg": 4
        },
        "added_removed": {
          "added": 18,
          "removed": 6
        },
        "true_churn": {
          "overall": {
            "contribution": 18,
            "churn": 0
          },
          "per_author": {
            "RJP": {
              "contribution": 18,
              "churn": 0
            }
          },
          "per_file": {
            "telegram/bot.py": {
              "contribution": 2,
              "churn": 0
            },
            "telegram/notify.py": {
              "contribution": 14,
              "churn": 0
            },
            "database/additional_tools/domains_db.py": {
              "contribution": 2,
              "churn": 0
            }
          }
        }
      },
      "bugs": {
        "bug_work_percent_by_file": {
          "telegram/bot.py": 0.0,
          "telegram/notify.py": 0.0,
          "database/additional_tools/domains_db.py": 0.0
        },
        "overall_bug_work_percent": 0.0,
        "total_bug_lines": 0,
        "total_lines": 24
      },
      "code_movement": {
        "moved_lines_count": 0,
        "copy_pasted_lines_count": 0,
        "total_changed_lines": 20,
        "moved_lines_percent": 0.0,
        "copy_pasted_lines_percent": 0.0
      },
      "test_doc_pct": {
        "test_coverage": {
          "files": 0,
          "lines": 0,
          "percent": 0.0
        },
        "doc_coverage": {
          "files": 0,
          "lines": 40,
          "percent": 6.472491909385113
        },
        "total": {
          "files": 3,
          "lines": 618
        },
        "quality_score": 3.2362459546925564
      },
      "meaningful_code": {
        "total": {
          "files": 3,
          "lines": 618,
          "meaningful_lines": 476,
          "meaningful_percent": 77.02265372168284
        },
        "quality_score": 3.2362459546925564,
        "unrealistic_commits": {
          "large_commits": 0,
          "rapid_large_commits": 0,
          "total": 0,
          "skipped_lines": 24
        },
        "auto_generated": {
          "long_sequences": 0,
          "repeated_chars": 2,
          "repetitive_patterns": 0,
          "total": 2,
          "percent": 0.3236245954692557
        }
      }
    },
    "timings": {
      "diff_delta": {
        "rjp@debian8svm.debian8svm": {
          "total_diff_delta": 20.5,
          "total_commits": 2,
          "weekly_velocity": {
            "2018-07-09": {
              "diff_delta": 20.5,
              "lines_added": 16,
              "lines_updated": 4,
              "lines_deleted": 6,
              "lines_moved": 0,
              "commits": 2,
              "files_changed": 3,
              "active_days": 1,
              "velocity_per_day": 20.5
            }
          }
        }
      },
      "code_provenance": {
        "rjp@debian8svm.debian8svm": {
          "weekly_provenance": {
            "2018-07-09": {
              "new_code_lines": 9,
              "recent_code_lines": 0,
              "old_code_lines": 7,
              "legacy_code_lines": 0,
              "total_lines": 16,
              "new_code_percent": 56.25,
              "recent_code_percent": 0.0,
              "old_code_percent": 43.75,
              "legacy_code_percent": 0.0
            }
          }
        }
      },
      "developer_hours": {
        "rjp@debian8svm.debian8svm": {
          "total_estimated_hours": 0.917888888888889,
          "total_sessions": 1,
          "weekly_hours": {
            "2018-W28": {
              "estimated_hours": 0.92,
              "sessions": 1,
              "commits": 2,
              "hours_per_day": 0.92
            }
          }
        }
      },
      "code_domain": {
        "rjp@debian8svm.debian8svm": {
          "total_by_domain": {
            "backend": 24
          },
          "weekly_domains": {
            "2018-07-09": {
              "domains": {
                "backend": 24
              },
              "total_changes": 24,
              "percentages": {
                "backend": 100.0
              }
            }
          },
          "domain_percentages": {
            "backend": 100.0
          }
        }
      },
      "comprehensive_time_analysis": {
        "rjp@debian8svm.debian8svm": {
          "basic_stats": {
            "total_commits": 2,
            "total_repos": 1,
            "first_commit_date": "2018-07-11T00:20:59+02:00",
            "last_commit_date": "2018-07-11T00:26:03+02:00",
            "total_span_days": 0.0,
            "commits_per_day": 2.0,
            "total_lines_changed": 24,
            "total_files_changed": 3
          },
          "timing_patterns": {
            "mean_interval_hours": 0.08,
            "median_interval_hours": 0.08,
            "min_interval_minutes": 5.07,
            "max_interval_days": 0.0
          },
          "work_sessions": {
            "session_count": 1,
            "avg_session_length_hours": 0.08,
            "max_session_length_hours": 0.08,
            "avg_commits_per_session": 2,
            "max_commits_per_session": 2,
            "sessions": [
              {
                "start": "2018-07-11T00:20:59+02:00",
                "end": "2018-07-11T00:26:03+02:00",
                "length_hours": 0.08,
                "commits": 2
              }
            ]
          },
          "daily_patterns": {
            "peak_day": 2,
            "peak_day_count": 2,
            "day_distribution": {
              "2": 2
            }
          },
          "weekly_patterns": {
            "total_weeks": 1,
            "avg_activities_per_week": 2,
            "max_activities_per_week": 2,
            "min_activities_per_week": 2
          },
          "downtime_analysis": {
            "short_breaks_count": 1,
            "long_breaks_count": 0,
            "avg_break_hours": 0.08444444444444445
          },
          "rhythm_analysis": {
            "activities_per_day": 2.0,
            "consistency_score": 0.0
          },
          "sustained_activity": {
            "total_active_days": 1,
            "max_consecutive_days": 1,
            "avg_activities_per_active_day": 2.0
          }
        }
      }
    }
  },
  "developer_stats": {}
},
  "metrics_type": "weekly",
  "processing": {
    "total_commits": 43,
    "total_lines_added": 2052,
    "total_lines_removed": 340
  }
}
